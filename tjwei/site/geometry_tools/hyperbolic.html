<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geometry_tools.hyperbolic API documentation</title>
<meta name="description" content="Model objects in hyperbolic space with numerical coordinates â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geometry_tools.hyperbolic</code></h1>
</header>
<section id="section-intro">
<p>Model objects in hyperbolic space with numerical coordinates.</p>
<p>This module provides abstract versions of various objects in hyperbolic
geometry (points, line segments, polygons, isometries, etc.) and gives a
unified framework for <em>translating those objects by isometries</em> and <em>getting
their coordinates in various models of hyperbolic space.</em></p>
<p>For instance, to get a single point in the hyperbolic plane, use the <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
class:</p>
<pre><code class="python">from geometry_tools import hyperbolic

# get a point by providing kleinian coordinates
point = hyperbolic.Point([0.1, 0.0], model=hyperbolic.Model.KLEIN)
# or equivalently:
point = hyperbolic.get_point([0.1, 0.0], model=&quot;klein&quot;)

# get the poincare coordinates of this point.
point.coords(model=&quot;poincare&quot;)
</code></pre>
<pre><code>array([0.05012563, 0.        ])
</code></pre>
<p>The <code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code> class models isometries of hyperbolic space. The easiest way to
obtain an isometry of the hyperbolic plane is to use the isomorphism from
<span><span class="MathJax_Preview">\mathrm{PSL}(2, \mathbb{R})</span><script type="math/tex">\mathrm{PSL}(2, \mathbb{R})</script></span> to the (orientation-preserving) isometry group
of <span><span class="MathJax_Preview">\mathbb{H}^2</span><script type="math/tex">\mathbb{H}^2</script></span>.</p>
<pre><code class="python">from geometry_tools import hyperbolic

# get a loxodromic isometry and a point in H^2
hyp_iso = hyperbolic.sl2r_iso([[2., 0.], [0., -1./2]])
point = hyperbolic.get_point([0., 0.])

# apply the isometry to the point
(hyp_iso @ point).coords(model=&quot;halfplane&quot;)
</code></pre>
<pre><code>array([-0.  ,  0.25])
</code></pre>
<p>Most of the power of the <code><a title="geometry_tools.hyperbolic" href="#geometry_tools.hyperbolic">geometry_tools.hyperbolic</a></code> module comes from the
fact that you can easily and efficiently build <em>composite</em> hyperbolic objects
out of arrays of subobjects, and then translate the entire composite object
at once. For instance, we can build an array of points, and translate all of
those points by an isometry:</p>
<pre><code class="python">from geometry_tools import hyperbolic

# make two points in Klein coordinates
p1 = hyperbolic.Point([0., 0.1], model=&quot;klein&quot;)
p2 = hyperbolic.Point([0.1, 0.], model=&quot;klein&quot;)

# package these two points together into a single hyperbolic object
# (an array of points)
pts = hyperbolic.Point([p1, p2])

# get a parabolic isometry
iso = hyperbolic.sl2r_iso([[1., 1.], [0., 1.]])

(iso @ pts).coords(model=&quot;klein&quot;)
</code></pre>
<pre><code>array([[-0.375     ,  0.6875    ],
       [-0.29032258,  0.70967742]])
</code></pre>
<p>The data is returned as a 2x2 numpy array, giving x,y Kleinian coordinates for
the translated points.</p>
<p>Working with composite objects can be nice because it's a convenient way to
handle <em>orbits</em> of hyperbolic objects under groups of isometries. To see
this, we can use the <code><a title="geometry_tools.hyperbolic.HyperbolicRepresentation" href="#geometry_tools.hyperbolic.HyperbolicRepresentation">HyperbolicRepresentation</a></code> class to make a representation of
a free group, and then translate a pair of points by some words in the group.</p>
<pre><code class="python">from geometry_tools import hyperbolic
from numpy import pi

# make a free group representation by mapping the generators to loxodromic
# isometries with perpendicular axes
free_rep = hyperbolic.HyperbolicRepresentation()
free_rep[&quot;a&quot;] = hyperbolic.sl2r_iso([[3., 0], [0., 1./3]])
rot = hyperbolic.Isometry.standard_rotation(pi / 2)
free_rep[&quot;b&quot;] = rot @ free_rep[&quot;a&quot;] @ rot.inv()

# make a pair of points in hyperbolic space
pt = hyperbolic.Point([[0., 0.3],
                       [0.1, 0.0]], model=&quot;klein&quot;)

# get image of reduced words of length at most 3
words = free_rep.free_words_less_than(2)
isos = free_rep.isometries(words)

# get coordinates of points translated by these isometries.
# we have to specify &quot;pairwise&quot; argument because we want each
# isometry to apply to each point in our composite Point object.
(isos.apply(pt, &quot;pairwise&quot;)).coords(model=&quot;klein&quot;)
</code></pre>
<pre><code>array([[[ 0.00000000e+00,  3.00000000e-01],
    [ 1.00000000e-01,  0.00000000e+00]],

   [[-9.75609756e-01,  6.58536585e-02],
    [-9.70270270e-01,  0.00000000e+00]],

   [[ 9.75609756e-01,  6.58536585e-02],
    [ 9.80000000e-01,  0.00000000e+00]],

   [[-6.41883840e-17, -9.55172414e-01],
    [ 2.19512195e-02, -9.75609756e-01]],

   [[ 5.73042276e-17,  9.86792453e-01],
    [ 2.19512195e-02,  9.75609756e-01]]])
</code></pre>
<p>The coordinate data is returned as a 5x2x2 numpy array, since there are 5
isometries being applied to 2 points, each of which has 2 coordinates. To
flatten the output to a 10x2 array (representing an array of 10 points), we
could use <code><a title="geometry_tools.hyperbolic.HyperbolicObject.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">ProjectiveObject.flatten_to_unit()</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#34;&#34;&#34;Model objects in hyperbolic space with numerical coordinates.

This module provides abstract versions of various objects in hyperbolic
geometry (points, line segments, polygons, isometries, etc.) and gives a
unified framework for *translating those objects by isometries* and *getting
their coordinates in various models of hyperbolic space.*

For instance, to get a single point in the hyperbolic plane, use the `Point`
class:

```python
from geometry_tools import hyperbolic

# get a point by providing kleinian coordinates
point = hyperbolic.Point([0.1, 0.0], model=hyperbolic.Model.KLEIN)
# or equivalently:
point = hyperbolic.get_point([0.1, 0.0], model=&#34;klein&#34;)

# get the poincare coordinates of this point.
point.coords(model=&#34;poincare&#34;)
```
    array([0.05012563, 0.        ])

The `Isometry` class models isometries of hyperbolic space. The easiest way to
obtain an isometry of the hyperbolic plane is to use the isomorphism from
\(\mathrm{PSL}(2, \mathbb{R})\) to the (orientation-preserving) isometry group
 of \(\mathbb{H}^2\).

```python
from geometry_tools import hyperbolic

# get a loxodromic isometry and a point in H^2
hyp_iso = hyperbolic.sl2r_iso([[2., 0.], [0., -1./2]])
point = hyperbolic.get_point([0., 0.])

# apply the isometry to the point
(hyp_iso @ point).coords(model=&#34;halfplane&#34;)
```
    array([-0.  ,  0.25])


Most of the power of the `geometry_tools.hyperbolic` module comes from the
fact that you can easily and efficiently build *composite* hyperbolic objects
out of arrays of subobjects, and then translate the entire composite object
at once. For instance, we can build an array of points, and translate all of
those points by an isometry:

```python
from geometry_tools import hyperbolic

# make two points in Klein coordinates
p1 = hyperbolic.Point([0., 0.1], model=&#34;klein&#34;)
p2 = hyperbolic.Point([0.1, 0.], model=&#34;klein&#34;)

# package these two points together into a single hyperbolic object
# (an array of points)
pts = hyperbolic.Point([p1, p2])

# get a parabolic isometry
iso = hyperbolic.sl2r_iso([[1., 1.], [0., 1.]])

(iso @ pts).coords(model=&#34;klein&#34;)
```
    array([[-0.375     ,  0.6875    ],
           [-0.29032258,  0.70967742]])

The data is returned as a 2x2 numpy array, giving x,y Kleinian coordinates for
the translated points.

Working with composite objects can be nice because it&#39;s a convenient way to
handle *orbits* of hyperbolic objects under groups of isometries. To see
this, we can use the `HyperbolicRepresentation` class to make a representation of
a free group, and then translate a pair of points by some words in the group.

```python
from geometry_tools import hyperbolic
from numpy import pi

# make a free group representation by mapping the generators to loxodromic
# isometries with perpendicular axes
free_rep = hyperbolic.HyperbolicRepresentation()
free_rep[&#34;a&#34;] = hyperbolic.sl2r_iso([[3., 0], [0., 1./3]])
rot = hyperbolic.Isometry.standard_rotation(pi / 2)
free_rep[&#34;b&#34;] = rot @ free_rep[&#34;a&#34;] @ rot.inv()

# make a pair of points in hyperbolic space
pt = hyperbolic.Point([[0., 0.3],
                       [0.1, 0.0]], model=&#34;klein&#34;)

# get image of reduced words of length at most 3
words = free_rep.free_words_less_than(2)
isos = free_rep.isometries(words)

# get coordinates of points translated by these isometries.
# we have to specify &#34;pairwise&#34; argument because we want each
# isometry to apply to each point in our composite Point object.
(isos.apply(pt, &#34;pairwise&#34;)).coords(model=&#34;klein&#34;)
```
    array([[[ 0.00000000e+00,  3.00000000e-01],
        [ 1.00000000e-01,  0.00000000e+00]],

       [[-9.75609756e-01,  6.58536585e-02],
        [-9.70270270e-01,  0.00000000e+00]],

       [[ 9.75609756e-01,  6.58536585e-02],
        [ 9.80000000e-01,  0.00000000e+00]],

       [[-6.41883840e-17, -9.55172414e-01],
        [ 2.19512195e-02, -9.75609756e-01]],

       [[ 5.73042276e-17,  9.86792453e-01],
        [ 2.19512195e-02,  9.75609756e-01]]])

The coordinate data is returned as a 5x2x2 numpy array, since there are 5
isometries being applied to 2 points, each of which has 2 coordinates. To
flatten the output to a 10x2 array (representing an array of 10 points), we
could use `HyperbolicObject.flatten_to_unit()`.

&#34;&#34;&#34;


from copy import copy
from enum import Enum

import numpy as np

from geometry_tools import projective, representation, utils
from geometry_tools.projective import GeometryError

#arbitrary
ERROR_THRESHOLD = 1e-8
BOUNDARY_THRESHOLD = 1e-5

CHECK_LIGHT_CONE = False


class Model(Enum):
    &#34;&#34;&#34;Enumerate implemented models of hyperbolic space.

    Models can have different aliases, and can be compared to strings
    with the == operator, which returns `True` if the strings match
    any alias name (case insensitive).

    &#34;&#34;&#34;
    POINCARE = &#34;poincare&#34;
    KLEIN = &#34;klein&#34;
    KLEINIAN = &#34;klein&#34;
    AFFINE = &#34;klein&#34;
    HALFSPACE = &#34;halfspace&#34;
    HALFPLANE = &#34;halfspace&#34;
    HYPERBOLOID = &#34;hyperboloid&#34;
    PROJECTIVE = &#34;projective&#34;

    def aliases(self):
        &#34;&#34;&#34;List all of the different accepted names for this hyperbolic model.&#34;&#34;&#34;
        return [name for name, member in Model.__members__.items()
                if member is self]

    def __eq__(self, other):
        if self is other:
            return True

        try:
            if other.upper() in self.aliases():
                return True
        except AttributeError:
            pass

        return False

class HyperbolicObject(projective.ProjectiveObject):
    &#34;&#34;&#34;Model for an abstract object in hyperbolic space.

    Subclasses of HyperbolicObject model more specific objects in
    hyperbolic geometry, e.g. points, geodesic segments, hyperplanes,
    ideal points.

    Every object in hyperbolic space H^n has the underlying data of an
    ndarray whose last dimension is n+1. This is interpreted as a
    collection of (row) vectors in R^(n+1), or more precisely R^(n,1),
    which transforms via the action of the indefinite orthogonal group
    O(n,1).

    The last `unit_ndims` dimensions of this underlying array represent
    a single object in hyperbolic space, which transforms as a unit
    under the action of O(n,1). The remaining dimensions of the array
    are used to represent an array of such &#34;unit objects.&#34;

    &#34;&#34;&#34;

    @property
    def minkowski(self):
        return minkowski(self.dimension + 1)


    def coords(self, model, proj_data=None):
        &#34;&#34;&#34;Get or set a representation of this hyperbolic object in
        coordinates.

        For the base `HyperbolicObject` class, the available models
        are `Model.KLEIN` and `Model.PROJECTIVE`.

        Parameters
        ----------
        model : Model
            which model to take coordinates in
        proj_data : ndarray
            data for this hyperbolic object, interpreted as
            coordinates with respect to `model`. If `None`, just
            return coordinates.

        Raises
        ------
        GeometryError
            Raised if an unsupported model is specified.

        &#34;&#34;&#34;
        if model == Model.KLEIN:
            return self.kleinian_coords(proj_data)
        if model == Model.PROJECTIVE:
            return self.projective_coords(proj_data)

        raise GeometryError(
            &#34;Unimplemented model for an object of type {}: &#39;{}&#39;&#34;.format(
                self.__class__.__name__, model
            ))

    def kleinian_coords(self, aff_data=None):
        return self.affine_coords(aff_data, chart_index=0)

class Point(HyperbolicObject, projective.Point):
    &#34;&#34;&#34;Model for a point (or ndarray of points) in the closure of
    hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, point, model=Model.PROJECTIVE):
        &#34;&#34;&#34;

        Parameters
        ----------
        point : HyperbolicObject or iterable or ndarray
            Data used to construct a point or an array of points. If
            `point` is a `HyperbolicObject`, then use the underlying
            coordinate data to build an array of points. If `point` is
            an iterable of `HyperbolicObject`s, build a composite `Point`
            object out of this array. If `point` is an `ndarray`, then
            interpret this as coordinate data for an array of points
            in some hyperbolic model.
        model : Model
            if `point` is numerical data, then what model of
            hyperbolic space we should use to interpret `point` as
            coordinates.

        &#34;&#34;&#34;
        self.unit_ndims = 1
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(point)
            return
        except TypeError:
            pass

        self.coords(model, point)

    def hyperboloid_coords(self, proj_data=None):
        &#34;&#34;&#34;Get or set point coordinates in the hyperboloid model.

        Parameters
        ----------
        proj_data : ndarray
            Data to set coordinates to, in the hyperboloid
            model. The last dimension of the array is the
            dimension of the vector space R^(n,1). If `None`, do not
            update coordinates.

        Returns
        -------
        ndarray
            Hyperboloid coordinates for this point (or array of
            points).

        &#34;&#34;&#34;
        if proj_data is not None:
            self.set(proj_data)

        return hyperboloid_coords(self.proj_data)

    def poincare_coords(self, proj_data=None):
        &#34;&#34;&#34;Get or set point coordinates in the hyperboloid model.

        Parameters
        ----------
        proj_data : ndarray
            Data to set coordinates to, as points in projective space.
            The last dimension of the array is the dimension of the
            vector space R^(n,1). If `None`, do not update
            coordinates.

        Returns
        -------
        ndarray
            Projective coordinates for this point (or array of
            points).

        &#34;&#34;&#34;
        if proj_data is not None:
            klein = poincare_to_kleinian(np.array(proj_data))
            self.kleinian_coords(klein)

        return kleinian_to_poincare(self.kleinian_coords())

    def halfspace_coords(self, proj_data=None):
        &#34;&#34;&#34;Get or set point coordinates in the half-space model.

        Parameters
        ----------
        proj_data : ndarray
            Data to set coordinates to, as points in half-space.  The
            last dimension of the array is the dimension of hyperbolic
            space H^n. If `None`, do not update coordinates.

        Returns
        -------
        ndarray
            Half-space coordinates for this point (or array of
            points).

        &#34;&#34;&#34;
        poincare = None

        if proj_data is not None:
            poincare = halfspace_to_poincare(np.array(proj_data))

        poincare_coords = self.poincare_coords(poincare)
        return poincare_to_halfspace(poincare_coords)

    def coords(self, model, proj_data=None):
        &#34;&#34;&#34;Get or set a representation of this hyperbolic object in
        coordinates.

        The available models are `Model.KLEIN`, `Model.PROJECTIVE`,
        `Model.POINCARE`, `Model.HYPERBOLOID`, and `Model.HALFSPACE`.

        Parameters
        ----------
        model : Model
            which model to take coordinates in
        proj_data : ndarray
            data for this hyperbolic object, interpreted as
            coordinates with respect to `model`. If `None`, just
            return coordinates.

        Raises
        ------
        GeometryError
            Raised if an unsupported model is specified.

        &#34;&#34;&#34;
        try:
            return HyperbolicObject.coords(self, model, proj_data)
        except GeometryError as e:
            if model == Model.POINCARE:
                return self.poincare_coords(proj_data)
            if model == Model.HYPERBOLOID:
                return self.hyperboloid_coords(proj_data)
            if model == Model.HALFSPACE:
                return self.halfspace_coords(proj_data)
            raise e

    def distance(self, other):
        &#34;&#34;&#34;Compute hyperbolic distances between pairs of points, or pairs of
            arrays of points.

        Parameters
        ----------
        other : Point
            The point to compute distances to

        Returns
        -------
        ndarray
            distances in hyperbolic space between self and other

        &#34;&#34;&#34;
        #TODO: allow for pairwise distances
        products = utils.apply_bilinear(self.proj_data, other.proj_data,
                                        self.minkowski)

        return np.arccosh(np.abs(products))

    def origin_to(self):
        &#34;&#34;&#34;Get an isometry taking an &#34;origin&#34; point to this point

        Returns
        -------
        Isometry :
            Some isometry taking the point with Kleinian/Poincare
            coordinates (0, 0, ...) to this point. This isometry is
            not uniquely determined and is not guaranteed to be
            orientation-preserving.

        &#34;&#34;&#34;
        return timelike_to(self.proj_data)

    def unit_tangent_towards(self, other):
        &#34;&#34;&#34;Get a unit tangent vector with this basepoint, pointing at another point

        Parameters
        ----------
        other : Point
            another point in hyperbolic space where the unit tangent
            vector points

        Returns
        -------
        TangentVector
            A tangent vector with this point at its base and pointing
            towards `other`.

        &#34;&#34;&#34;
        diff = other.proj_data - self.proj_data
        return TangentVector(self, diff).normalized()

    def get_origin(dimension, shape=()):
        &#34;&#34;&#34;Get a point (or ndarray of points) at the &#34;origin&#34; of hyperbolic
           space

        Parameters
        ----------
        dimension : int
            Dimension of hyperbolic space where this point lives
        shape : tuple(int)
            Shape of array of origin points to get

        Returns
        -------
        Point
            Point object with Kleinian/Poincare coords (0, 0, ...)
        &#34;&#34;&#34;

        return Point(np.zeros(shape + (dimension,)), model=&#34;klein&#34;)

class DualPoint(Point):
    &#34;&#34;&#34;Model for a &#34;dual point&#34; in hyperbolic space (a point in the
    complement of the projectivization of the Minkowski light cone,
    corresponding to a geodesic hyperplane in hyperbolic space).

    &#34;&#34;&#34;

    def _assert_geometry_valid(self, proj_data):
        Point._assert_geometry_valid(self, proj_data)
        if not CHECK_LIGHT_CONE:
            return

        if not spacelike(proj_data).all():
            raise GeometryError(&#34;Dual point data must consist of vectors&#34;
                                &#34; in the complement of the Minkowski light cone&#34;)

class IdealPoint(Point):
    &#34;&#34;&#34;Model for an ideal point in hyperbolic space (lying on the boundary
    of the projectivization of the Minkowski light cone)

    &#34;&#34;&#34;
    def _assert_geometry_valid(self, proj_data):
        super()._assert_geometry_valid(proj_data)

        if not CHECK_LIGHT_CONE:
            return

        if not lightlike(proj_data).all():
            raise GeometryError(&#34;Ideal point data must consist of vectors&#34;
                                &#34;in the boundary of the Minkowski light cone&#34;)

    def from_angle(theta):
        #TODO: vectorize and make this work in n dimensions
        return IdealPoint(np.array([1.0, np.cos(theta), np.sin(theta)]))

class Subspace(IdealPoint):
    &#34;&#34;&#34;Model for a geodesic subspace of hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, proj_data):
        &#34;&#34;&#34;
        Parameters
        ----------
        proj_data : HyperbolicObject or ndarray
            Data used to construct a subspace (or array of
            subspaces). If `proj_data` is a `HyperbolicObject`, then
            use underlying coordinate data to build an array of
            subspaces. If `proj_data` is an `ndarray`, then interpret
            this as coordinate data for an array of subspaces in the
            projective model.

        &#34;&#34;&#34;
        HyperbolicObject.__init__(self, proj_data, unit_ndims=2)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.ideal_basis = proj_data

    def ideal_basis_coords(self, model=Model.KLEIN):
        &#34;&#34;&#34;Get coordinates for a basis of this subspace lying in the ideal
           boundary of hyperbolic space

        Parameters
        ----------
        model : Model
            Model of hyperbolic space in which to compute coordinates

        Returns
        -------
        ndarray
            Coordinates for k vectors in the ideal boundary of
            hyperbolic space, giving a basis for this subspace.

        &#34;&#34;&#34;
        #we don&#39;t return proj_data directly, since we want subclasses
        #to be able to use this method even if the structure of the
        #underlying data is different.
        return Point(self.ideal_basis).coords(model)

    def spacelike_complement(self):
        &#34;&#34;&#34;Get a spacelike point in the orthogonal complement to this subspace

        Returns
        -------
        DualPoint
            A spacelike (i.e. Minkowski-positive) point which is
            Minkowski-orthogonal to this subspace. This is not
            uniquely determined (as a point in projective space)
            unless the subspace is a hyperplane.

        &#34;&#34;&#34;

        orthed = self._data_with_dual()
        return DualPoint(orthed[..., 0, :])

    def _data_with_dual(self):
        midpoints = np.sum(self.ideal_basis, axis=-2) / self.ideal_basis.shape[-2]

        poincare_ctr, poincare_rad = self.sphere_parameters(model=Model.POINCARE)
        spacelike_guess = Point(poincare_ctr, model=Model.KLEIN).coords(
            model=Model.PROJECTIVE
        )


        to_orthogonalize = np.concatenate(
            [np.expand_dims(midpoints, axis=-2),
            self.ideal_basis[..., 1:, :],
            np.expand_dims(spacelike_guess, axis=-2)],
            axis=-2)

        orthed = utils.indefinite_orthogonalize(self.minkowski,
                                                to_orthogonalize)
        return np.concatenate([
            np.expand_dims(orthed[..., -1, :], axis=-2),
            self.ideal_basis], axis=-2)

    def sphere_parameters(self, model=Model.POINCARE):
        &#34;&#34;&#34;Get parameters describing a k-sphere corresponding to this subspace
        in the Poincare model.

        Parameters
        ----------
        model : Model
            hyperbolic model to use. Acceptable values are
            `Model.POINCARE` and `Model.HALFSPACE`

        Returns
        -------
        tuple
            Tuple of the form `(centers, radii)`, where `centers` and
            `radii` are `ndarray`s respectively holding the centers
            and radii of spheres corresponding to this subspace in the
            given hyperbolic model.

        Raises
        ------
        GeometryError

        &#34;&#34;&#34;

        if model == Model.POINCARE:
            klein_basis = self.ideal_basis_coords(model=Model.KLEIN)
            klein_midpoint = klein_basis.sum(axis=-2) / klein_basis.shape[-2]
            poincare_midpoint = kleinian_to_poincare(klein_midpoint)
            poincare_extreme = utils.sphere_inversion(poincare_midpoint)

            center = (poincare_midpoint + poincare_extreme) / 2
            radius = np.sqrt(utils.normsq(poincare_midpoint - poincare_extreme)) / 2

        elif model == Model.HALFSPACE:
            halfspace_basis = self.ideal_basis_coords(model=Model.HALFSPACE)
            halfspace_midpoint = (halfspace_basis.sum(axis=-2) /
                                  halfspace_basis.shape[-2])

            #just use the first element of the basis
            center = halfspace_midpoint
            radius = np.sqrt(
                utils.normsq(halfspace_basis[..., 0, :] - halfspace_midpoint)
            )
        else:
            raise GeometryError(
                (&#34;Cannot compute spherical parameters for an object of type {}&#34;
                 &#34; in model: &#39;{}&#39;&#34;).format(self.__class__.__name__, model)
            )

        return center, radius

    def reflection_across(self):
        &#34;&#34;&#34;Get a hyperbolic isometry reflecting across this hyperplane.

        Returns
        -------
        Isometry
            Isometry reflecting across this hyperplane.

        &#34;&#34;&#34;
        dual_data = self._data_with_dual()
        if self.dimension + 1 != dual_data.shape[-2]:
            raise GeometryError(
                (&#34;Cannot compute a reflection across a subspace of &#34;
                 &#34;dimension {}&#34;).format(dual_data.shape[-2])
            )

        refdata = (np.linalg.inv(dual_data) @
                   self.minkowski @
                   dual_data)

        return Isometry(refdata, column_vectors=False)

class PointPair(Point, projective.PointPair):
    &#34;&#34;&#34;Abstract model for a hyperbolic object whose underlying data is
    determined by a pair of points in R^(n,1)

    &#34;&#34;&#34;
    def __init__(self, endpoint1, endpoint2=None):
        &#34;&#34;&#34;If `endpoint2` is `None`, interpret `endpoint1` as either a (2
        x...x n) `ndarray` (where n is the dimension of the underlying
        vector space), or else a composite `Point` object which can be
        unpacked into two Points (which may themselves be composite).

        If `endpoint2` is given, then both `endpoint1` and `endpoint2`
        can be used to construct `Point` objects, which serve as the
        endpoints for this pair of points.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

        &#34;&#34;&#34;

        projective.PointPair.__init__(self, endpoint1, endpoint2)

    def endpoint_coords(self, model=Model.KLEIN):
        &#34;&#34;&#34;Get coordinates for the endpoints of this point pair

        Parameters
        ----------
        model : Model
            model to compute coordinates in

        Returns
        -------
        ndarray
            Coordinates for the endpoints of this PointPair, as an
            ndarray with shape `(2, ... n)` (where `n` is the
            dimension of the hyperbolic space).

        &#34;&#34;&#34;
        return self.get_endpoints().coords(model)

    def get_endpoints(self):
        &#34;&#34;&#34;Convert this pair of points to a composite `Point` object

        Returns
        -------
        Point
            Composite `Point` object with the same underlying data as
            this point pair.

        &#34;&#34;&#34;
        return Point(self.endpoints)

    def get_end_pair(self, as_points=False):
        &#34;&#34;&#34;Get a pair of `Point` objects, one for each endpoint of this PointPair

        Parameters
        ----------
        as_points : bool
            If `True`, return a pair of `Point` objects. Otherwise,
            return a pair of `ndarray`s with projective coordinates
            for these points.

        Returns
        -------
        tuple
            A tuple `(p1, p2)`, where `p1` and `p2` are either both
            `Point`s or both `ndarrays`, representing the endpoints of
            this pair.

    &#34;&#34;&#34;
        if as_points:
            p1, p2 = self.get_end_pair(as_points=False)
            return (Point(p1), Point(p2))

        return (self.endpoints[..., 0, :], self.endpoints[..., 1, :])

class Geodesic(PointPair, Subspace):
    &#34;&#34;&#34;Model for a bi-infinite gedoesic in hyperbolic space.

    &#34;&#34;&#34;
    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.endpoints = self.proj_data[..., :2, :]
        self.ideal_basis = self.proj_data[..., :2, :]

    def circle_parameters(self, degrees=True, model=Model.POINCARE):
        &#34;&#34;&#34;Get parameters describing a circular arc corresponding to this
        geodesic in the Poincare or halfspace models.

        Parameters
        ----------
        degrees : bool
            if `True`, return angles in degrees. Otherwise, return
            angles in radians
        model : Model
            hyperbolic model to use for the computation

        Returns
        -------
        tuple
            tuple `(centers, radii, thetas)`, where `centers`,
            `radii`, and `thetas` are `ndarray`s representing the
            centers, radii, and begin/end angles for the circle
            corresponding to this arc in the given model of hyperbolic
            space. Angles are always specified in counterclockwise
            order.

        &#34;&#34;&#34;
        center, radius = self.sphere_parameters(model)
        endpoints = self.ideal_basis_coords(model)
        thetas = utils.circle_angles(center, endpoints)

        if model == Model.POINCARE:
            thetas = utils.short_arc(thetas)

        if model == Model.HALFSPACE:
            thetas = utils.right_to_left(thetas)

        if degrees:
            thetas *= 180 / np.pi

        return center, radius, thetas

    @classmethod
    def from_reflection(cls, reflection):
        &#34;&#34;&#34;Construct a geodesic which is the fixpoint set of a reflection.

        Parameters
        ----------
        reflection : Isometry or ndarray
            The reflection to compute the fixed geodesic for

        Raises
        ------
        GeometryError :
            If the given isometry is not a reflection, or if the
            dimension of the underlying hyperbolic space is not 2.

        Returns
        -------
        Geodesic
            A `Geodesic` fixed by the given isometry.

    &#34;&#34;&#34;
        if reflection.dimension != 2:
            raise GeometryError(&#34;Creating segment from reflection expects dimension 2, got dimension {}&#34;.format(reflection.dimension))

        hyperplane = Hyperplane.from_reflection(reflection)
        pt1 = hyperplane.ideal_basis[..., 0, :]
        pt2 = hyperplane.ideal_basis[..., 1, :]
        return Geodesic(pt1, pt2)

class Segment(Geodesic):
    &#34;&#34;&#34;Model a geodesic segment in hyperbolic space.&#34;&#34;&#34;

    def __init__(self, endpoint1, endpoint2=None):
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if endpoint2 is None:
            try:
                self._construct_from_object(endpoint1)
                return
            except (AttributeError, TypeError, GeometryError):
                pass

            try:
                self.set(endpoint1)
                return
            except (AttributeError, GeometryError) as e:
                pass

        self.set_endpoints(endpoint1, endpoint2)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.endpoints = self.proj_data[..., :2, :]
        self.ideal_basis = self.proj_data[..., 2:, :]

    def set_endpoints(self, endpoint1, endpoint2=None):
        # reimplemented to also compute ideal endpoints
        if endpoint2 is None:
            self.endpoints = Point(endpoint1).proj_data
            self._compute_ideal_endpoints(endpoint1)
            return

        pt1 = Point(endpoint1)
        pt2 = Point(endpoint2)
        self.endpoints = Point(np.stack(
            [pt1.proj_data, pt2.proj_data], axis=-2)
        )

        self._compute_ideal_endpoints(self.endpoints)

    def _assert_geometry_valid(self, proj_data):
        HyperbolicObject._assert_geometry_valid(self, proj_data)

        if (proj_data.shape[-2] != 4):
            raise GeometryError( (&#34;Underlying data for a hyperbolic&#34;
            &#34; segment must have shape (..., 4, n) but data&#34;
            &#34; has shape {}&#34;).format(proj_data.shape))

        if not CHECK_LIGHT_CONE:
            return

        if not timelike(proj_data[..., 0, :, :]).all():
            raise GeometryError( &#34;segment data at index [..., 0, :,&#34;
            &#34;:] must consist of timelike vectors&#34; )

        if not lightlike(proj_data[..., 1, :, :]).all():
            raise GeometryError( &#34;segment data at index [..., 1, :,&#34;
            &#34;:] must consist of lightlike vectors&#34; )

    def _compute_ideal_endpoints(self, endpoints):
        end_data = Point(endpoints).proj_data
        dim = end_data.shape[-1]
        products = end_data @ minkowski(dim) @ end_data.swapaxes(-1, -2)
        a11 = products[..., 0, 0]
        a22 = products[..., 1, 1]
        a12 = products[..., 0, 1]

        a = a11 - 2 * a12 + a22
        b = 2 * a12 - 2 * a22
        c = a22

        mu1 = (-b + np.sqrt(b * b - 4 * a * c)) / (2*a)
        mu2 = (-b - np.sqrt(b * b - 4 * a * c)) / (2*a)

        null1 = (mu1[..., np.newaxis] * end_data[..., 0, :] +
                 (1 - mu1)[..., np.newaxis] * end_data[..., 1, :])

        null2 = (mu2[..., np.newaxis] * end_data[..., 0, :] +
                 (1 - mu2)[..., np.newaxis] * end_data[..., 1, :])

        ideal_basis = np.stack([null1, null2], axis=-2)
        proj_data = np.concatenate([end_data, ideal_basis], axis=-2)

        self.set(proj_data)

    def geodesic(self):
        &#34;&#34;&#34;Get the bi-infinite geodesic spanned by this segment

        Returns
        -------
        Geodesic
            Geodesic in hyperbolic space spanned by this segment.
        &#34;&#34;&#34;
        return Geodesic(self.ideal_basis)

    def ideal_endpoint_coords(self, model=Model.KLEIN):
        &#34;&#34;&#34;Alias for Subspace.ideal_basis_coords.

        &#34;&#34;&#34;
        return self.ideal_basis_coords(model)

    def circle_parameters(self, degrees=True, model=Model.POINCARE):
        &#34;&#34;&#34;Get parameters describing a circular arc corresponding to this
        segment in the Poincare or halfspace models.

        Parameters
        ----------
        degrees : bool
            if `True`, return angles in degrees. Otherwise, return
            angles in radians
        model : Model
            hyperbolic model to use for the computation

        Returns
        -------
        tuple
            tuple `(centers, radii, thetas)`, where `centers`,
            `radii`, and `thetas` are `ndarray`s representing the
            centers, radii, and begin/end angles for the circle
            corresponding to this arc in the given model of hyperbolic
            space. Angles are always specified in counterclockwise
            order.

        &#34;&#34;&#34;
        center, radius = self.sphere_parameters(model)

        endpoints = self.endpoint_coords(model)

        thetas = utils.circle_angles(center, endpoints)

        if model == Model.POINCARE:
            thetas = utils.short_arc(thetas)
        elif model == Model.HALFSPACE:
            thetas = utils.right_to_left(thetas)

        if degrees:
            thetas *= 180 / np.pi

        return center, radius, thetas


class Hyperplane(Subspace):
    &#34;&#34;&#34;Model for a geodesic hyperplane in hyperbolic space.&#34;&#34;&#34;

    #TODO: reimplement so ideal_basis is aux_data
    def __init__(self, hyperplane_data):
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(hyperplane_data)
            return
        except (TypeError, GeometryError):
            pass

        try:
            self.set(hyperplane_data)
            return
        except GeometryError:
            pass

        self._compute_ideal_basis(hyperplane_data)

    def _assert_geometry_valid(self, proj_data):
        HyperbolicObject._assert_geometry_valid(self, proj_data)

        if (len(proj_data.shape) &lt; 2 or
            proj_data.shape[-2] != proj_data.shape[-1]):
            raise GeometryError( (&#34;Underlying data for hyperplane in H^n must&#34;
                                  &#34; have shape (..., n, n) but data has shape&#34;
                                  &#34; {}&#34;).format(proj_data.shape))


        if not CHECK_LIGHT_CONE:
            return

        if not spacelike(proj_data[..., 0, :]).all():
            raise GeometryError( (&#34;Hyperplane data at index [..., 0, :]&#34;
                                  &#34; must consist of spacelike vectors&#34;) )

        if not lightlike(proj_data[..., 1:, :]).all():
            raise GeometryError( (&#34;Hyperplane data at index [..., 1, :]&#34;
                                  &#34; must consist of lightlike vectors&#34;) )

    def _data_with_dual(self):
        return self.proj_data

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)

        self.spacelike_vector = self.proj_data[..., 0, :]
        self.ideal_basis = self.proj_data[..., 1:, :]

    def _compute_ideal_basis(self, vector):
        spacelike_vector = DualPoint(vector).proj_data
        n = spacelike_vector.shape[-1]
        transform = spacelike_to(spacelike_vector)

        if len(spacelike_vector.shape) &lt; 2:
            spacelike_vector = np.expand_dims(spacelike_vector, axis=0)

        standard_ideal_basis = np.vstack(
            [np.ones((1, n-1)), np.eye(n - 1, n - 1, -1)]
        )
        standard_ideal_basis[n-1, n-2] = -1.


        ideal_basis = transform.apply(standard_ideal_basis.T,
                                      broadcast=&#34;pairwise&#34;).proj_data
        proj_data = np.concatenate([spacelike_vector, ideal_basis],
                                  axis=-2)
        self.set(proj_data)

    @classmethod
    def from_reflection(cls, reflection):
        &#34;&#34;&#34;Construct a hyperplane which is the fixpoint set of a reflection.

        Parameters
        ----------
        reflection : Isometry or ndarray
            The reflection to compute the fixed plane for

        Raises
        ------
        GeometryError :
            If the given isometry is not a reflection.

        Returns
        -------
        Hyperplane
            A `Hyperplane` fixed by the given isometry.
        &#34;&#34;&#34;
        try:
            matrix = reflection.matrix.swapaxes(-1, -2)
        except AttributeError:
            matrix = reflection

        #numpy&#39;s eig expects a matrix operating on the left
        evals, evecs = np.linalg.eig(matrix)

        dimension = reflection.dimension

        #we expect a reflection to have eigenvalues [-1, 1, ...]
        expected_evals = np.ones(dimension + 1)
        expected_evals[0] = -1.
        eval_differences = np.sort(evals, axis=-1) - expected_evals
        if (np.abs(eval_differences) &gt; ERROR_THRESHOLD).any():
            raise GeometryError(&#34;Not a reflection matrix&#34;)

        #sometimes eigenvalues will be complex due to roundoff error
        #so we cast to reals to avoid warnings.
        reflected = np.argmin(np.real(evals), axis=-1)

        spacelike = np.take_along_axis(
            np.real(evecs), np.expand_dims(reflected, axis=(-1,-2)), axis=-1
        )

        return Hyperplane(spacelike.swapaxes(-1,-2))

class TangentVector(HyperbolicObject):
    &#34;&#34;&#34;Model for a tangent vector in hyperbolic space.&#34;&#34;&#34;
    def __init__(self, point_data, vector=None):
        &#34;&#34;&#34;If `vector` is `None`, interpret `point_data` as either an ndarray
        of shape `(..., 2, n)` (where `n` is the dimension of the
        underlying vector space), or else a composite HyperbolicObject
        whose data can be unpacked into a point in projective space
        and a tangent vector to a hyperboloid.

        If `vector` is given, then `point_data` is used to construct
        the basepoint for this tangent vector, and `vector` is used to
        construct the tangent vector to the hyperboloid.

        Parameters
        ----------
        point_data : Point or ndarray
            The basepoint of the tangent vector, or (if `vector` is
            `None`) the data of the basepoint and the tangent vector.
        vector : HyperbolicObject or ndarray
            The tangent vector data. If `None`, `point_data` contains
            the data for the basepoint and the tangent vector.

        &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if vector is None:
            try:
                self._construct_from_object(point_data)
                return
            except TypeError:
                pass

            self.set(point_data)
            return

        self._compute_data(point_data, vector)

    def _assert_geometry_valid(self, proj_data):
        super()._assert_geometry_valid(proj_data)

        if proj_data.shape[-2] != 2:
            raise GeometryError(
                (&#34;Underlying data for a tangent vector in Hn must have shape&#34;
                 &#34; (..., 2, n) but data has shape {}&#34;).format(
                     proj_data.shape)
            )

        if not CHECK_LIGHT_CONE:
            return

        point_data = proj_data[..., 0, :]
        vector_data = proj_data[..., 1, :]

        if not timelike(point_data).all():
            raise GeometryError(&#34;tangent vector data at index [..., 0, :] must&#34;
                                &#34; consist of timelike vectors&#34;)

        products = utils.apply_bilinear(point_data, vector_data, self.minkowski)
        if (np.abs(products) &gt; ERROR_THRESHOLD).any():
            raise GeometryError(&#34;tangent vector must be orthogonal to point&#34;)

    def _compute_data(self, point, vector):
        #wrapping these as hyperbolic objects first
        pt = Point(point)

        #this should be a dual point, but we don&#39;t expect one until
        #after we project
        vec = HyperbolicObject(vector)

        projected = project_to_hyperboloid(pt.proj_data, vec.proj_data)

        self.set(np.stack([pt.proj_data, projected], axis=-2))

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.point = self.proj_data[..., 0, :]
        self.vector = self.proj_data[..., 1, :]

    def normalized(self):
        &#34;&#34;&#34;Get a unit tangent vector in the same direction as this tangent
        vector.

        Returns
        -------
        TangentVector
            Normalized version of this tangent vector (with respect to
            the standard Minkowski inner product)

        &#34;&#34;&#34;
        normed_vec = utils.normalize(self.vector, self.minkowski)
        return TangentVector(self.point, normed_vec)

    def origin_to(self, force_oriented=True):
        &#34;&#34;&#34;Get an isometry taking the &#34;origin&#34; to this vector.

        The &#34;origin&#34; is a tangent vector whose basepoint lies at (0,
        0, ....) in Poincare or Kleinian coordinates, and whose
        tangent vector is parallel to the second standard basis
        vector.

        Parameters
        ----------
        force_oriented : bool
            If `True`, force the computed isometry to be
            orientation-preserving

        Returns
        -------
        Isometry
            Isometry taking the &#34;origin&#34; to this tangent vector.

    &#34;&#34;&#34;
        normed = utils.normalize(self.proj_data, self.minkowski)
        isom = utils.find_isometry(self.minkowski, normed,
                                   force_oriented)

        return Isometry(isom, column_vectors=False)

    def isometry_to(self, other, force_oriented=True):
        &#34;&#34;&#34;Get an isometry taking this tangent vector to a scalar multiple of
        the other.

        Parameters
        ----------
        other : TangentVector
            Tangent vector to translate this vector to
        force_oriented : bool
            If `True`, force the computed isometry to be
            orientation-preserving.

        Returns
        -------
        Isometry
            Isometry this tangent vector to `other`.

        &#34;&#34;&#34;
        return other.origin_to(force_oriented) @ self.origin_to(force_oriented).inv()

    def angle(self, other):
        &#34;&#34;&#34;Compute the angle between two tangent vectors.

        Parameters
        ----------
        other : TangentVector

        Returns
        -------
        float or ndarray
            The angle between `self` and `other`.

        &#34;&#34;&#34;
        v1 = project_to_hyperboloid(self.point, self.normalized().vector)
        v2 = project_to_hyperboloid(self.point, other.normalized().vector)

        product = utils.apply_bilinear(v1, v2, self.minkowski)
        return np.arccos(product)

    def point_along(self, distance):
        &#34;&#34;&#34;Get a point in hyperbolic space along the geodesic specified by
        this tangent vector.

        Parameters
        ----------
        distance : float or ndarray

        Returns
        -------
        Point
            Point in hyperbolic space along the geodesic ray defined
            by this tangent vector

        &#34;&#34;&#34;
        kleinian_shape = list(self.point.shape)
        kleinian_shape[-1] -= 1

        kleinian_pt = np.zeros(kleinian_shape)
        kleinian_pt[..., 0] = hyp_to_affine_dist(distance)

        basepoint = Point(kleinian_pt, model=Model.KLEIN)

        return self.origin_to().apply(basepoint, &#34;elementwise&#34;)

    @classmethod
    def get_base_tangent(cls, dimension, shape=()):
        &#34;&#34;&#34;Get an &#34;origin&#34; tangent vector.

        The basepoint of this tangent vector has coordinates (0, 0,
        ...) in Poincare/Klein coordinates, and the vector is parallel
        to the second standard basis vector in R^(n,1).

        Parameters
        ----------
        dimension : int
            Dimension of the hyperbolic space where this tangent vector lives
        shape : tuple
            Shape of the composite TangentVector object to return.

        Returns
        -------
        TangentVector
            An &#34;origin&#34; tangent vector.

        &#34;&#34;&#34;
        origin = Point.get_origin(dimension, shape)
        vector = np.zeros(() + (dimension + 1,))
        vector[..., 1] = 1.

        return TangentVector(origin, vector)

class Horosphere(HyperbolicObject):
    &#34;&#34;&#34;Model for a horosphere in hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, center, reference_point=None):
        &#34;&#34;&#34;If `reference_point` is `None`, interpret `center` as either:

        - a (..., 2, n) `ndarray`, where first row of the last two
        ndindices gives the (ideal) center point for this horosphere,
        and the second row gives some reference point on the
        horosphere itself, or

        - a `HyperbolicObject` whose underlying data has the form above.

        If `reference_point` is given, then `center` can be used to
        construct an `IdealPoint` giving the center of the horosphere,
        and `reference_point` can be used to construct a `Point`
        giving some point on the horosphere.

        Parameters
        ----------
        center : Point or ndarray
            The (ideal) center point for this horosphere, or an object
            which can be unpacked into all of the data for the
            horosphere
        reference_point : Point or ndarray
            Any point lying on the horosphere itself. If `None`, then
            `center` contains the data for the reference point as
            well.

        &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if reference_point is None:
            try:
                self._construct_from_object(center)
                return
            except TypeError:
                pass

        self.set_center_ref(center, reference_point)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.center = proj_data[..., 0, :]
        self.reference = proj_data[..., 1, :]

    def set_center_ref(self, center, reference_point=None):
        if reference_point is None:
            proj_data = Point(center).proj_data
        else:
            center = IdealPoint(center)
            ref = Point(reference_point)
            proj_data = np.stack([center.proj_data, ref.proj_data], axis=-2)

        self.set(proj_data)

    def sphere_parameters(self, model=Model.POINCARE):
        &#34;&#34;&#34;Get the center and radius of a sphere giving this horosphere in
        poincare coordinates.

        &#34;&#34;&#34;
        ideal_coords = Point(self.center).coords(model)
        ref_coords = Point(self.reference).coords(model)

        if model == Model.POINCARE:
            model_radius = (utils.normsq(ideal_coords - ref_coords) /
                            (2 * (1 - utils.apply_bilinear(ideal_coords,
                                                           ref_coords))))
            model_center = ideal_coords * (1 - model_radius[..., np.newaxis])
        elif model == Model.HALFSPACE:
            with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
                ideal_euc = ideal_coords[..., :-1]
                ref_euc = ref_coords[..., :-1]
                ref_z = ref_coords[..., -1]

                model_radius = 0.5 * (utils.normsq(ideal_euc - ref_euc) / ref_z + ref_z)
                model_center = ideal_coords[:]
                model_center[..., -1] = model_radius
        else:
            raise GeometryError(
                &#34;No implementation for spherical parameters for a horosphere in&#34;
                &#34; model: &#39;{}&#39;&#34;.format(model)
            )

        return model_center, model_radius

    def center_coords(self, model=Model.KLEIN):
        return Point(self.center).coords(model)

    def ref_coords(self, model):
        return Point(self.reference).coords(model)

    def intersect_geodesic(self, geodesic, p2=None):
        &#34;&#34;&#34;Compute the intersection points of a geodesic with this horosphere

        &#34;&#34;&#34;
        segment = Segment(geodesic, p2)
        geodesic_endpts = segment.ideal_endpoint_coords(Model.KLEIN)

        # compute an isometry taking this geodesic to one which passes
        # through the origin (so we can do intersection calculations
        # in Euclidean geometry)
        midpt = Point((geodesic_endpts[..., 0, :] + geodesic_endpts[..., 1, :]) / 2.,
                       model=Model.KLEIN)
        coord_change = midpt.origin_to()
        coord_inv = coord_change.inv()

        c_hsph = coord_inv @ self
        c_seg = coord_inv @ segment

        p_center, p_radius = c_hsph.sphere_parameters()
        geodesic_endpts = c_seg.ideal_endpoint_coords(Model.KLEIN)

        u = geodesic_endpts[..., 0, :]
        v = geodesic_endpts[..., 1, :]

        a = utils.normsq(u - v)
        b = 2 * ((utils.apply_bilinear(p_center, v - u) +
                  utils.apply_bilinear(u, v) -
                  utils.normsq(u)))
        c = utils.normsq(v - p_center) - p_radius**2

        #TODO: check to see if the intersection actually occurs
        t1 = (-1 * b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)
        t2 = (-1 * b - np.sqrt(b**2 - 4 * a * c)) / (2 * a)

        p1_poincare = t1 * u + (1 - t1) * v
        p2_poincare = t2 * u + (1 - t2) * v

        poincare_pts = np.stack([p1_poincare, p2_poincare], axis=-2)
        klein_pts = poincare_to_kleinian(poincare_pts)

        return coord_change @ Point(klein_pts, model=Model.KLEIN)

class HorosphereArc(Horosphere, PointPair):
    &#34;&#34;&#34;Model for an arc lying along a horosphere

    &#34;&#34;&#34;
    def __init__(self, center, p1=None, p2=None):
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if p1 is None and p2 is None:
            try:
                self._construct_from_object(center)
                return
            except TypeError:
                pass
            try:
                self.set(center)
                return
            except (AttributeError, GeometryError):
                pass

        self.set_center_endpoints(center, p1, p2)

    def set_center_endpoints(self, center, p1=None, p2=None):
        if ((p1 is None and p2 is not None) or
            (p1 is not None and p2 is None)):
            raise GeometryError(
                &#34;Horospherical arc determined by two endpoints and a centerpoint, but&#34;
                &#34; this was not provided&#34;
            )

        if p2 is None:
            proj_data = Point(center).proj_data
        else:
            center_data = Point(center).proj_data
            p1_data = Point(p1).proj_data
            p2_data = Point(p2).proj_data
            proj_data = np.stack([center_data, p1_data, p2_data], axis=-2)

        self.set(proj_data)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.center = self.proj_data[..., 0, :]
        self.reference = self.proj_data[..., 1, :]
        self.endpoints = self.proj_data[..., 1:, :]

    def circle_parameters(self, model=Model.POINCARE, degrees=True):
        &#34;&#34;&#34;Get parameters for a circle describing this horospherical arc.

        &#34;&#34;&#34;
        center, radius = Horosphere.sphere_parameters(self, model=model)
        model_coords = self.endpoint_coords(model)

        thetas = utils.circle_angles(center, model_coords)

        center_theta = utils.circle_angles(
            center, self.center_coords(model=model)
        )[..., 0]

        thetas = np.flip(utils.arc_include(thetas, center_theta), axis=-1)

        if degrees:
            thetas *= 180 / np.pi

        return center, radius, thetas

class BoundaryArc(Geodesic):
    &#34;&#34;&#34;Model for an arc sitting in the boundary of hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, endpoint1, endpoint2=None):
        PointPair.__init__(self, endpoint1, endpoint2)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.endpoints = proj_data[..., :2, :]
        self.orientation_pt = proj_data[..., 2, :]

    def set_endpoints(self, endpoint1, endpoint2):
        if endpoint2 is None:
            endpoint_data = Point(endpoint1).proj_data
        else:
            pt1 = Point(endpoint1)
            pt2 = Point(endpoint2)
            endpoint_data = np.stack(
                [pt1.proj_data, pt2.proj_data], axis=-2
            )

        self._build_orientation_point(endpoint_data)

    def orientation(self):
        return np.linalg.det(self.proj_data)

    def flip_orientation(self):
        self.proj_data[..., 2, :] *= -1
        self.set(self.proj_data)

    def endpoint_coords(self, model, ordered=True):
        endpoints = Geodesic.endpoint_coords(self, model)
        endpoints[self.orientation() &lt; 0] = np.flip(
            endpoints[self.orientation() &lt; 0],
            axis=-2
        )
        return endpoints

    def _build_orientation_point(self, endpoints):
        n = endpoints.shape[-1]
        orientation_pt_1 = np.zeros(endpoints.shape[:-2] +
                                    (1, n))
        orientation_pt_2 = np.zeros(endpoints.shape[:-2] +
                                    (1, n))
        orientation_pt_1[..., 0, 0] = 1.0
        orientation_pt_2[..., 0, 1] = 1.0

        point_data = np.concatenate((endpoints, orientation_pt_1), axis=-2)

        dets = np.linalg.det(point_data)
        point_data[np.abs(dets) &lt; ERROR_THRESHOLD, 2] = orientation_pt_2

        signs = np.linalg.det(point_data)
        point_data[signs &lt; 0, 2] *= -1

        self.set(point_data)


    def circle_parameters(self, model=Model.POINCARE, degrees=True):
        &#34;&#34;&#34;Compute parameters (center, radius) for this boundary arc.

        &#34;&#34;&#34;
        if model != Model.POINCARE and model != Model.KLEIN:
            raise GeometryError(
                (&#34;Cannot compute circular parameters for a boundary arc in model: &#39;{}&#39;&#34;
                 ).format(model)
            )
        center = np.zeros(self.proj_data.shape[:-2] + (2,))
        radius = np.ones(self.proj_data.shape[:-2])

        coords = self.endpoint_coords(model, ordered=True)
        thetas = utils.circle_angles(center, coords)

        if degrees:
            thetas *= 180 / np.pi



        return center, radius, thetas

class Polygon(Point, projective.Polygon):
    &#34;&#34;&#34;Model for a geodesic polygon in hyperbolic space.

    Underlying data consists of the vertices of the polygon. We also
    keep track of auxiliary data, namely the proj_data of the segments
    making up the edges of the polygon.
    &#34;&#34;&#34;
    def __init__(self, vertices, aux_data=None):
        self.segment_class = Segment
        HyperbolicObject.__init__(self, vertices, aux_data,
                                  unit_ndims=2, aux_ndims=3)

    def _compute_aux_data(self, proj_data):
        segments = Segment(proj_data, np.roll(proj_data, -1, axis=-2))
        return segments.proj_data

    def get_vertices(self):
        return Point(self.proj_data)

    def get_edges(self):
        return Segment(self.edges)

    def circle_parameters(self, short_arc=True, degrees=True,
                          model=Model.POINCARE, flatten=False):
        if not flatten:
            return self.get_edges().circle_parameters(short_arc, degrees, model)

        flat_segments = self.get_edges().flatten_to_unit()
        return flat_segments.circle_parameters(short_arc, degrees, model)

    def regular_polygon(n, radius=None, angle=None, dimension=2):
        &#34;&#34;&#34;Get a regular polygon with n vertices, inscribed on a circle of
        radius hyp_radius.

        (This is actually vectorized.)

        &#34;&#34;&#34;
        if radius is None and angle is None:
            raise ValueError(
                &#34;Must provide either an angle or a radius to regular_polygon&#34;
            )

        if radius is None:
            radius = regular_polygon_radius(n, angle)

        hyp_radius = np.array(radius)
        tangent = TangentVector.get_base_tangent(dimension,
                                                 hyp_radius.shape).normalized()
        start_vertex = tangent.point_along(hyp_radius)

        cyclic_rep = HyperbolicRepresentation()
        cyclic_rep[&#34;a&#34;] = Isometry.standard_rotation(2 * np.pi / n, dimension=dimension)

        words = [&#34;a&#34; * i for i in range(n)]
        mats = cyclic_rep.isometries(words)

        vertices = mats.apply(start_vertex, &#34;pairwise_reversed&#34;)
        return Polygon(vertices)

    def regular_surface_polygon(g, dimension=2):
        &#34;&#34;&#34;Get a regular polygon which is the fundamental domain for the
        action of a hyperbolic surface group with genus g.

        &#34;&#34;&#34;
        return Polygon.regular_polygon(4 * g, radius=genus_g_surface_radius(g),
                                       dimension=dimension)

class Isometry(projective.Transformation, HyperbolicObject):
    &#34;&#34;&#34;Model for an isometry of hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, proj_data, column_vectors=False):
        projective.Transformation.__init__(self, proj_data, column_vectors)

    def _fixpoint_data(self, sort_eigvals=True):

        # find fixpoints in projective space, and their eigenvalues and minkowski norms

        eigvals, eigvecs = np.linalg.eig(self.proj_data.swapaxes(-1, -2))
        norms = utils.normsq(eigvecs.swapaxes(-1, -2),  self.minkowski)

        # 1 for eigenvectors which actually lie in H^n, 0 for outside vectors
        in_plane = np.where(norms &gt; ERROR_THRESHOLD, 0, 1)

        # primary sort key is whether or not we&#39;re in the plane,
        # secondary is the eigenvalue modulus
        if sort_eigvals:
            sort_order = np.stack([np.abs(eigvals),
                                   -1 * np.abs(np.imag(eigvals)),
                                   in_plane])
            sort_indices = np.lexsort(sort_order, axis=-1)
            sort_indices = np.expand_dims(sort_indices, axis=-2)
        else:
            sort_indices = np.argsort(in_plane, axis=-1)

        # we want a descending sort to put maximum modulus eigenvalues first
        sort_indices = np.flip(sort_indices, axis=-1)

        pt_data = np.take_along_axis(eigvecs, sort_indices, axis=-1).swapaxes(-1, -2)

        return pt_data

    def _data_to_object(self, data):
        return HyperbolicObject(data)

    def axis(self):
        return Geodesic(self.fixed_point_pair())

    def isometry_type(self):
        fixpoint_data = self._fixpoint_data(sort_eigvals=True)
        fixpoint

    def fixed_point_pair(self, sort_eigvals=True):
        &#34;&#34;&#34;Find fixed points for this isometry in the closure of hyperbolic space.

        Parameters
        ----------
        sort_eigvals : bool
            If `True`, guarantee that the fixpoints are ordered in
            order of descending eigenvalue moduli

        Returns
        -------
        Point
            Points fixed by this isometry object.

        &#34;&#34;&#34;
        fixpoint_data = np.real(self._fixpoint_data(sort_eigvals))
        return PointPair(fixpoint_data[..., :2, :])

    def fixed_point(self, max_eigval=True):
        &#34;&#34;&#34;Find a fixed point for this isometry in the closure of hyperbolic
           space.

        Parameters
        ----------
        max_eigval : bool
            If `True`, guarantee that the eigenvalue for this fixed
            point has maximum modulus

        Returns
        -------
        Point
            A point (possibly ideal) fixed by this isometry object.

        &#34;&#34;&#34;
        fixpoint_data = np.real(self._fixpoint_data(max_eigval))
        return Point(fixpoint_data[..., 0, :])


    def elliptic(dimension, block_elliptic, column_vectors=True):
        &#34;&#34;&#34;Get an elliptic isometry stabilizing the origin in the
        Poincare/Klein models.

        block_elliptic is an element of O(n), whose image is taken
        diagonally in O(n,1).

        &#34;&#34;&#34;
        mat = np.zeros((dimension + 1, dimension + 1))
        mat[0,0] = 1.0
        mat[1:, 1:] = block_elliptic

        return Isometry(mat, column_vectors=column_vectors)

    def standard_loxodromic(dimension, parameter):
        &#34;&#34;&#34;Get a loxodromic isometry whose axis intersects the origin.

        WARNING: not vectorized.

        &#34;&#34;&#34;
        basis_change = _loxodromic_basis_change(dimension)
        diagonal_loxodromic = np.diag(
            np.concatenate(([parameter, 1.0/parameter],
                       np.ones(dimension - 1)))
        )

        return Isometry((basis_change @ diagonal_loxodromic @
                        np.linalg.inv(basis_change)),
                        column_vectors=True)

    def standard_rotation(angle, dimension=2):
        &#34;&#34;&#34;Get a rotation about the origin by a fixed angle.

        WARNING: not vectorized.
        &#34;&#34;&#34;
        affine = np.identity(dimension)
        affine[0:2, 0:2] = utils.rotation_matrix(angle)

        return Isometry.elliptic(dimension, affine)

class HyperbolicRepresentation(projective.ProjectiveRepresentation):
    &#34;&#34;&#34;Model a representation for a finitely generated group
    representation into O(n,1).

    Really this is just a convenient way of mapping words in the
    generators to hyperbolic isometries - there&#39;s no group theory
    being done here at all.

    &#34;&#34;&#34;
    def __getitem__(self, word):
        matrix = self._word_value(word)
        return Isometry(matrix, column_vectors=True)

    def normalize(self, matrix):
        dimension = np.array(matrix).shape[-1]
        return utils.indefinite_orthogonalize(minkowski(dimension), matrix)

    def isometries(self, words):
        &#34;&#34;&#34;Get an Isometry object holding the matrices which are the images of
        a sequence of words in the generators.

        &#34;&#34;&#34;
        return Isometry(self.transformations(words))

    def automaton_accepted(self, automaton, length,
                           maxlen=True, with_words=False,
                           start_state=None, end_state=None,
                           precomputed=None):
        result = projective.ProjectiveRepresentation.automaton_accepted(
            self, automaton, length, maxlen=maxlen, with_words=with_words,
            start_state=start_state, end_state=end_state,
            precomputed=precomputed
        )

        if with_words:
            transformations, words = result
            return (Isometry(transformations), words)

        return Isometry(result)

def minkowski(dimension):
    return np.diag(np.concatenate(([-1.0], np.ones(dimension - 1))))

def kleinian_coords(points, column_vectors=False):
    &#34;&#34;&#34;Get kleinian coordinates for an ndarray of points.

    &#34;&#34;&#34;
    return projective.affine_coords(points, chart_index=0,
                                    column_vectors=column_vectors)

def get_point(coords, model=&#34;klein&#34;):
    return Point(coords, model)

def get_boundary_point(angle):
    return IdealPoint.from_angle(angle)

def hyperboloid_coords(points, column_vectors=False):
    &#34;&#34;&#34;Project an ndarray of points to the unit hyperboloid defined by the
    Minkowski quadratic form.&#34;&#34;&#34;

    proj_coords = points
    if column_vectors:
        proj_coords = coords.swapaxes(-1, -2)

    dim = proj_coords.shape[-1]
    hyperbolized = utils.normalize(proj_coords, minkowski(dim))

    if column_vectors:
        hyperbolized = hyperbolized.swapaxes(-1, -2)

    return hyperbolized

def spacelike(vectors):
    &#34;&#34;&#34;Determine if a vector in R^(n,1) is spacelike.

    Parameters
    ----------
    vectors : ndarray
        Vectors to test for spacelike norms. The last index of the
        array is the dimension of the vector space.

    Returns
    -------
    ndarray(bool)
        `True` for vectors which have Minkowski norm above a fixed
        error threshold.

    &#34;&#34;&#34;
    dim = np.array(vectors).shape[-1]
    return (utils.normsq(vectors, minkowski(dim)) &gt; ERROR_THRESHOLD).all()

def timelike(self, vectors):
    &#34;&#34;&#34;Determine if a vector in R^(n,1) is timelike.

    Parameters
    ----------
    vectors : ndarray
        Vectors to test for timelike norms. The last index of the
        array is the dimension of the vector space.

    Returns
    -------
    ndarray(bool)
        `True` for vectors which have Minkowski norm below a fixed
        error threshold.

    &#34;&#34;&#34;
    dim = np.array(vectors).shape[-1]
    return (utils.normsq(vectors, minkowski(dim)) &lt; ERROR_THRESHOLD)

def lightlike(self, vectors):
    &#34;&#34;&#34;Determine if a vector in R^(n,1) is lightlike.

    Parameters
    ----------
    vectors : ndarray
        Vectors to test for lightlike norms. The last index of the
        array is the dimension of the vector space.

    Returns
    -------
    ndarray(bool)
        `True` for vectors where the absolute value of the Minkowski
        norm is below a fixed error threshold.

    &#34;&#34;&#34;

    dim = np.array(vectors).shape[-1]
    return (np.abs(utils.normsq(vectors, minkowski(dim))) &lt; ERROR_THRESHOLD)


def kleinian_to_poincare(points):
    euc_norms = utils.normsq(points)
    #we take absolute value to combat roundoff error
    mult_factor = 1 / (1. + np.sqrt(np.abs(1 - euc_norms)))

    return (points.T * mult_factor.T).T

def poincare_to_kleinian(points):
    euc_norms = utils.normsq(points)
    mult_factor = 2. / (1. + euc_norms)

    return (points.T * mult_factor.T).T

def poincare_to_halfspace(points):
    y = points[..., 0]
    v = points[..., 1:]
    x2 = utils.normsq(v)

    halfspace_coords = np.zeros_like(points)
    denom = (x2 + (y - 1)*(y - 1))

    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        halfspace_coords[..., :-1] = (-2. * v) / denom[..., np.newaxis]
        halfspace_coords[..., -1] = (1 - x2 - y * y) / denom

    return halfspace_coords

def halfspace_to_poincare(points):
    y = points[..., -1]
    v = points[..., :-1]
    x2 = utils.normsq(v)

    poincare_coords = np.zeros_like(points)
    denom = (x2 + (y + 1)*(y + 1))
    poincare_coords[..., 1:] = (-2. * v) / denom[..., np.newaxis]
    poincare_coords[..., 0] = (x2 + y * y - 1) / denom

    return poincare_coords

def timelike_to(self, v, force_oriented=False):
    &#34;&#34;&#34;Find an isometry taking the origin of the Poincare/Klein models to
    the given vector v.

    We expect v to be timelike in order for this to make sense.

    &#34;&#34;&#34;
    if not timelike(v).all():
        raise GeometryError( &#34;Cannot find isometry taking a&#34;
        &#34; timelike vector to a non-timelike vector.&#34;  )

    dim = np.array(vectors).shape[-1]
    return Isometry(utils.find_isometry(minkowski(dim),
                                        v, force_oriented),
                    column_vectors=False)

def sl2r_iso(matrix):
    &#34;&#34;&#34;Convert 2x2 matrices to isometries.

    matrix is an array of shape (..., 2, 2), and interpreted as an
    array of elements of SL^+-(2, R).

    &#34;&#34;&#34;

    return Isometry(representation.sl2_to_so21(np.array(matrix)),
                    column_vectors=True)

def project_to_hyperboloid(basepoint, tangent_vector):
    &#34;&#34;&#34;Project a vector in R^(n,1) to lie in the tangent space to the unit
    hyperboloid at a given basepoint.

    &#34;&#34;&#34;
    dim = basepoint.shape[-1]
    return tangent_vector - utils.projection(
        tangent_vector, basepoint, minkowski(dim))

def hyp_to_affine_dist(r):
    &#34;&#34;&#34;Convert distance in hyperbolic space to distance from the origin in
    the Klein model.

    &#34;&#34;&#34;
    return (np.exp(2 * r) - 1) / (1 + np.exp(2 * r))

def _loxodromic_basis_change(dimension):
    mat = np.identity(dimension + 1)
    basis_change = np.array([
        [1.0, 1.0],
        [1.0, -1.0]
    ])
    mat[0:2, 0:2] = basis_change

    return mat

def regular_polygon_radius(n, interior_angle):
    &#34;&#34;&#34;Find r such that a regular n-gon inscribed on a circle of radius r
    has the given interior angle.

    &#34;&#34;&#34;
    alpha = interior_angle / 2
    gamma = np.pi / n
    term = ((np.cos(alpha)**2 - np.sin(gamma)**2) /
            ((np.sin(alpha) * np.sin(gamma))**2))
    return np.arcsinh(np.sqrt(term))

def polygon_interior_angle(n, hyp_radius):
    &#34;&#34;&#34;Get the interior angle of a regular n-gon inscribed on a circle
    with the given hyperbolic radius.

    &#34;&#34;&#34;
    gamma = np.pi / n
    denom = np.sqrt(1 + (np.sin(gamma) * np.sinh(hyp_radius))**2)
    return 2 * np.arcsin(np.cos(gamma) / denom)

def genus_g_surface_radius(g):
    &#34;&#34;&#34;Find the radius of a regular polygon giving the fundamental domain
    for the action of a hyperbolic surface group with genus g.

    &#34;&#34;&#34;
    return regular_polygon_radius(4 * g, np.pi / (4*g))

def spacelike_to(v, force_oriented=False):
    &#34;&#34;&#34;Find an isometry taking the second standard basis vector (0, 1, 0,
    ...) to the given vector v.

    We expect v to be spacelike in order for this to make sense.

    &#34;&#34;&#34;
    dim = np.array(v).shape[-1]

    normed = utils.normalize(v, minkowski(dim))

    if not spacelike(v).all():
        raise GeometryError( &#34;Cannot find isometry taking a&#34;
        &#34; spacelike vector to a non-spacelike vector.&#34;)

    iso = utils.find_isometry(minkowski(dim), normed)

    #find the index of the timelike basis vector
    lengths = np.expand_dims(utils.normsq(iso, minkowski(dim)), axis=-1)
    t_index = np.argmin(lengths, axis=-2)

    #apply a permutation so the isometry actually preserves the
    #form. we do the permutation in two steps because it could be
    #either a 2-cycle or a 3-cycle.
    p_iso = iso.copy()

    #first swap timelike index with zero
    indices = np.stack([np.zeros_like(t_index), t_index], axis=-2)
    p_indices = np.stack([t_index, np.zeros_like(t_index)], axis=-2)

    p_values = np.take_along_axis(iso, indices, axis=-2)
    np.put_along_axis(p_iso, p_indices, p_values, axis=-2)

    #then swap timelike index with one
    indices = np.stack([np.ones_like(t_index), t_index], axis=-2)
    p_indices = np.stack([t_index, np.ones_like(t_index)], axis=-2)

    p_values = np.take_along_axis(p_iso, indices, axis=-2)
    np.put_along_axis(p_iso, p_indices, p_values, axis=-2)

    if force_oriented:
        p_iso = utils.make_orientation_preserving(p_iso)

    return Isometry(p_iso, column_vectors=False)

def identity(dimension):
    return Isometry(np.identity(dimension + 1))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geometry_tools.hyperbolic.genus_g_surface_radius"><code class="name flex">
<span>def <span class="ident">genus_g_surface_radius</span></span>(<span>g)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the radius of a regular polygon giving the fundamental domain
for the action of a hyperbolic surface group with genus g.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genus_g_surface_radius(g):
    &#34;&#34;&#34;Find the radius of a regular polygon giving the fundamental domain
    for the action of a hyperbolic surface group with genus g.

    &#34;&#34;&#34;
    return regular_polygon_radius(4 * g, np.pi / (4*g))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.get_boundary_point"><code class="name flex">
<span>def <span class="ident">get_boundary_point</span></span>(<span>angle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_boundary_point(angle):
    return IdealPoint.from_angle(angle)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.get_point"><code class="name flex">
<span>def <span class="ident">get_point</span></span>(<span>coords, model='klein')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_point(coords, model=&#34;klein&#34;):
    return Point(coords, model)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.halfspace_to_poincare"><code class="name flex">
<span>def <span class="ident">halfspace_to_poincare</span></span>(<span>points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def halfspace_to_poincare(points):
    y = points[..., -1]
    v = points[..., :-1]
    x2 = utils.normsq(v)

    poincare_coords = np.zeros_like(points)
    denom = (x2 + (y + 1)*(y + 1))
    poincare_coords[..., 1:] = (-2. * v) / denom[..., np.newaxis]
    poincare_coords[..., 0] = (x2 + y * y - 1) / denom

    return poincare_coords</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.hyp_to_affine_dist"><code class="name flex">
<span>def <span class="ident">hyp_to_affine_dist</span></span>(<span>r)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert distance in hyperbolic space to distance from the origin in
the Klein model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyp_to_affine_dist(r):
    &#34;&#34;&#34;Convert distance in hyperbolic space to distance from the origin in
    the Klein model.

    &#34;&#34;&#34;
    return (np.exp(2 * r) - 1) / (1 + np.exp(2 * r))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.hyperboloid_coords"><code class="name flex">
<span>def <span class="ident">hyperboloid_coords</span></span>(<span>points, column_vectors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Project an ndarray of points to the unit hyperboloid defined by the
Minkowski quadratic form.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperboloid_coords(points, column_vectors=False):
    &#34;&#34;&#34;Project an ndarray of points to the unit hyperboloid defined by the
    Minkowski quadratic form.&#34;&#34;&#34;

    proj_coords = points
    if column_vectors:
        proj_coords = coords.swapaxes(-1, -2)

    dim = proj_coords.shape[-1]
    hyperbolized = utils.normalize(proj_coords, minkowski(dim))

    if column_vectors:
        hyperbolized = hyperbolized.swapaxes(-1, -2)

    return hyperbolized</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.identity"><code class="name flex">
<span>def <span class="ident">identity</span></span>(<span>dimension)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identity(dimension):
    return Isometry(np.identity(dimension + 1))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.kleinian_coords"><code class="name flex">
<span>def <span class="ident">kleinian_coords</span></span>(<span>points, column_vectors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get kleinian coordinates for an ndarray of points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kleinian_coords(points, column_vectors=False):
    &#34;&#34;&#34;Get kleinian coordinates for an ndarray of points.

    &#34;&#34;&#34;
    return projective.affine_coords(points, chart_index=0,
                                    column_vectors=column_vectors)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.kleinian_to_poincare"><code class="name flex">
<span>def <span class="ident">kleinian_to_poincare</span></span>(<span>points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kleinian_to_poincare(points):
    euc_norms = utils.normsq(points)
    #we take absolute value to combat roundoff error
    mult_factor = 1 / (1. + np.sqrt(np.abs(1 - euc_norms)))

    return (points.T * mult_factor.T).T</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.lightlike"><code class="name flex">
<span>def <span class="ident">lightlike</span></span>(<span>self, vectors)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if a vector in R^(n,1) is lightlike.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vectors</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vectors to test for lightlike norms. The last index of the
array is the dimension of the vector space.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray(bool)</code></dt>
<dd><code>True</code> for vectors where the absolute value of the Minkowski
norm is below a fixed error threshold.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lightlike(self, vectors):
    &#34;&#34;&#34;Determine if a vector in R^(n,1) is lightlike.

    Parameters
    ----------
    vectors : ndarray
        Vectors to test for lightlike norms. The last index of the
        array is the dimension of the vector space.

    Returns
    -------
    ndarray(bool)
        `True` for vectors where the absolute value of the Minkowski
        norm is below a fixed error threshold.

    &#34;&#34;&#34;

    dim = np.array(vectors).shape[-1]
    return (np.abs(utils.normsq(vectors, minkowski(dim))) &lt; ERROR_THRESHOLD)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.minkowski"><code class="name flex">
<span>def <span class="ident">minkowski</span></span>(<span>dimension)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minkowski(dimension):
    return np.diag(np.concatenate(([-1.0], np.ones(dimension - 1))))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.poincare_to_halfspace"><code class="name flex">
<span>def <span class="ident">poincare_to_halfspace</span></span>(<span>points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poincare_to_halfspace(points):
    y = points[..., 0]
    v = points[..., 1:]
    x2 = utils.normsq(v)

    halfspace_coords = np.zeros_like(points)
    denom = (x2 + (y - 1)*(y - 1))

    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        halfspace_coords[..., :-1] = (-2. * v) / denom[..., np.newaxis]
        halfspace_coords[..., -1] = (1 - x2 - y * y) / denom

    return halfspace_coords</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.poincare_to_kleinian"><code class="name flex">
<span>def <span class="ident">poincare_to_kleinian</span></span>(<span>points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poincare_to_kleinian(points):
    euc_norms = utils.normsq(points)
    mult_factor = 2. / (1. + euc_norms)

    return (points.T * mult_factor.T).T</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.polygon_interior_angle"><code class="name flex">
<span>def <span class="ident">polygon_interior_angle</span></span>(<span>n, hyp_radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the interior angle of a regular n-gon inscribed on a circle
with the given hyperbolic radius.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon_interior_angle(n, hyp_radius):
    &#34;&#34;&#34;Get the interior angle of a regular n-gon inscribed on a circle
    with the given hyperbolic radius.

    &#34;&#34;&#34;
    gamma = np.pi / n
    denom = np.sqrt(1 + (np.sin(gamma) * np.sinh(hyp_radius))**2)
    return 2 * np.arcsin(np.cos(gamma) / denom)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.project_to_hyperboloid"><code class="name flex">
<span>def <span class="ident">project_to_hyperboloid</span></span>(<span>basepoint, tangent_vector)</span>
</code></dt>
<dd>
<div class="desc"><p>Project a vector in R^(n,1) to lie in the tangent space to the unit
hyperboloid at a given basepoint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project_to_hyperboloid(basepoint, tangent_vector):
    &#34;&#34;&#34;Project a vector in R^(n,1) to lie in the tangent space to the unit
    hyperboloid at a given basepoint.

    &#34;&#34;&#34;
    dim = basepoint.shape[-1]
    return tangent_vector - utils.projection(
        tangent_vector, basepoint, minkowski(dim))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.regular_polygon_radius"><code class="name flex">
<span>def <span class="ident">regular_polygon_radius</span></span>(<span>n, interior_angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Find r such that a regular n-gon inscribed on a circle of radius r
has the given interior angle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_polygon_radius(n, interior_angle):
    &#34;&#34;&#34;Find r such that a regular n-gon inscribed on a circle of radius r
    has the given interior angle.

    &#34;&#34;&#34;
    alpha = interior_angle / 2
    gamma = np.pi / n
    term = ((np.cos(alpha)**2 - np.sin(gamma)**2) /
            ((np.sin(alpha) * np.sin(gamma))**2))
    return np.arcsinh(np.sqrt(term))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.sl2r_iso"><code class="name flex">
<span>def <span class="ident">sl2r_iso</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 2x2 matrices to isometries.</p>
<p>matrix is an array of shape (&hellip;, 2, 2), and interpreted as an
array of elements of SL^+-(2, R).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sl2r_iso(matrix):
    &#34;&#34;&#34;Convert 2x2 matrices to isometries.

    matrix is an array of shape (..., 2, 2), and interpreted as an
    array of elements of SL^+-(2, R).

    &#34;&#34;&#34;

    return Isometry(representation.sl2_to_so21(np.array(matrix)),
                    column_vectors=True)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.spacelike"><code class="name flex">
<span>def <span class="ident">spacelike</span></span>(<span>vectors)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if a vector in R^(n,1) is spacelike.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vectors</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vectors to test for spacelike norms. The last index of the
array is the dimension of the vector space.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray(bool)</code></dt>
<dd><code>True</code> for vectors which have Minkowski norm above a fixed
error threshold.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spacelike(vectors):
    &#34;&#34;&#34;Determine if a vector in R^(n,1) is spacelike.

    Parameters
    ----------
    vectors : ndarray
        Vectors to test for spacelike norms. The last index of the
        array is the dimension of the vector space.

    Returns
    -------
    ndarray(bool)
        `True` for vectors which have Minkowski norm above a fixed
        error threshold.

    &#34;&#34;&#34;
    dim = np.array(vectors).shape[-1]
    return (utils.normsq(vectors, minkowski(dim)) &gt; ERROR_THRESHOLD).all()</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.spacelike_to"><code class="name flex">
<span>def <span class="ident">spacelike_to</span></span>(<span>v, force_oriented=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Find an isometry taking the second standard basis vector (0, 1, 0,
&hellip;) to the given vector v.</p>
<p>We expect v to be spacelike in order for this to make sense.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spacelike_to(v, force_oriented=False):
    &#34;&#34;&#34;Find an isometry taking the second standard basis vector (0, 1, 0,
    ...) to the given vector v.

    We expect v to be spacelike in order for this to make sense.

    &#34;&#34;&#34;
    dim = np.array(v).shape[-1]

    normed = utils.normalize(v, minkowski(dim))

    if not spacelike(v).all():
        raise GeometryError( &#34;Cannot find isometry taking a&#34;
        &#34; spacelike vector to a non-spacelike vector.&#34;)

    iso = utils.find_isometry(minkowski(dim), normed)

    #find the index of the timelike basis vector
    lengths = np.expand_dims(utils.normsq(iso, minkowski(dim)), axis=-1)
    t_index = np.argmin(lengths, axis=-2)

    #apply a permutation so the isometry actually preserves the
    #form. we do the permutation in two steps because it could be
    #either a 2-cycle or a 3-cycle.
    p_iso = iso.copy()

    #first swap timelike index with zero
    indices = np.stack([np.zeros_like(t_index), t_index], axis=-2)
    p_indices = np.stack([t_index, np.zeros_like(t_index)], axis=-2)

    p_values = np.take_along_axis(iso, indices, axis=-2)
    np.put_along_axis(p_iso, p_indices, p_values, axis=-2)

    #then swap timelike index with one
    indices = np.stack([np.ones_like(t_index), t_index], axis=-2)
    p_indices = np.stack([t_index, np.ones_like(t_index)], axis=-2)

    p_values = np.take_along_axis(p_iso, indices, axis=-2)
    np.put_along_axis(p_iso, p_indices, p_values, axis=-2)

    if force_oriented:
        p_iso = utils.make_orientation_preserving(p_iso)

    return Isometry(p_iso, column_vectors=False)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.timelike"><code class="name flex">
<span>def <span class="ident">timelike</span></span>(<span>self, vectors)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if a vector in R^(n,1) is timelike.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vectors</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Vectors to test for timelike norms. The last index of the
array is the dimension of the vector space.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray(bool)</code></dt>
<dd><code>True</code> for vectors which have Minkowski norm below a fixed
error threshold.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timelike(self, vectors):
    &#34;&#34;&#34;Determine if a vector in R^(n,1) is timelike.

    Parameters
    ----------
    vectors : ndarray
        Vectors to test for timelike norms. The last index of the
        array is the dimension of the vector space.

    Returns
    -------
    ndarray(bool)
        `True` for vectors which have Minkowski norm below a fixed
        error threshold.

    &#34;&#34;&#34;
    dim = np.array(vectors).shape[-1]
    return (utils.normsq(vectors, minkowski(dim)) &lt; ERROR_THRESHOLD)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.timelike_to"><code class="name flex">
<span>def <span class="ident">timelike_to</span></span>(<span>self, v, force_oriented=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Find an isometry taking the origin of the Poincare/Klein models to
the given vector v.</p>
<p>We expect v to be timelike in order for this to make sense.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timelike_to(self, v, force_oriented=False):
    &#34;&#34;&#34;Find an isometry taking the origin of the Poincare/Klein models to
    the given vector v.

    We expect v to be timelike in order for this to make sense.

    &#34;&#34;&#34;
    if not timelike(v).all():
        raise GeometryError( &#34;Cannot find isometry taking a&#34;
        &#34; timelike vector to a non-timelike vector.&#34;  )

    dim = np.array(vectors).shape[-1]
    return Isometry(utils.find_isometry(minkowski(dim),
                                        v, force_oriented),
                    column_vectors=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geometry_tools.hyperbolic.BoundaryArc"><code class="flex name class">
<span>class <span class="ident">BoundaryArc</span></span>
<span>(</span><span>endpoint1, endpoint2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for an arc sitting in the boundary of hyperbolic space.</p>
<p>If <code>endpoint2</code> is <code>None</code>, interpret <code>endpoint1</code> as either a (2
x&hellip;x n) <code>ndarray</code> (where n is the dimension of the underlying
vector space), or else a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> object which can be
unpacked into two Points (which may themselves be composite).</p>
<p>If <code>endpoint2</code> is given, then both <code>endpoint1</code> and <code>endpoint2</code>
can be used to construct <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> objects, which serve as the
endpoints for this pair of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>endpoint1</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>One (or both) endpoints of the point pair</dd>
<dt><strong><code>endpoint2</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The other endpoint of the point pair. If <code>None</code>,
<code>endpoint1</code> contains the data for both points in the pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundaryArc(Geodesic):
    &#34;&#34;&#34;Model for an arc sitting in the boundary of hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, endpoint1, endpoint2=None):
        PointPair.__init__(self, endpoint1, endpoint2)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.endpoints = proj_data[..., :2, :]
        self.orientation_pt = proj_data[..., 2, :]

    def set_endpoints(self, endpoint1, endpoint2):
        if endpoint2 is None:
            endpoint_data = Point(endpoint1).proj_data
        else:
            pt1 = Point(endpoint1)
            pt2 = Point(endpoint2)
            endpoint_data = np.stack(
                [pt1.proj_data, pt2.proj_data], axis=-2
            )

        self._build_orientation_point(endpoint_data)

    def orientation(self):
        return np.linalg.det(self.proj_data)

    def flip_orientation(self):
        self.proj_data[..., 2, :] *= -1
        self.set(self.proj_data)

    def endpoint_coords(self, model, ordered=True):
        endpoints = Geodesic.endpoint_coords(self, model)
        endpoints[self.orientation() &lt; 0] = np.flip(
            endpoints[self.orientation() &lt; 0],
            axis=-2
        )
        return endpoints

    def _build_orientation_point(self, endpoints):
        n = endpoints.shape[-1]
        orientation_pt_1 = np.zeros(endpoints.shape[:-2] +
                                    (1, n))
        orientation_pt_2 = np.zeros(endpoints.shape[:-2] +
                                    (1, n))
        orientation_pt_1[..., 0, 0] = 1.0
        orientation_pt_2[..., 0, 1] = 1.0

        point_data = np.concatenate((endpoints, orientation_pt_1), axis=-2)

        dets = np.linalg.det(point_data)
        point_data[np.abs(dets) &lt; ERROR_THRESHOLD, 2] = orientation_pt_2

        signs = np.linalg.det(point_data)
        point_data[signs &lt; 0, 2] *= -1

        self.set(point_data)


    def circle_parameters(self, model=Model.POINCARE, degrees=True):
        &#34;&#34;&#34;Compute parameters (center, radius) for this boundary arc.

        &#34;&#34;&#34;
        if model != Model.POINCARE and model != Model.KLEIN:
            raise GeometryError(
                (&#34;Cannot compute circular parameters for a boundary arc in model: &#39;{}&#39;&#34;
                 ).format(model)
            )
        center = np.zeros(self.proj_data.shape[:-2] + (2,))
        radius = np.ones(self.proj_data.shape[:-2])

        coords = self.endpoint_coords(model, ordered=True)
        thetas = utils.circle_angles(center, coords)

        if degrees:
            thetas *= 180 / np.pi



        return center, radius, thetas</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></li>
<li><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></li>
<li><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></li>
<li><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.PointPair" href="projective.html#geometry_tools.projective.PointPair">PointPair</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.BoundaryArc.circle_parameters"><code class="name flex">
<span>def <span class="ident">circle_parameters</span></span>(<span>self, model=Model.POINCARE, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute parameters (center, radius) for this boundary arc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_parameters(self, model=Model.POINCARE, degrees=True):
    &#34;&#34;&#34;Compute parameters (center, radius) for this boundary arc.

    &#34;&#34;&#34;
    if model != Model.POINCARE and model != Model.KLEIN:
        raise GeometryError(
            (&#34;Cannot compute circular parameters for a boundary arc in model: &#39;{}&#39;&#34;
             ).format(model)
        )
    center = np.zeros(self.proj_data.shape[:-2] + (2,))
    radius = np.ones(self.proj_data.shape[:-2])

    coords = self.endpoint_coords(model, ordered=True)
    thetas = utils.circle_angles(center, coords)

    if degrees:
        thetas *= 180 / np.pi



    return center, radius, thetas</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.BoundaryArc.flip_orientation"><code class="name flex">
<span>def <span class="ident">flip_orientation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip_orientation(self):
    self.proj_data[..., 2, :] *= -1
    self.set(self.proj_data)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.BoundaryArc.orientation"><code class="name flex">
<span>def <span class="ident">orientation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orientation(self):
    return np.linalg.det(self.proj_data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Geodesic.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.endpoint_affine_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_affine_coords">endpoint_affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.endpoint_coords" href="#geometry_tools.hyperbolic.PointPair.endpoint_coords">endpoint_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.endpoint_projective_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_projective_coords">endpoint_projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.from_reflection" href="#geometry_tools.hyperbolic.Geodesic.from_reflection">from_reflection</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.get_end_pair" href="#geometry_tools.hyperbolic.PointPair.get_end_pair">get_end_pair</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.get_endpoints" href="#geometry_tools.hyperbolic.PointPair.get_endpoints">get_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.ideal_basis_coords" href="#geometry_tools.hyperbolic.Subspace.ideal_basis_coords">ideal_basis_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.reflection_across" href="#geometry_tools.hyperbolic.Subspace.reflection_across">reflection_across</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.set_endpoints" href="projective.html#geometry_tools.projective.PointPair.set_endpoints">set_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.spacelike_complement" href="#geometry_tools.hyperbolic.Subspace.spacelike_complement">spacelike_complement</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.sphere_parameters" href="#geometry_tools.hyperbolic.Subspace.sphere_parameters">sphere_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.DualPoint"><code class="flex name class">
<span>class <span class="ident">DualPoint</span></span>
<span>(</span><span>point, model=Model.PROJECTIVE)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a "dual point" in hyperbolic space (a point in the
complement of the projectivization of the Minkowski light cone,
corresponding to a geodesic hyperplane in hyperbolic space).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>iterable</code> or <code>ndarray</code></dt>
<dd>Data used to construct a point or an array of points. If
<code>point</code> is a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>, then use the underlying
coordinate data to build an array of points. If <code>point</code> is
an iterable of <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>s, build a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
object out of this array. If <code>point</code> is an <code>ndarray</code>, then
interpret this as coordinate data for an array of points
in some hyperbolic model.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>if <code>point</code> is numerical data, then what model of
hyperbolic space we should use to interpret <code>point</code> as
coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DualPoint(Point):
    &#34;&#34;&#34;Model for a &#34;dual point&#34; in hyperbolic space (a point in the
    complement of the projectivization of the Minkowski light cone,
    corresponding to a geodesic hyperplane in hyperbolic space).

    &#34;&#34;&#34;

    def _assert_geometry_valid(self, proj_data):
        Point._assert_geometry_valid(self, proj_data)
        if not CHECK_LIGHT_CONE:
            return

        if not spacelike(proj_data).all():
            raise GeometryError(&#34;Dual point data must consist of vectors&#34;
                                &#34; in the complement of the Minkowski light cone&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Point.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Geodesic"><code class="flex name class">
<span>class <span class="ident">Geodesic</span></span>
<span>(</span><span>endpoint1, endpoint2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a bi-infinite gedoesic in hyperbolic space.</p>
<p>If <code>endpoint2</code> is <code>None</code>, interpret <code>endpoint1</code> as either a (2
x&hellip;x n) <code>ndarray</code> (where n is the dimension of the underlying
vector space), or else a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> object which can be
unpacked into two Points (which may themselves be composite).</p>
<p>If <code>endpoint2</code> is given, then both <code>endpoint1</code> and <code>endpoint2</code>
can be used to construct <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> objects, which serve as the
endpoints for this pair of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>endpoint1</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>One (or both) endpoints of the point pair</dd>
<dt><strong><code>endpoint2</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The other endpoint of the point pair. If <code>None</code>,
<code>endpoint1</code> contains the data for both points in the pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geodesic(PointPair, Subspace):
    &#34;&#34;&#34;Model for a bi-infinite gedoesic in hyperbolic space.

    &#34;&#34;&#34;
    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.endpoints = self.proj_data[..., :2, :]
        self.ideal_basis = self.proj_data[..., :2, :]

    def circle_parameters(self, degrees=True, model=Model.POINCARE):
        &#34;&#34;&#34;Get parameters describing a circular arc corresponding to this
        geodesic in the Poincare or halfspace models.

        Parameters
        ----------
        degrees : bool
            if `True`, return angles in degrees. Otherwise, return
            angles in radians
        model : Model
            hyperbolic model to use for the computation

        Returns
        -------
        tuple
            tuple `(centers, radii, thetas)`, where `centers`,
            `radii`, and `thetas` are `ndarray`s representing the
            centers, radii, and begin/end angles for the circle
            corresponding to this arc in the given model of hyperbolic
            space. Angles are always specified in counterclockwise
            order.

        &#34;&#34;&#34;
        center, radius = self.sphere_parameters(model)
        endpoints = self.ideal_basis_coords(model)
        thetas = utils.circle_angles(center, endpoints)

        if model == Model.POINCARE:
            thetas = utils.short_arc(thetas)

        if model == Model.HALFSPACE:
            thetas = utils.right_to_left(thetas)

        if degrees:
            thetas *= 180 / np.pi

        return center, radius, thetas

    @classmethod
    def from_reflection(cls, reflection):
        &#34;&#34;&#34;Construct a geodesic which is the fixpoint set of a reflection.

        Parameters
        ----------
        reflection : Isometry or ndarray
            The reflection to compute the fixed geodesic for

        Raises
        ------
        GeometryError :
            If the given isometry is not a reflection, or if the
            dimension of the underlying hyperbolic space is not 2.

        Returns
        -------
        Geodesic
            A `Geodesic` fixed by the given isometry.

    &#34;&#34;&#34;
        if reflection.dimension != 2:
            raise GeometryError(&#34;Creating segment from reflection expects dimension 2, got dimension {}&#34;.format(reflection.dimension))

        hyperplane = Hyperplane.from_reflection(reflection)
        pt1 = hyperplane.ideal_basis[..., 0, :]
        pt2 = hyperplane.ideal_basis[..., 1, :]
        return Geodesic(pt1, pt2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></li>
<li><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></li>
<li><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.PointPair" href="projective.html#geometry_tools.projective.PointPair">PointPair</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.BoundaryArc" href="#geometry_tools.hyperbolic.BoundaryArc">BoundaryArc</a></li>
<li><a title="geometry_tools.hyperbolic.Segment" href="#geometry_tools.hyperbolic.Segment">Segment</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Geodesic.from_reflection"><code class="name flex">
<span>def <span class="ident">from_reflection</span></span>(<span>reflection)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a geodesic which is the fixpoint set of a reflection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reflection</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code> or <code>ndarray</code></dt>
<dd>The reflection to compute the fixed geodesic for</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GeometryError :</code></dt>
<dd>If the given isometry is not a reflection, or if the
dimension of the underlying hyperbolic space is not 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></code></dt>
<dd>A <code><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></code> fixed by the given isometry.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_reflection(cls, reflection):
    &#34;&#34;&#34;Construct a geodesic which is the fixpoint set of a reflection.

    Parameters
    ----------
    reflection : Isometry or ndarray
        The reflection to compute the fixed geodesic for

    Raises
    ------
    GeometryError :
        If the given isometry is not a reflection, or if the
        dimension of the underlying hyperbolic space is not 2.

    Returns
    -------
    Geodesic
        A `Geodesic` fixed by the given isometry.

&#34;&#34;&#34;
    if reflection.dimension != 2:
        raise GeometryError(&#34;Creating segment from reflection expects dimension 2, got dimension {}&#34;.format(reflection.dimension))

    hyperplane = Hyperplane.from_reflection(reflection)
    pt1 = hyperplane.ideal_basis[..., 0, :]
    pt2 = hyperplane.ideal_basis[..., 1, :]
    return Geodesic(pt1, pt2)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Geodesic.circle_parameters"><code class="name flex">
<span>def <span class="ident">circle_parameters</span></span>(<span>self, degrees=True, model=Model.POINCARE)</span>
</code></dt>
<dd>
<div class="desc"><p>Get parameters describing a circular arc corresponding to this
geodesic in the Poincare or halfspace models.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>degrees</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, return angles in degrees. Otherwise, return
angles in radians</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>hyperbolic model to use for the computation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>tuple <code>(centers, radii, thetas)</code>, where <code>centers</code>,
<code>radii</code>, and <code>thetas</code> are <code>ndarray</code>s representing the
centers, radii, and begin/end angles for the circle
corresponding to this arc in the given model of hyperbolic
space. Angles are always specified in counterclockwise
order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_parameters(self, degrees=True, model=Model.POINCARE):
    &#34;&#34;&#34;Get parameters describing a circular arc corresponding to this
    geodesic in the Poincare or halfspace models.

    Parameters
    ----------
    degrees : bool
        if `True`, return angles in degrees. Otherwise, return
        angles in radians
    model : Model
        hyperbolic model to use for the computation

    Returns
    -------
    tuple
        tuple `(centers, radii, thetas)`, where `centers`,
        `radii`, and `thetas` are `ndarray`s representing the
        centers, radii, and begin/end angles for the circle
        corresponding to this arc in the given model of hyperbolic
        space. Angles are always specified in counterclockwise
        order.

    &#34;&#34;&#34;
    center, radius = self.sphere_parameters(model)
    endpoints = self.ideal_basis_coords(model)
    thetas = utils.circle_angles(center, endpoints)

    if model == Model.POINCARE:
        thetas = utils.short_arc(thetas)

    if model == Model.HALFSPACE:
        thetas = utils.right_to_left(thetas)

    if degrees:
        thetas *= 180 / np.pi

    return center, radius, thetas</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.PointPair.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_affine_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_affine_coords">endpoint_affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_coords" href="#geometry_tools.hyperbolic.PointPair.endpoint_coords">endpoint_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_projective_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_projective_coords">endpoint_projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_end_pair" href="#geometry_tools.hyperbolic.PointPair.get_end_pair">get_end_pair</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_endpoints" href="#geometry_tools.hyperbolic.PointPair.get_endpoints">get_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.set_endpoints" href="projective.html#geometry_tools.projective.PointPair.set_endpoints">set_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
<li><code><b><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Subspace.ideal_basis_coords" href="#geometry_tools.hyperbolic.Subspace.ideal_basis_coords">ideal_basis_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.reflection_across" href="#geometry_tools.hyperbolic.Subspace.reflection_across">reflection_across</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.spacelike_complement" href="#geometry_tools.hyperbolic.Subspace.spacelike_complement">spacelike_complement</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.sphere_parameters" href="#geometry_tools.hyperbolic.Subspace.sphere_parameters">sphere_parameters</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Horosphere"><code class="flex name class">
<span>class <span class="ident">Horosphere</span></span>
<span>(</span><span>center, reference_point=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a horosphere in hyperbolic space.</p>
<p>If <code>reference_point</code> is <code>None</code>, interpret <code>center</code> as either:</p>
<ul>
<li>
<p>a (&hellip;, 2, n) <code>ndarray</code>, where first row of the last two
ndindices gives the (ideal) center point for this horosphere,
and the second row gives some reference point on the
horosphere itself, or</p>
</li>
<li>
<p>a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> whose underlying data has the form above.</p>
</li>
</ul>
<p>If <code>reference_point</code> is given, then <code>center</code> can be used to
construct an <code><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></code> giving the center of the horosphere,
and <code>reference_point</code> can be used to construct a <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
giving some point on the horosphere.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The (ideal) center point for this horosphere, or an object
which can be unpacked into all of the data for the
horosphere</dd>
<dt><strong><code>reference_point</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>Any point lying on the horosphere itself. If <code>None</code>, then
<code>center</code> contains the data for the reference point as
well.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Horosphere(HyperbolicObject):
    &#34;&#34;&#34;Model for a horosphere in hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, center, reference_point=None):
        &#34;&#34;&#34;If `reference_point` is `None`, interpret `center` as either:

        - a (..., 2, n) `ndarray`, where first row of the last two
        ndindices gives the (ideal) center point for this horosphere,
        and the second row gives some reference point on the
        horosphere itself, or

        - a `HyperbolicObject` whose underlying data has the form above.

        If `reference_point` is given, then `center` can be used to
        construct an `IdealPoint` giving the center of the horosphere,
        and `reference_point` can be used to construct a `Point`
        giving some point on the horosphere.

        Parameters
        ----------
        center : Point or ndarray
            The (ideal) center point for this horosphere, or an object
            which can be unpacked into all of the data for the
            horosphere
        reference_point : Point or ndarray
            Any point lying on the horosphere itself. If `None`, then
            `center` contains the data for the reference point as
            well.

        &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if reference_point is None:
            try:
                self._construct_from_object(center)
                return
            except TypeError:
                pass

        self.set_center_ref(center, reference_point)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.center = proj_data[..., 0, :]
        self.reference = proj_data[..., 1, :]

    def set_center_ref(self, center, reference_point=None):
        if reference_point is None:
            proj_data = Point(center).proj_data
        else:
            center = IdealPoint(center)
            ref = Point(reference_point)
            proj_data = np.stack([center.proj_data, ref.proj_data], axis=-2)

        self.set(proj_data)

    def sphere_parameters(self, model=Model.POINCARE):
        &#34;&#34;&#34;Get the center and radius of a sphere giving this horosphere in
        poincare coordinates.

        &#34;&#34;&#34;
        ideal_coords = Point(self.center).coords(model)
        ref_coords = Point(self.reference).coords(model)

        if model == Model.POINCARE:
            model_radius = (utils.normsq(ideal_coords - ref_coords) /
                            (2 * (1 - utils.apply_bilinear(ideal_coords,
                                                           ref_coords))))
            model_center = ideal_coords * (1 - model_radius[..., np.newaxis])
        elif model == Model.HALFSPACE:
            with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
                ideal_euc = ideal_coords[..., :-1]
                ref_euc = ref_coords[..., :-1]
                ref_z = ref_coords[..., -1]

                model_radius = 0.5 * (utils.normsq(ideal_euc - ref_euc) / ref_z + ref_z)
                model_center = ideal_coords[:]
                model_center[..., -1] = model_radius
        else:
            raise GeometryError(
                &#34;No implementation for spherical parameters for a horosphere in&#34;
                &#34; model: &#39;{}&#39;&#34;.format(model)
            )

        return model_center, model_radius

    def center_coords(self, model=Model.KLEIN):
        return Point(self.center).coords(model)

    def ref_coords(self, model):
        return Point(self.reference).coords(model)

    def intersect_geodesic(self, geodesic, p2=None):
        &#34;&#34;&#34;Compute the intersection points of a geodesic with this horosphere

        &#34;&#34;&#34;
        segment = Segment(geodesic, p2)
        geodesic_endpts = segment.ideal_endpoint_coords(Model.KLEIN)

        # compute an isometry taking this geodesic to one which passes
        # through the origin (so we can do intersection calculations
        # in Euclidean geometry)
        midpt = Point((geodesic_endpts[..., 0, :] + geodesic_endpts[..., 1, :]) / 2.,
                       model=Model.KLEIN)
        coord_change = midpt.origin_to()
        coord_inv = coord_change.inv()

        c_hsph = coord_inv @ self
        c_seg = coord_inv @ segment

        p_center, p_radius = c_hsph.sphere_parameters()
        geodesic_endpts = c_seg.ideal_endpoint_coords(Model.KLEIN)

        u = geodesic_endpts[..., 0, :]
        v = geodesic_endpts[..., 1, :]

        a = utils.normsq(u - v)
        b = 2 * ((utils.apply_bilinear(p_center, v - u) +
                  utils.apply_bilinear(u, v) -
                  utils.normsq(u)))
        c = utils.normsq(v - p_center) - p_radius**2

        #TODO: check to see if the intersection actually occurs
        t1 = (-1 * b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)
        t2 = (-1 * b - np.sqrt(b**2 - 4 * a * c)) / (2 * a)

        p1_poincare = t1 * u + (1 - t1) * v
        p2_poincare = t2 * u + (1 - t2) * v

        poincare_pts = np.stack([p1_poincare, p2_poincare], axis=-2)
        klein_pts = poincare_to_kleinian(poincare_pts)

        return coord_change @ Point(klein_pts, model=Model.KLEIN)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.HorosphereArc" href="#geometry_tools.hyperbolic.HorosphereArc">HorosphereArc</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Horosphere.center_coords"><code class="name flex">
<span>def <span class="ident">center_coords</span></span>(<span>self, model=Model.KLEIN)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_coords(self, model=Model.KLEIN):
    return Point(self.center).coords(model)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Horosphere.intersect_geodesic"><code class="name flex">
<span>def <span class="ident">intersect_geodesic</span></span>(<span>self, geodesic, p2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the intersection points of a geodesic with this horosphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect_geodesic(self, geodesic, p2=None):
    &#34;&#34;&#34;Compute the intersection points of a geodesic with this horosphere

    &#34;&#34;&#34;
    segment = Segment(geodesic, p2)
    geodesic_endpts = segment.ideal_endpoint_coords(Model.KLEIN)

    # compute an isometry taking this geodesic to one which passes
    # through the origin (so we can do intersection calculations
    # in Euclidean geometry)
    midpt = Point((geodesic_endpts[..., 0, :] + geodesic_endpts[..., 1, :]) / 2.,
                   model=Model.KLEIN)
    coord_change = midpt.origin_to()
    coord_inv = coord_change.inv()

    c_hsph = coord_inv @ self
    c_seg = coord_inv @ segment

    p_center, p_radius = c_hsph.sphere_parameters()
    geodesic_endpts = c_seg.ideal_endpoint_coords(Model.KLEIN)

    u = geodesic_endpts[..., 0, :]
    v = geodesic_endpts[..., 1, :]

    a = utils.normsq(u - v)
    b = 2 * ((utils.apply_bilinear(p_center, v - u) +
              utils.apply_bilinear(u, v) -
              utils.normsq(u)))
    c = utils.normsq(v - p_center) - p_radius**2

    #TODO: check to see if the intersection actually occurs
    t1 = (-1 * b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)
    t2 = (-1 * b - np.sqrt(b**2 - 4 * a * c)) / (2 * a)

    p1_poincare = t1 * u + (1 - t1) * v
    p2_poincare = t2 * u + (1 - t2) * v

    poincare_pts = np.stack([p1_poincare, p2_poincare], axis=-2)
    klein_pts = poincare_to_kleinian(poincare_pts)

    return coord_change @ Point(klein_pts, model=Model.KLEIN)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Horosphere.ref_coords"><code class="name flex">
<span>def <span class="ident">ref_coords</span></span>(<span>self, model)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ref_coords(self, model):
    return Point(self.reference).coords(model)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Horosphere.set_center_ref"><code class="name flex">
<span>def <span class="ident">set_center_ref</span></span>(<span>self, center, reference_point=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_center_ref(self, center, reference_point=None):
    if reference_point is None:
        proj_data = Point(center).proj_data
    else:
        center = IdealPoint(center)
        ref = Point(reference_point)
        proj_data = np.stack([center.proj_data, ref.proj_data], axis=-2)

    self.set(proj_data)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Horosphere.sphere_parameters"><code class="name flex">
<span>def <span class="ident">sphere_parameters</span></span>(<span>self, model=Model.POINCARE)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the center and radius of a sphere giving this horosphere in
poincare coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere_parameters(self, model=Model.POINCARE):
    &#34;&#34;&#34;Get the center and radius of a sphere giving this horosphere in
    poincare coordinates.

    &#34;&#34;&#34;
    ideal_coords = Point(self.center).coords(model)
    ref_coords = Point(self.reference).coords(model)

    if model == Model.POINCARE:
        model_radius = (utils.normsq(ideal_coords - ref_coords) /
                        (2 * (1 - utils.apply_bilinear(ideal_coords,
                                                       ref_coords))))
        model_center = ideal_coords * (1 - model_radius[..., np.newaxis])
    elif model == Model.HALFSPACE:
        with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
            ideal_euc = ideal_coords[..., :-1]
            ref_euc = ref_coords[..., :-1]
            ref_z = ref_coords[..., -1]

            model_radius = 0.5 * (utils.normsq(ideal_euc - ref_euc) / ref_z + ref_z)
            model_center = ideal_coords[:]
            model_center[..., -1] = model_radius
    else:
        raise GeometryError(
            &#34;No implementation for spherical parameters for a horosphere in&#34;
            &#34; model: &#39;{}&#39;&#34;.format(model)
        )

    return model_center, model_radius</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.coords" href="#geometry_tools.hyperbolic.HyperbolicObject.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.HorosphereArc"><code class="flex name class">
<span>class <span class="ident">HorosphereArc</span></span>
<span>(</span><span>center, p1=None, p2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for an arc lying along a horosphere</p>
<p>If <code>reference_point</code> is <code>None</code>, interpret <code>center</code> as either:</p>
<ul>
<li>
<p>a (&hellip;, 2, n) <code>ndarray</code>, where first row of the last two
ndindices gives the (ideal) center point for this horosphere,
and the second row gives some reference point on the
horosphere itself, or</p>
</li>
<li>
<p>a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> whose underlying data has the form above.</p>
</li>
</ul>
<p>If <code>reference_point</code> is given, then <code>center</code> can be used to
construct an <code><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></code> giving the center of the horosphere,
and <code>reference_point</code> can be used to construct a <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
giving some point on the horosphere.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The (ideal) center point for this horosphere, or an object
which can be unpacked into all of the data for the
horosphere</dd>
<dt><strong><code>reference_point</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>Any point lying on the horosphere itself. If <code>None</code>, then
<code>center</code> contains the data for the reference point as
well.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HorosphereArc(Horosphere, PointPair):
    &#34;&#34;&#34;Model for an arc lying along a horosphere

    &#34;&#34;&#34;
    def __init__(self, center, p1=None, p2=None):
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if p1 is None and p2 is None:
            try:
                self._construct_from_object(center)
                return
            except TypeError:
                pass
            try:
                self.set(center)
                return
            except (AttributeError, GeometryError):
                pass

        self.set_center_endpoints(center, p1, p2)

    def set_center_endpoints(self, center, p1=None, p2=None):
        if ((p1 is None and p2 is not None) or
            (p1 is not None and p2 is None)):
            raise GeometryError(
                &#34;Horospherical arc determined by two endpoints and a centerpoint, but&#34;
                &#34; this was not provided&#34;
            )

        if p2 is None:
            proj_data = Point(center).proj_data
        else:
            center_data = Point(center).proj_data
            p1_data = Point(p1).proj_data
            p2_data = Point(p2).proj_data
            proj_data = np.stack([center_data, p1_data, p2_data], axis=-2)

        self.set(proj_data)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.center = self.proj_data[..., 0, :]
        self.reference = self.proj_data[..., 1, :]
        self.endpoints = self.proj_data[..., 1:, :]

    def circle_parameters(self, model=Model.POINCARE, degrees=True):
        &#34;&#34;&#34;Get parameters for a circle describing this horospherical arc.

        &#34;&#34;&#34;
        center, radius = Horosphere.sphere_parameters(self, model=model)
        model_coords = self.endpoint_coords(model)

        thetas = utils.circle_angles(center, model_coords)

        center_theta = utils.circle_angles(
            center, self.center_coords(model=model)
        )[..., 0]

        thetas = np.flip(utils.arc_include(thetas, center_theta), axis=-1)

        if degrees:
            thetas *= 180 / np.pi

        return center, radius, thetas</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Horosphere" href="#geometry_tools.hyperbolic.Horosphere">Horosphere</a></li>
<li><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.PointPair" href="projective.html#geometry_tools.projective.PointPair">PointPair</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.HorosphereArc.circle_parameters"><code class="name flex">
<span>def <span class="ident">circle_parameters</span></span>(<span>self, model=Model.POINCARE, degrees=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get parameters for a circle describing this horospherical arc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_parameters(self, model=Model.POINCARE, degrees=True):
    &#34;&#34;&#34;Get parameters for a circle describing this horospherical arc.

    &#34;&#34;&#34;
    center, radius = Horosphere.sphere_parameters(self, model=model)
    model_coords = self.endpoint_coords(model)

    thetas = utils.circle_angles(center, model_coords)

    center_theta = utils.circle_angles(
        center, self.center_coords(model=model)
    )[..., 0]

    thetas = np.flip(utils.arc_include(thetas, center_theta), axis=-1)

    if degrees:
        thetas *= 180 / np.pi

    return center, radius, thetas</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.HorosphereArc.set_center_endpoints"><code class="name flex">
<span>def <span class="ident">set_center_endpoints</span></span>(<span>self, center, p1=None, p2=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_center_endpoints(self, center, p1=None, p2=None):
    if ((p1 is None and p2 is not None) or
        (p1 is not None and p2 is None)):
        raise GeometryError(
            &#34;Horospherical arc determined by two endpoints and a centerpoint, but&#34;
            &#34; this was not provided&#34;
        )

    if p2 is None:
        proj_data = Point(center).proj_data
    else:
        center_data = Point(center).proj_data
        p1_data = Point(p1).proj_data
        p2_data = Point(p2).proj_data
        proj_data = np.stack([center_data, p1_data, p2_data], axis=-2)

    self.set(proj_data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Horosphere" href="#geometry_tools.hyperbolic.Horosphere">Horosphere</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Horosphere.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.coords" href="#geometry_tools.hyperbolic.HyperbolicObject.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.intersect_geodesic" href="#geometry_tools.hyperbolic.Horosphere.intersect_geodesic">intersect_geodesic</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.sphere_parameters" href="#geometry_tools.hyperbolic.Horosphere.sphere_parameters">sphere_parameters</a></code></li>
</ul>
</li>
<li><code><b><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.PointPair.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_affine_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_affine_coords">endpoint_affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_coords" href="#geometry_tools.hyperbolic.PointPair.endpoint_coords">endpoint_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_projective_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_projective_coords">endpoint_projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_end_pair" href="#geometry_tools.hyperbolic.PointPair.get_end_pair">get_end_pair</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_endpoints" href="#geometry_tools.hyperbolic.PointPair.get_endpoints">get_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.set_endpoints" href="projective.html#geometry_tools.projective.PointPair.set_endpoints">set_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.HyperbolicObject"><code class="flex name class">
<span>class <span class="ident">HyperbolicObject</span></span>
<span>(</span><span>proj_data, aux_data=None, dual_data=None, unit_ndims=1, aux_ndims=0, dual_ndims=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for an abstract object in hyperbolic space.</p>
<p>Subclasses of HyperbolicObject model more specific objects in
hyperbolic geometry, e.g. points, geodesic segments, hyperplanes,
ideal points.</p>
<p>Every object in hyperbolic space H^n has the underlying data of an
ndarray whose last dimension is n+1. This is interpreted as a
collection of (row) vectors in R^(n+1), or more precisely R^(n,1),
which transforms via the action of the indefinite orthogonal group
O(n,1).</p>
<p>The last <code>unit_ndims</code> dimensions of this underlying array represent
a single object in hyperbolic space, which transforms as a unit
under the action of O(n,1). The remaining dimensions of the array
are used to represent an array of such "unit objects."</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>underyling data describing this projective object</dd>
<dt><strong><code>aux_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>auxiliary data describing this projective
object. Auxiliary data is any data which is in principle
computable from <code>proj_data</code>, but is convenient to keep as
part of the object definition for transformation purposes.</dd>
<dt><strong><code>dual_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>data describing this projective object which transforms
covariantly, i.e. as a dual vector in projective space.</dd>
<dt><strong><code>unit_ndims</code></strong> :&ensp;<code>int</code></dt>
<dd>number of ndims of an array representing a "unit" version
of this object. For example, an object representing a
single point in hyperbolic space has <code>unit_ndims</code> 1, while
an object representing a line segment has <code>unit_ndims</code>
equal to 2.</dd>
<dt><strong><code>aux_ndims</code></strong> :&ensp;<code>int</code></dt>
<dd>like <code>unit_ndims</code>, but for auxiliary data.</dd>
<dt><strong><code>dual_ndims</code></strong> :&ensp;<code>int</code></dt>
<dd>like <code>unit_ndims</code>, but for covariant (dual) data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HyperbolicObject(projective.ProjectiveObject):
    &#34;&#34;&#34;Model for an abstract object in hyperbolic space.

    Subclasses of HyperbolicObject model more specific objects in
    hyperbolic geometry, e.g. points, geodesic segments, hyperplanes,
    ideal points.

    Every object in hyperbolic space H^n has the underlying data of an
    ndarray whose last dimension is n+1. This is interpreted as a
    collection of (row) vectors in R^(n+1), or more precisely R^(n,1),
    which transforms via the action of the indefinite orthogonal group
    O(n,1).

    The last `unit_ndims` dimensions of this underlying array represent
    a single object in hyperbolic space, which transforms as a unit
    under the action of O(n,1). The remaining dimensions of the array
    are used to represent an array of such &#34;unit objects.&#34;

    &#34;&#34;&#34;

    @property
    def minkowski(self):
        return minkowski(self.dimension + 1)


    def coords(self, model, proj_data=None):
        &#34;&#34;&#34;Get or set a representation of this hyperbolic object in
        coordinates.

        For the base `HyperbolicObject` class, the available models
        are `Model.KLEIN` and `Model.PROJECTIVE`.

        Parameters
        ----------
        model : Model
            which model to take coordinates in
        proj_data : ndarray
            data for this hyperbolic object, interpreted as
            coordinates with respect to `model`. If `None`, just
            return coordinates.

        Raises
        ------
        GeometryError
            Raised if an unsupported model is specified.

        &#34;&#34;&#34;
        if model == Model.KLEIN:
            return self.kleinian_coords(proj_data)
        if model == Model.PROJECTIVE:
            return self.projective_coords(proj_data)

        raise GeometryError(
            &#34;Unimplemented model for an object of type {}: &#39;{}&#39;&#34;.format(
                self.__class__.__name__, model
            ))

    def kleinian_coords(self, aff_data=None):
        return self.affine_coords(aff_data, chart_index=0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Horosphere" href="#geometry_tools.hyperbolic.Horosphere">Horosphere</a></li>
<li><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="geometry_tools.hyperbolic.HyperbolicObject.minkowski"><code class="name">var <span class="ident">minkowski</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def minkowski(self):
    return minkowski(self.dimension + 1)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.HyperbolicObject.coords"><code class="name flex">
<span>def <span class="ident">coords</span></span>(<span>self, model, proj_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set a representation of this hyperbolic object in
coordinates.</p>
<p>For the base <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> class, the available models
are <code><a title="geometry_tools.hyperbolic.Model.KLEIN" href="#geometry_tools.hyperbolic.Model.KLEIN">Model.KLEIN</a></code> and <code><a title="geometry_tools.hyperbolic.Model.PROJECTIVE" href="#geometry_tools.hyperbolic.Model.PROJECTIVE">Model.PROJECTIVE</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>which model to take coordinates in</dd>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>data for this hyperbolic object, interpreted as
coordinates with respect to <code>model</code>. If <code>None</code>, just
return coordinates.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GeometryError</code></dt>
<dd>Raised if an unsupported model is specified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords(self, model, proj_data=None):
    &#34;&#34;&#34;Get or set a representation of this hyperbolic object in
    coordinates.

    For the base `HyperbolicObject` class, the available models
    are `Model.KLEIN` and `Model.PROJECTIVE`.

    Parameters
    ----------
    model : Model
        which model to take coordinates in
    proj_data : ndarray
        data for this hyperbolic object, interpreted as
        coordinates with respect to `model`. If `None`, just
        return coordinates.

    Raises
    ------
    GeometryError
        Raised if an unsupported model is specified.

    &#34;&#34;&#34;
    if model == Model.KLEIN:
        return self.kleinian_coords(proj_data)
    if model == Model.PROJECTIVE:
        return self.projective_coords(proj_data)

    raise GeometryError(
        &#34;Unimplemented model for an object of type {}: &#39;{}&#39;&#34;.format(
            self.__class__.__name__, model
        ))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.HyperbolicObject.kleinian_coords"><code class="name flex">
<span>def <span class="ident">kleinian_coords</span></span>(<span>self, aff_data=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kleinian_coords(self, aff_data=None):
    return self.affine_coords(aff_data, chart_index=0)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.ProjectiveObject.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.HyperbolicRepresentation"><code class="flex name class">
<span>class <span class="ident">HyperbolicRepresentation</span></span>
<span>(</span><span>representation=None, generator_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model a representation for a finitely generated group
representation into O(n,1).</p>
<p>Really this is just a convenient way of mapping words in the
generators to hyperbolic isometries - there's no group theory
being done here at all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>representation</code></strong> :&ensp;<code>Representation</code></dt>
<dd>Representation to copy elements from</dd>
<dt><strong><code>generator_names</code></strong> :&ensp;<code>iterable</code> of <code>strings</code></dt>
<dd>Names to use for the generators. These must be initialized
as arrays later to use the representation properly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HyperbolicRepresentation(projective.ProjectiveRepresentation):
    &#34;&#34;&#34;Model a representation for a finitely generated group
    representation into O(n,1).

    Really this is just a convenient way of mapping words in the
    generators to hyperbolic isometries - there&#39;s no group theory
    being done here at all.

    &#34;&#34;&#34;
    def __getitem__(self, word):
        matrix = self._word_value(word)
        return Isometry(matrix, column_vectors=True)

    def normalize(self, matrix):
        dimension = np.array(matrix).shape[-1]
        return utils.indefinite_orthogonalize(minkowski(dimension), matrix)

    def isometries(self, words):
        &#34;&#34;&#34;Get an Isometry object holding the matrices which are the images of
        a sequence of words in the generators.

        &#34;&#34;&#34;
        return Isometry(self.transformations(words))

    def automaton_accepted(self, automaton, length,
                           maxlen=True, with_words=False,
                           start_state=None, end_state=None,
                           precomputed=None):
        result = projective.ProjectiveRepresentation.automaton_accepted(
            self, automaton, length, maxlen=maxlen, with_words=with_words,
            start_state=start_state, end_state=end_state,
            precomputed=precomputed
        )

        if with_words:
            transformations, words = result
            return (Isometry(transformations), words)

        return Isometry(result)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.ProjectiveRepresentation" href="projective.html#geometry_tools.projective.ProjectiveRepresentation">ProjectiveRepresentation</a></li>
<li><a title="geometry_tools.representation.Representation" href="representation.html#geometry_tools.representation.Representation">Representation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.HyperbolicRepresentation.isometries"><code class="name flex">
<span>def <span class="ident">isometries</span></span>(<span>self, words)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an Isometry object holding the matrices which are the images of
a sequence of words in the generators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isometries(self, words):
    &#34;&#34;&#34;Get an Isometry object holding the matrices which are the images of
    a sequence of words in the generators.

    &#34;&#34;&#34;
    return Isometry(self.transformations(words))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.HyperbolicRepresentation.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self, matrix):
    dimension = np.array(matrix).shape[-1]
    return utils.indefinite_orthogonalize(minkowski(dimension), matrix)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.ProjectiveRepresentation" href="projective.html#geometry_tools.projective.ProjectiveRepresentation">ProjectiveRepresentation</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.automaton_accepted" href="representation.html#geometry_tools.representation.Representation.automaton_accepted">automaton_accepted</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.elements" href="representation.html#geometry_tools.representation.Representation.elements">elements</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.free_words_less_than" href="representation.html#geometry_tools.representation.Representation.free_words_less_than">free_words_less_than</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.free_words_of_length" href="representation.html#geometry_tools.representation.Representation.free_words_of_length">free_words_of_length</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.freely_reduced_elements" href="representation.html#geometry_tools.representation.Representation.freely_reduced_elements">freely_reduced_elements</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.semi_gens" href="representation.html#geometry_tools.representation.Representation.semi_gens">semi_gens</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.symmetric_square" href="representation.html#geometry_tools.representation.Representation.symmetric_square">symmetric_square</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.tensor_product" href="representation.html#geometry_tools.representation.Representation.tensor_product">tensor_product</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.transformations" href="projective.html#geometry_tools.projective.ProjectiveRepresentation.transformations">transformations</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Hyperplane"><code class="flex name class">
<span>class <span class="ident">Hyperplane</span></span>
<span>(</span><span>hyperplane_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a geodesic hyperplane in hyperbolic space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>ndarray</code></dt>
<dd>Data used to construct a subspace (or array of
subspaces). If <code>proj_data</code> is a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>, then
use underlying coordinate data to build an array of
subspaces. If <code>proj_data</code> is an <code>ndarray</code>, then interpret
this as coordinate data for an array of subspaces in the
projective model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hyperplane(Subspace):
    &#34;&#34;&#34;Model for a geodesic hyperplane in hyperbolic space.&#34;&#34;&#34;

    #TODO: reimplement so ideal_basis is aux_data
    def __init__(self, hyperplane_data):
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(hyperplane_data)
            return
        except (TypeError, GeometryError):
            pass

        try:
            self.set(hyperplane_data)
            return
        except GeometryError:
            pass

        self._compute_ideal_basis(hyperplane_data)

    def _assert_geometry_valid(self, proj_data):
        HyperbolicObject._assert_geometry_valid(self, proj_data)

        if (len(proj_data.shape) &lt; 2 or
            proj_data.shape[-2] != proj_data.shape[-1]):
            raise GeometryError( (&#34;Underlying data for hyperplane in H^n must&#34;
                                  &#34; have shape (..., n, n) but data has shape&#34;
                                  &#34; {}&#34;).format(proj_data.shape))


        if not CHECK_LIGHT_CONE:
            return

        if not spacelike(proj_data[..., 0, :]).all():
            raise GeometryError( (&#34;Hyperplane data at index [..., 0, :]&#34;
                                  &#34; must consist of spacelike vectors&#34;) )

        if not lightlike(proj_data[..., 1:, :]).all():
            raise GeometryError( (&#34;Hyperplane data at index [..., 1, :]&#34;
                                  &#34; must consist of lightlike vectors&#34;) )

    def _data_with_dual(self):
        return self.proj_data

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)

        self.spacelike_vector = self.proj_data[..., 0, :]
        self.ideal_basis = self.proj_data[..., 1:, :]

    def _compute_ideal_basis(self, vector):
        spacelike_vector = DualPoint(vector).proj_data
        n = spacelike_vector.shape[-1]
        transform = spacelike_to(spacelike_vector)

        if len(spacelike_vector.shape) &lt; 2:
            spacelike_vector = np.expand_dims(spacelike_vector, axis=0)

        standard_ideal_basis = np.vstack(
            [np.ones((1, n-1)), np.eye(n - 1, n - 1, -1)]
        )
        standard_ideal_basis[n-1, n-2] = -1.


        ideal_basis = transform.apply(standard_ideal_basis.T,
                                      broadcast=&#34;pairwise&#34;).proj_data
        proj_data = np.concatenate([spacelike_vector, ideal_basis],
                                  axis=-2)
        self.set(proj_data)

    @classmethod
    def from_reflection(cls, reflection):
        &#34;&#34;&#34;Construct a hyperplane which is the fixpoint set of a reflection.

        Parameters
        ----------
        reflection : Isometry or ndarray
            The reflection to compute the fixed plane for

        Raises
        ------
        GeometryError :
            If the given isometry is not a reflection.

        Returns
        -------
        Hyperplane
            A `Hyperplane` fixed by the given isometry.
        &#34;&#34;&#34;
        try:
            matrix = reflection.matrix.swapaxes(-1, -2)
        except AttributeError:
            matrix = reflection

        #numpy&#39;s eig expects a matrix operating on the left
        evals, evecs = np.linalg.eig(matrix)

        dimension = reflection.dimension

        #we expect a reflection to have eigenvalues [-1, 1, ...]
        expected_evals = np.ones(dimension + 1)
        expected_evals[0] = -1.
        eval_differences = np.sort(evals, axis=-1) - expected_evals
        if (np.abs(eval_differences) &gt; ERROR_THRESHOLD).any():
            raise GeometryError(&#34;Not a reflection matrix&#34;)

        #sometimes eigenvalues will be complex due to roundoff error
        #so we cast to reals to avoid warnings.
        reflected = np.argmin(np.real(evals), axis=-1)

        spacelike = np.take_along_axis(
            np.real(evecs), np.expand_dims(reflected, axis=(-1,-2)), axis=-1
        )

        return Hyperplane(spacelike.swapaxes(-1,-2))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></li>
<li><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Hyperplane.from_reflection"><code class="name flex">
<span>def <span class="ident">from_reflection</span></span>(<span>reflection)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a hyperplane which is the fixpoint set of a reflection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reflection</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code> or <code>ndarray</code></dt>
<dd>The reflection to compute the fixed plane for</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GeometryError :</code></dt>
<dd>If the given isometry is not a reflection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Hyperplane" href="#geometry_tools.hyperbolic.Hyperplane">Hyperplane</a></code></dt>
<dd>A <code><a title="geometry_tools.hyperbolic.Hyperplane" href="#geometry_tools.hyperbolic.Hyperplane">Hyperplane</a></code> fixed by the given isometry.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_reflection(cls, reflection):
    &#34;&#34;&#34;Construct a hyperplane which is the fixpoint set of a reflection.

    Parameters
    ----------
    reflection : Isometry or ndarray
        The reflection to compute the fixed plane for

    Raises
    ------
    GeometryError :
        If the given isometry is not a reflection.

    Returns
    -------
    Hyperplane
        A `Hyperplane` fixed by the given isometry.
    &#34;&#34;&#34;
    try:
        matrix = reflection.matrix.swapaxes(-1, -2)
    except AttributeError:
        matrix = reflection

    #numpy&#39;s eig expects a matrix operating on the left
    evals, evecs = np.linalg.eig(matrix)

    dimension = reflection.dimension

    #we expect a reflection to have eigenvalues [-1, 1, ...]
    expected_evals = np.ones(dimension + 1)
    expected_evals[0] = -1.
    eval_differences = np.sort(evals, axis=-1) - expected_evals
    if (np.abs(eval_differences) &gt; ERROR_THRESHOLD).any():
        raise GeometryError(&#34;Not a reflection matrix&#34;)

    #sometimes eigenvalues will be complex due to roundoff error
    #so we cast to reals to avoid warnings.
    reflected = np.argmin(np.real(evals), axis=-1)

    spacelike = np.take_along_axis(
        np.real(evecs), np.expand_dims(reflected, axis=(-1,-2)), axis=-1
    )

    return Hyperplane(spacelike.swapaxes(-1,-2))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Subspace.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.ideal_basis_coords" href="#geometry_tools.hyperbolic.Subspace.ideal_basis_coords">ideal_basis_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.reflection_across" href="#geometry_tools.hyperbolic.Subspace.reflection_across">reflection_across</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.spacelike_complement" href="#geometry_tools.hyperbolic.Subspace.spacelike_complement">spacelike_complement</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.sphere_parameters" href="#geometry_tools.hyperbolic.Subspace.sphere_parameters">sphere_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.IdealPoint"><code class="flex name class">
<span>class <span class="ident">IdealPoint</span></span>
<span>(</span><span>point, model=Model.PROJECTIVE)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for an ideal point in hyperbolic space (lying on the boundary
of the projectivization of the Minkowski light cone)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>iterable</code> or <code>ndarray</code></dt>
<dd>Data used to construct a point or an array of points. If
<code>point</code> is a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>, then use the underlying
coordinate data to build an array of points. If <code>point</code> is
an iterable of <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>s, build a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
object out of this array. If <code>point</code> is an <code>ndarray</code>, then
interpret this as coordinate data for an array of points
in some hyperbolic model.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>if <code>point</code> is numerical data, then what model of
hyperbolic space we should use to interpret <code>point</code> as
coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdealPoint(Point):
    &#34;&#34;&#34;Model for an ideal point in hyperbolic space (lying on the boundary
    of the projectivization of the Minkowski light cone)

    &#34;&#34;&#34;
    def _assert_geometry_valid(self, proj_data):
        super()._assert_geometry_valid(proj_data)

        if not CHECK_LIGHT_CONE:
            return

        if not lightlike(proj_data).all():
            raise GeometryError(&#34;Ideal point data must consist of vectors&#34;
                                &#34;in the boundary of the Minkowski light cone&#34;)

    def from_angle(theta):
        #TODO: vectorize and make this work in n dimensions
        return IdealPoint(np.array([1.0, np.cos(theta), np.sin(theta)]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.IdealPoint.from_angle"><code class="name flex">
<span>def <span class="ident">from_angle</span></span>(<span>theta)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_angle(theta):
    #TODO: vectorize and make this work in n dimensions
    return IdealPoint(np.array([1.0, np.cos(theta), np.sin(theta)]))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Point.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry"><code class="flex name class">
<span>class <span class="ident">Isometry</span></span>
<span>(</span><span>proj_data, column_vectors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for an isometry of hyperbolic space.</p>
<p>By default, the underlying data for a projective
transformation is a <em>row matrix</em> (or an ndarray of row
matrices), acting on vectors on the <em>right</em>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ProjectiveObject</code> or <code>ndarray</code></dt>
<dd>Data to use to construct a projective transformation (or
array of projective transformations).</dd>
<dt><strong><code>column_vectors</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, interpret proj_data as a <em>column matrix</em> acting
on the left. Otherwise proj_data gives a <em>row matrix</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Isometry(projective.Transformation, HyperbolicObject):
    &#34;&#34;&#34;Model for an isometry of hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, proj_data, column_vectors=False):
        projective.Transformation.__init__(self, proj_data, column_vectors)

    def _fixpoint_data(self, sort_eigvals=True):

        # find fixpoints in projective space, and their eigenvalues and minkowski norms

        eigvals, eigvecs = np.linalg.eig(self.proj_data.swapaxes(-1, -2))
        norms = utils.normsq(eigvecs.swapaxes(-1, -2),  self.minkowski)

        # 1 for eigenvectors which actually lie in H^n, 0 for outside vectors
        in_plane = np.where(norms &gt; ERROR_THRESHOLD, 0, 1)

        # primary sort key is whether or not we&#39;re in the plane,
        # secondary is the eigenvalue modulus
        if sort_eigvals:
            sort_order = np.stack([np.abs(eigvals),
                                   -1 * np.abs(np.imag(eigvals)),
                                   in_plane])
            sort_indices = np.lexsort(sort_order, axis=-1)
            sort_indices = np.expand_dims(sort_indices, axis=-2)
        else:
            sort_indices = np.argsort(in_plane, axis=-1)

        # we want a descending sort to put maximum modulus eigenvalues first
        sort_indices = np.flip(sort_indices, axis=-1)

        pt_data = np.take_along_axis(eigvecs, sort_indices, axis=-1).swapaxes(-1, -2)

        return pt_data

    def _data_to_object(self, data):
        return HyperbolicObject(data)

    def axis(self):
        return Geodesic(self.fixed_point_pair())

    def isometry_type(self):
        fixpoint_data = self._fixpoint_data(sort_eigvals=True)
        fixpoint

    def fixed_point_pair(self, sort_eigvals=True):
        &#34;&#34;&#34;Find fixed points for this isometry in the closure of hyperbolic space.

        Parameters
        ----------
        sort_eigvals : bool
            If `True`, guarantee that the fixpoints are ordered in
            order of descending eigenvalue moduli

        Returns
        -------
        Point
            Points fixed by this isometry object.

        &#34;&#34;&#34;
        fixpoint_data = np.real(self._fixpoint_data(sort_eigvals))
        return PointPair(fixpoint_data[..., :2, :])

    def fixed_point(self, max_eigval=True):
        &#34;&#34;&#34;Find a fixed point for this isometry in the closure of hyperbolic
           space.

        Parameters
        ----------
        max_eigval : bool
            If `True`, guarantee that the eigenvalue for this fixed
            point has maximum modulus

        Returns
        -------
        Point
            A point (possibly ideal) fixed by this isometry object.

        &#34;&#34;&#34;
        fixpoint_data = np.real(self._fixpoint_data(max_eigval))
        return Point(fixpoint_data[..., 0, :])


    def elliptic(dimension, block_elliptic, column_vectors=True):
        &#34;&#34;&#34;Get an elliptic isometry stabilizing the origin in the
        Poincare/Klein models.

        block_elliptic is an element of O(n), whose image is taken
        diagonally in O(n,1).

        &#34;&#34;&#34;
        mat = np.zeros((dimension + 1, dimension + 1))
        mat[0,0] = 1.0
        mat[1:, 1:] = block_elliptic

        return Isometry(mat, column_vectors=column_vectors)

    def standard_loxodromic(dimension, parameter):
        &#34;&#34;&#34;Get a loxodromic isometry whose axis intersects the origin.

        WARNING: not vectorized.

        &#34;&#34;&#34;
        basis_change = _loxodromic_basis_change(dimension)
        diagonal_loxodromic = np.diag(
            np.concatenate(([parameter, 1.0/parameter],
                       np.ones(dimension - 1)))
        )

        return Isometry((basis_change @ diagonal_loxodromic @
                        np.linalg.inv(basis_change)),
                        column_vectors=True)

    def standard_rotation(angle, dimension=2):
        &#34;&#34;&#34;Get a rotation about the origin by a fixed angle.

        WARNING: not vectorized.
        &#34;&#34;&#34;
        affine = np.identity(dimension)
        affine[0:2, 0:2] = utils.rotation_matrix(angle)

        return Isometry.elliptic(dimension, affine)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.Transformation" href="projective.html#geometry_tools.projective.Transformation">Transformation</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Isometry.axis"><code class="name flex">
<span>def <span class="ident">axis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axis(self):
    return Geodesic(self.fixed_point_pair())</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry.elliptic"><code class="name flex">
<span>def <span class="ident">elliptic</span></span>(<span>dimension, block_elliptic, column_vectors=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an elliptic isometry stabilizing the origin in the
Poincare/Klein models.</p>
<p>block_elliptic is an element of O(n), whose image is taken
diagonally in O(n,1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elliptic(dimension, block_elliptic, column_vectors=True):
    &#34;&#34;&#34;Get an elliptic isometry stabilizing the origin in the
    Poincare/Klein models.

    block_elliptic is an element of O(n), whose image is taken
    diagonally in O(n,1).

    &#34;&#34;&#34;
    mat = np.zeros((dimension + 1, dimension + 1))
    mat[0,0] = 1.0
    mat[1:, 1:] = block_elliptic

    return Isometry(mat, column_vectors=column_vectors)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry.fixed_point"><code class="name flex">
<span>def <span class="ident">fixed_point</span></span>(<span>self, max_eigval=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a fixed point for this isometry in the closure of hyperbolic
space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_eigval</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, guarantee that the eigenvalue for this fixed
point has maximum modulus</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>A point (possibly ideal) fixed by this isometry object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_point(self, max_eigval=True):
    &#34;&#34;&#34;Find a fixed point for this isometry in the closure of hyperbolic
       space.

    Parameters
    ----------
    max_eigval : bool
        If `True`, guarantee that the eigenvalue for this fixed
        point has maximum modulus

    Returns
    -------
    Point
        A point (possibly ideal) fixed by this isometry object.

    &#34;&#34;&#34;
    fixpoint_data = np.real(self._fixpoint_data(max_eigval))
    return Point(fixpoint_data[..., 0, :])</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry.fixed_point_pair"><code class="name flex">
<span>def <span class="ident">fixed_point_pair</span></span>(<span>self, sort_eigvals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Find fixed points for this isometry in the closure of hyperbolic space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sort_eigvals</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, guarantee that the fixpoints are ordered in
order of descending eigenvalue moduli</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>Points fixed by this isometry object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixed_point_pair(self, sort_eigvals=True):
    &#34;&#34;&#34;Find fixed points for this isometry in the closure of hyperbolic space.

    Parameters
    ----------
    sort_eigvals : bool
        If `True`, guarantee that the fixpoints are ordered in
        order of descending eigenvalue moduli

    Returns
    -------
    Point
        Points fixed by this isometry object.

    &#34;&#34;&#34;
    fixpoint_data = np.real(self._fixpoint_data(sort_eigvals))
    return PointPair(fixpoint_data[..., :2, :])</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry.isometry_type"><code class="name flex">
<span>def <span class="ident">isometry_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isometry_type(self):
    fixpoint_data = self._fixpoint_data(sort_eigvals=True)
    fixpoint</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry.standard_loxodromic"><code class="name flex">
<span>def <span class="ident">standard_loxodromic</span></span>(<span>dimension, parameter)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a loxodromic isometry whose axis intersects the origin.</p>
<p>WARNING: not vectorized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standard_loxodromic(dimension, parameter):
    &#34;&#34;&#34;Get a loxodromic isometry whose axis intersects the origin.

    WARNING: not vectorized.

    &#34;&#34;&#34;
    basis_change = _loxodromic_basis_change(dimension)
    diagonal_loxodromic = np.diag(
        np.concatenate(([parameter, 1.0/parameter],
                   np.ones(dimension - 1)))
    )

    return Isometry((basis_change @ diagonal_loxodromic @
                    np.linalg.inv(basis_change)),
                    column_vectors=True)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Isometry.standard_rotation"><code class="name flex">
<span>def <span class="ident">standard_rotation</span></span>(<span>angle, dimension=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a rotation about the origin by a fixed angle.</p>
<p>WARNING: not vectorized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def standard_rotation(angle, dimension=2):
    &#34;&#34;&#34;Get a rotation about the origin by a fixed angle.

    WARNING: not vectorized.
    &#34;&#34;&#34;
    affine = np.identity(dimension)
    affine[0:2, 0:2] = utils.rotation_matrix(angle)

    return Isometry.elliptic(dimension, affine)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.Transformation" href="projective.html#geometry_tools.projective.Transformation">Transformation</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.Transformation.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.apply" href="projective.html#geometry_tools.projective.Transformation.apply">apply</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.inv" href="projective.html#geometry_tools.projective.Transformation.inv">inv</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
<li><code><b><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.coords" href="#geometry_tools.hyperbolic.HyperbolicObject.coords">coords</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enumerate implemented models of hyperbolic space.</p>
<p>Models can have different aliases, and can be compared to strings
with the == operator, which returns <code>True</code> if the strings match
any alias name (case insensitive).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model(Enum):
    &#34;&#34;&#34;Enumerate implemented models of hyperbolic space.

    Models can have different aliases, and can be compared to strings
    with the == operator, which returns `True` if the strings match
    any alias name (case insensitive).

    &#34;&#34;&#34;
    POINCARE = &#34;poincare&#34;
    KLEIN = &#34;klein&#34;
    KLEINIAN = &#34;klein&#34;
    AFFINE = &#34;klein&#34;
    HALFSPACE = &#34;halfspace&#34;
    HALFPLANE = &#34;halfspace&#34;
    HYPERBOLOID = &#34;hyperboloid&#34;
    PROJECTIVE = &#34;projective&#34;

    def aliases(self):
        &#34;&#34;&#34;List all of the different accepted names for this hyperbolic model.&#34;&#34;&#34;
        return [name for name, member in Model.__members__.items()
                if member is self]

    def __eq__(self, other):
        if self is other:
            return True

        try:
            if other.upper() in self.aliases():
                return True
        except AttributeError:
            pass

        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Model.AFFINE"><code class="name">var <span class="ident">AFFINE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.HALFPLANE"><code class="name">var <span class="ident">HALFPLANE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.HALFSPACE"><code class="name">var <span class="ident">HALFSPACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.HYPERBOLOID"><code class="name">var <span class="ident">HYPERBOLOID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.KLEIN"><code class="name">var <span class="ident">KLEIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.KLEINIAN"><code class="name">var <span class="ident">KLEINIAN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.POINCARE"><code class="name">var <span class="ident">POINCARE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geometry_tools.hyperbolic.Model.PROJECTIVE"><code class="name">var <span class="ident">PROJECTIVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Model.aliases"><code class="name flex">
<span>def <span class="ident">aliases</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List all of the different accepted names for this hyperbolic model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aliases(self):
    &#34;&#34;&#34;List all of the different accepted names for this hyperbolic model.&#34;&#34;&#34;
    return [name for name, member in Model.__members__.items()
            if member is self]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geometry_tools.hyperbolic.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>point, model=Model.PROJECTIVE)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a point (or ndarray of points) in the closure of
hyperbolic space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>iterable</code> or <code>ndarray</code></dt>
<dd>Data used to construct a point or an array of points. If
<code>point</code> is a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>, then use the underlying
coordinate data to build an array of points. If <code>point</code> is
an iterable of <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>s, build a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
object out of this array. If <code>point</code> is an <code>ndarray</code>, then
interpret this as coordinate data for an array of points
in some hyperbolic model.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>if <code>point</code> is numerical data, then what model of
hyperbolic space we should use to interpret <code>point</code> as
coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(HyperbolicObject, projective.Point):
    &#34;&#34;&#34;Model for a point (or ndarray of points) in the closure of
    hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, point, model=Model.PROJECTIVE):
        &#34;&#34;&#34;

        Parameters
        ----------
        point : HyperbolicObject or iterable or ndarray
            Data used to construct a point or an array of points. If
            `point` is a `HyperbolicObject`, then use the underlying
            coordinate data to build an array of points. If `point` is
            an iterable of `HyperbolicObject`s, build a composite `Point`
            object out of this array. If `point` is an `ndarray`, then
            interpret this as coordinate data for an array of points
            in some hyperbolic model.
        model : Model
            if `point` is numerical data, then what model of
            hyperbolic space we should use to interpret `point` as
            coordinates.

        &#34;&#34;&#34;
        self.unit_ndims = 1
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(point)
            return
        except TypeError:
            pass

        self.coords(model, point)

    def hyperboloid_coords(self, proj_data=None):
        &#34;&#34;&#34;Get or set point coordinates in the hyperboloid model.

        Parameters
        ----------
        proj_data : ndarray
            Data to set coordinates to, in the hyperboloid
            model. The last dimension of the array is the
            dimension of the vector space R^(n,1). If `None`, do not
            update coordinates.

        Returns
        -------
        ndarray
            Hyperboloid coordinates for this point (or array of
            points).

        &#34;&#34;&#34;
        if proj_data is not None:
            self.set(proj_data)

        return hyperboloid_coords(self.proj_data)

    def poincare_coords(self, proj_data=None):
        &#34;&#34;&#34;Get or set point coordinates in the hyperboloid model.

        Parameters
        ----------
        proj_data : ndarray
            Data to set coordinates to, as points in projective space.
            The last dimension of the array is the dimension of the
            vector space R^(n,1). If `None`, do not update
            coordinates.

        Returns
        -------
        ndarray
            Projective coordinates for this point (or array of
            points).

        &#34;&#34;&#34;
        if proj_data is not None:
            klein = poincare_to_kleinian(np.array(proj_data))
            self.kleinian_coords(klein)

        return kleinian_to_poincare(self.kleinian_coords())

    def halfspace_coords(self, proj_data=None):
        &#34;&#34;&#34;Get or set point coordinates in the half-space model.

        Parameters
        ----------
        proj_data : ndarray
            Data to set coordinates to, as points in half-space.  The
            last dimension of the array is the dimension of hyperbolic
            space H^n. If `None`, do not update coordinates.

        Returns
        -------
        ndarray
            Half-space coordinates for this point (or array of
            points).

        &#34;&#34;&#34;
        poincare = None

        if proj_data is not None:
            poincare = halfspace_to_poincare(np.array(proj_data))

        poincare_coords = self.poincare_coords(poincare)
        return poincare_to_halfspace(poincare_coords)

    def coords(self, model, proj_data=None):
        &#34;&#34;&#34;Get or set a representation of this hyperbolic object in
        coordinates.

        The available models are `Model.KLEIN`, `Model.PROJECTIVE`,
        `Model.POINCARE`, `Model.HYPERBOLOID`, and `Model.HALFSPACE`.

        Parameters
        ----------
        model : Model
            which model to take coordinates in
        proj_data : ndarray
            data for this hyperbolic object, interpreted as
            coordinates with respect to `model`. If `None`, just
            return coordinates.

        Raises
        ------
        GeometryError
            Raised if an unsupported model is specified.

        &#34;&#34;&#34;
        try:
            return HyperbolicObject.coords(self, model, proj_data)
        except GeometryError as e:
            if model == Model.POINCARE:
                return self.poincare_coords(proj_data)
            if model == Model.HYPERBOLOID:
                return self.hyperboloid_coords(proj_data)
            if model == Model.HALFSPACE:
                return self.halfspace_coords(proj_data)
            raise e

    def distance(self, other):
        &#34;&#34;&#34;Compute hyperbolic distances between pairs of points, or pairs of
            arrays of points.

        Parameters
        ----------
        other : Point
            The point to compute distances to

        Returns
        -------
        ndarray
            distances in hyperbolic space between self and other

        &#34;&#34;&#34;
        #TODO: allow for pairwise distances
        products = utils.apply_bilinear(self.proj_data, other.proj_data,
                                        self.minkowski)

        return np.arccosh(np.abs(products))

    def origin_to(self):
        &#34;&#34;&#34;Get an isometry taking an &#34;origin&#34; point to this point

        Returns
        -------
        Isometry :
            Some isometry taking the point with Kleinian/Poincare
            coordinates (0, 0, ...) to this point. This isometry is
            not uniquely determined and is not guaranteed to be
            orientation-preserving.

        &#34;&#34;&#34;
        return timelike_to(self.proj_data)

    def unit_tangent_towards(self, other):
        &#34;&#34;&#34;Get a unit tangent vector with this basepoint, pointing at another point

        Parameters
        ----------
        other : Point
            another point in hyperbolic space where the unit tangent
            vector points

        Returns
        -------
        TangentVector
            A tangent vector with this point at its base and pointing
            towards `other`.

        &#34;&#34;&#34;
        diff = other.proj_data - self.proj_data
        return TangentVector(self, diff).normalized()

    def get_origin(dimension, shape=()):
        &#34;&#34;&#34;Get a point (or ndarray of points) at the &#34;origin&#34; of hyperbolic
           space

        Parameters
        ----------
        dimension : int
            Dimension of hyperbolic space where this point lives
        shape : tuple(int)
            Shape of array of origin points to get

        Returns
        -------
        Point
            Point object with Kleinian/Poincare coords (0, 0, ...)
        &#34;&#34;&#34;

        return Point(np.zeros(shape + (dimension,)), model=&#34;klein&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.DualPoint" href="#geometry_tools.hyperbolic.DualPoint">DualPoint</a></li>
<li><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></li>
<li><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></li>
<li><a title="geometry_tools.hyperbolic.Polygon" href="#geometry_tools.hyperbolic.Polygon">Polygon</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Point.coords"><code class="name flex">
<span>def <span class="ident">coords</span></span>(<span>self, model, proj_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set a representation of this hyperbolic object in
coordinates.</p>
<p>The available models are <code><a title="geometry_tools.hyperbolic.Model.KLEIN" href="#geometry_tools.hyperbolic.Model.KLEIN">Model.KLEIN</a></code>, <code><a title="geometry_tools.hyperbolic.Model.PROJECTIVE" href="#geometry_tools.hyperbolic.Model.PROJECTIVE">Model.PROJECTIVE</a></code>,
<code><a title="geometry_tools.hyperbolic.Model.POINCARE" href="#geometry_tools.hyperbolic.Model.POINCARE">Model.POINCARE</a></code>, <code><a title="geometry_tools.hyperbolic.Model.HYPERBOLOID" href="#geometry_tools.hyperbolic.Model.HYPERBOLOID">Model.HYPERBOLOID</a></code>, and <code><a title="geometry_tools.hyperbolic.Model.HALFSPACE" href="#geometry_tools.hyperbolic.Model.HALFSPACE">Model.HALFSPACE</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>which model to take coordinates in</dd>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>data for this hyperbolic object, interpreted as
coordinates with respect to <code>model</code>. If <code>None</code>, just
return coordinates.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GeometryError</code></dt>
<dd>Raised if an unsupported model is specified.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords(self, model, proj_data=None):
    &#34;&#34;&#34;Get or set a representation of this hyperbolic object in
    coordinates.

    The available models are `Model.KLEIN`, `Model.PROJECTIVE`,
    `Model.POINCARE`, `Model.HYPERBOLOID`, and `Model.HALFSPACE`.

    Parameters
    ----------
    model : Model
        which model to take coordinates in
    proj_data : ndarray
        data for this hyperbolic object, interpreted as
        coordinates with respect to `model`. If `None`, just
        return coordinates.

    Raises
    ------
    GeometryError
        Raised if an unsupported model is specified.

    &#34;&#34;&#34;
    try:
        return HyperbolicObject.coords(self, model, proj_data)
    except GeometryError as e:
        if model == Model.POINCARE:
            return self.poincare_coords(proj_data)
        if model == Model.HYPERBOLOID:
            return self.hyperboloid_coords(proj_data)
        if model == Model.HALFSPACE:
            return self.halfspace_coords(proj_data)
        raise e</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute hyperbolic distances between pairs of points, or pairs of
arrays of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>The point to compute distances to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>distances in hyperbolic space between self and other</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, other):
    &#34;&#34;&#34;Compute hyperbolic distances between pairs of points, or pairs of
        arrays of points.

    Parameters
    ----------
    other : Point
        The point to compute distances to

    Returns
    -------
    ndarray
        distances in hyperbolic space between self and other

    &#34;&#34;&#34;
    #TODO: allow for pairwise distances
    products = utils.apply_bilinear(self.proj_data, other.proj_data,
                                    self.minkowski)

    return np.arccosh(np.abs(products))</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.get_origin"><code class="name flex">
<span>def <span class="ident">get_origin</span></span>(<span>dimension, shape=())</span>
</code></dt>
<dd>
<div class="desc"><p>Get a point (or ndarray of points) at the "origin" of hyperbolic
space</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dimension</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of hyperbolic space where this point lives</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple(int)</code></dt>
<dd>Shape of array of origin points to get</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>Point object with Kleinian/Poincare coords (0, 0, &hellip;)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_origin(dimension, shape=()):
    &#34;&#34;&#34;Get a point (or ndarray of points) at the &#34;origin&#34; of hyperbolic
       space

    Parameters
    ----------
    dimension : int
        Dimension of hyperbolic space where this point lives
    shape : tuple(int)
        Shape of array of origin points to get

    Returns
    -------
    Point
        Point object with Kleinian/Poincare coords (0, 0, ...)
    &#34;&#34;&#34;

    return Point(np.zeros(shape + (dimension,)), model=&#34;klein&#34;)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.halfspace_coords"><code class="name flex">
<span>def <span class="ident">halfspace_coords</span></span>(<span>self, proj_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set point coordinates in the half-space model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Data to set coordinates to, as points in half-space.
The
last dimension of the array is the dimension of hyperbolic
space H^n. If <code>None</code>, do not update coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Half-space coordinates for this point (or array of
points).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def halfspace_coords(self, proj_data=None):
    &#34;&#34;&#34;Get or set point coordinates in the half-space model.

    Parameters
    ----------
    proj_data : ndarray
        Data to set coordinates to, as points in half-space.  The
        last dimension of the array is the dimension of hyperbolic
        space H^n. If `None`, do not update coordinates.

    Returns
    -------
    ndarray
        Half-space coordinates for this point (or array of
        points).

    &#34;&#34;&#34;
    poincare = None

    if proj_data is not None:
        poincare = halfspace_to_poincare(np.array(proj_data))

    poincare_coords = self.poincare_coords(poincare)
    return poincare_to_halfspace(poincare_coords)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.hyperboloid_coords"><code class="name flex">
<span>def <span class="ident">hyperboloid_coords</span></span>(<span>self, proj_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set point coordinates in the hyperboloid model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Data to set coordinates to, in the hyperboloid
model. The last dimension of the array is the
dimension of the vector space R^(n,1). If <code>None</code>, do not
update coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Hyperboloid coordinates for this point (or array of
points).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperboloid_coords(self, proj_data=None):
    &#34;&#34;&#34;Get or set point coordinates in the hyperboloid model.

    Parameters
    ----------
    proj_data : ndarray
        Data to set coordinates to, in the hyperboloid
        model. The last dimension of the array is the
        dimension of the vector space R^(n,1). If `None`, do not
        update coordinates.

    Returns
    -------
    ndarray
        Hyperboloid coordinates for this point (or array of
        points).

    &#34;&#34;&#34;
    if proj_data is not None:
        self.set(proj_data)

    return hyperboloid_coords(self.proj_data)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.origin_to"><code class="name flex">
<span>def <span class="ident">origin_to</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an isometry taking an "origin" point to this point</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Isometry :</code></dt>
<dd>Some isometry taking the point with Kleinian/Poincare
coordinates (0, 0, &hellip;) to this point. This isometry is
not uniquely determined and is not guaranteed to be
orientation-preserving.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def origin_to(self):
    &#34;&#34;&#34;Get an isometry taking an &#34;origin&#34; point to this point

    Returns
    -------
    Isometry :
        Some isometry taking the point with Kleinian/Poincare
        coordinates (0, 0, ...) to this point. This isometry is
        not uniquely determined and is not guaranteed to be
        orientation-preserving.

    &#34;&#34;&#34;
    return timelike_to(self.proj_data)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.poincare_coords"><code class="name flex">
<span>def <span class="ident">poincare_coords</span></span>(<span>self, proj_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set point coordinates in the hyperboloid model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Data to set coordinates to, as points in projective space.
The last dimension of the array is the dimension of the
vector space R^(n,1). If <code>None</code>, do not update
coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Projective coordinates for this point (or array of
points).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poincare_coords(self, proj_data=None):
    &#34;&#34;&#34;Get or set point coordinates in the hyperboloid model.

    Parameters
    ----------
    proj_data : ndarray
        Data to set coordinates to, as points in projective space.
        The last dimension of the array is the dimension of the
        vector space R^(n,1). If `None`, do not update
        coordinates.

    Returns
    -------
    ndarray
        Projective coordinates for this point (or array of
        points).

    &#34;&#34;&#34;
    if proj_data is not None:
        klein = poincare_to_kleinian(np.array(proj_data))
        self.kleinian_coords(klein)

    return kleinian_to_poincare(self.kleinian_coords())</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Point.unit_tangent_towards"><code class="name flex">
<span>def <span class="ident">unit_tangent_towards</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a unit tangent vector with this basepoint, pointing at another point</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>another point in hyperbolic space where the unit tangent
vector points</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></code></dt>
<dd>A tangent vector with this point at its base and pointing
towards <code>other</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_tangent_towards(self, other):
    &#34;&#34;&#34;Get a unit tangent vector with this basepoint, pointing at another point

    Parameters
    ----------
    other : Point
        another point in hyperbolic space where the unit tangent
        vector points

    Returns
    -------
    TangentVector
        A tangent vector with this point at its base and pointing
        towards `other`.

    &#34;&#34;&#34;
    diff = other.proj_data - self.proj_data
    return TangentVector(self, diff).normalized()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.PointPair"><code class="flex name class">
<span>class <span class="ident">PointPair</span></span>
<span>(</span><span>endpoint1, endpoint2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract model for a hyperbolic object whose underlying data is
determined by a pair of points in R^(n,1)</p>
<p>If <code>endpoint2</code> is <code>None</code>, interpret <code>endpoint1</code> as either a (2
x&hellip;x n) <code>ndarray</code> (where n is the dimension of the underlying
vector space), or else a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> object which can be
unpacked into two Points (which may themselves be composite).</p>
<p>If <code>endpoint2</code> is given, then both <code>endpoint1</code> and <code>endpoint2</code>
can be used to construct <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> objects, which serve as the
endpoints for this pair of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>endpoint1</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>One (or both) endpoints of the point pair</dd>
<dt><strong><code>endpoint2</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The other endpoint of the point pair. If <code>None</code>,
<code>endpoint1</code> contains the data for both points in the pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointPair(Point, projective.PointPair):
    &#34;&#34;&#34;Abstract model for a hyperbolic object whose underlying data is
    determined by a pair of points in R^(n,1)

    &#34;&#34;&#34;
    def __init__(self, endpoint1, endpoint2=None):
        &#34;&#34;&#34;If `endpoint2` is `None`, interpret `endpoint1` as either a (2
        x...x n) `ndarray` (where n is the dimension of the underlying
        vector space), or else a composite `Point` object which can be
        unpacked into two Points (which may themselves be composite).

        If `endpoint2` is given, then both `endpoint1` and `endpoint2`
        can be used to construct `Point` objects, which serve as the
        endpoints for this pair of points.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

        &#34;&#34;&#34;

        projective.PointPair.__init__(self, endpoint1, endpoint2)

    def endpoint_coords(self, model=Model.KLEIN):
        &#34;&#34;&#34;Get coordinates for the endpoints of this point pair

        Parameters
        ----------
        model : Model
            model to compute coordinates in

        Returns
        -------
        ndarray
            Coordinates for the endpoints of this PointPair, as an
            ndarray with shape `(2, ... n)` (where `n` is the
            dimension of the hyperbolic space).

        &#34;&#34;&#34;
        return self.get_endpoints().coords(model)

    def get_endpoints(self):
        &#34;&#34;&#34;Convert this pair of points to a composite `Point` object

        Returns
        -------
        Point
            Composite `Point` object with the same underlying data as
            this point pair.

        &#34;&#34;&#34;
        return Point(self.endpoints)

    def get_end_pair(self, as_points=False):
        &#34;&#34;&#34;Get a pair of `Point` objects, one for each endpoint of this PointPair

        Parameters
        ----------
        as_points : bool
            If `True`, return a pair of `Point` objects. Otherwise,
            return a pair of `ndarray`s with projective coordinates
            for these points.

        Returns
        -------
        tuple
            A tuple `(p1, p2)`, where `p1` and `p2` are either both
            `Point`s or both `ndarrays`, representing the endpoints of
            this pair.

    &#34;&#34;&#34;
        if as_points:
            p1, p2 = self.get_end_pair(as_points=False)
            return (Point(p1), Point(p2))

        return (self.endpoints[..., 0, :], self.endpoints[..., 1, :])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.PointPair" href="projective.html#geometry_tools.projective.PointPair">PointPair</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></li>
<li><a title="geometry_tools.hyperbolic.HorosphereArc" href="#geometry_tools.hyperbolic.HorosphereArc">HorosphereArc</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.PointPair.endpoint_coords"><code class="name flex">
<span>def <span class="ident">endpoint_coords</span></span>(<span>self, model=Model.KLEIN)</span>
</code></dt>
<dd>
<div class="desc"><p>Get coordinates for the endpoints of this point pair</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>model to compute coordinates in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Coordinates for the endpoints of this PointPair, as an
ndarray with shape <code>(2, &hellip; n)</code> (where <code>n</code> is the
dimension of the hyperbolic space).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endpoint_coords(self, model=Model.KLEIN):
    &#34;&#34;&#34;Get coordinates for the endpoints of this point pair

    Parameters
    ----------
    model : Model
        model to compute coordinates in

    Returns
    -------
    ndarray
        Coordinates for the endpoints of this PointPair, as an
        ndarray with shape `(2, ... n)` (where `n` is the
        dimension of the hyperbolic space).

    &#34;&#34;&#34;
    return self.get_endpoints().coords(model)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.PointPair.get_end_pair"><code class="name flex">
<span>def <span class="ident">get_end_pair</span></span>(<span>self, as_points=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a pair of <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> objects, one for each endpoint of this PointPair</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>as_points</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, return a pair of <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> objects. Otherwise,
return a pair of <code>ndarray</code>s with projective coordinates
for these points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple <code>(p1, p2)</code>, where <code>p1</code> and <code>p2</code> are either both
<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>s or both <code>ndarrays</code>, representing the endpoints of
this pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_pair(self, as_points=False):
    &#34;&#34;&#34;Get a pair of `Point` objects, one for each endpoint of this PointPair

    Parameters
    ----------
    as_points : bool
        If `True`, return a pair of `Point` objects. Otherwise,
        return a pair of `ndarray`s with projective coordinates
        for these points.

    Returns
    -------
    tuple
        A tuple `(p1, p2)`, where `p1` and `p2` are either both
        `Point`s or both `ndarrays`, representing the endpoints of
        this pair.

&#34;&#34;&#34;
    if as_points:
        p1, p2 = self.get_end_pair(as_points=False)
        return (Point(p1), Point(p2))

    return (self.endpoints[..., 0, :], self.endpoints[..., 1, :])</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.PointPair.get_endpoints"><code class="name flex">
<span>def <span class="ident">get_endpoints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert this pair of points to a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>Composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> object with the same underlying data as
this point pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_endpoints(self):
    &#34;&#34;&#34;Convert this pair of points to a composite `Point` object

    Returns
    -------
    Point
        Composite `Point` object with the same underlying data as
        this point pair.

    &#34;&#34;&#34;
    return Point(self.endpoints)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Point.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
<li><code><b><a title="geometry_tools.projective.PointPair" href="projective.html#geometry_tools.projective.PointPair">PointPair</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.PointPair.endpoint_affine_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_affine_coords">endpoint_affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.PointPair.endpoint_projective_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_projective_coords">endpoint_projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.PointPair.set_endpoints" href="projective.html#geometry_tools.projective.PointPair.set_endpoints">set_endpoints</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Polygon"><code class="flex name class">
<span>class <span class="ident">Polygon</span></span>
<span>(</span><span>vertices, aux_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a geodesic polygon in hyperbolic space.</p>
<p>Underlying data consists of the vertices of the polygon. We also
keep track of auxiliary data, namely the proj_data of the segments
making up the edges of the polygon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>iterable</code> or <code>ndarray</code></dt>
<dd>Data used to construct a point or an array of points. If
<code>point</code> is a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>, then use the underlying
coordinate data to build an array of points. If <code>point</code> is
an iterable of <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>s, build a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code>
object out of this array. If <code>point</code> is an <code>ndarray</code>, then
interpret this as coordinate data for an array of points
in some hyperbolic model.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>if <code>point</code> is numerical data, then what model of
hyperbolic space we should use to interpret <code>point</code> as
coordinates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polygon(Point, projective.Polygon):
    &#34;&#34;&#34;Model for a geodesic polygon in hyperbolic space.

    Underlying data consists of the vertices of the polygon. We also
    keep track of auxiliary data, namely the proj_data of the segments
    making up the edges of the polygon.
    &#34;&#34;&#34;
    def __init__(self, vertices, aux_data=None):
        self.segment_class = Segment
        HyperbolicObject.__init__(self, vertices, aux_data,
                                  unit_ndims=2, aux_ndims=3)

    def _compute_aux_data(self, proj_data):
        segments = Segment(proj_data, np.roll(proj_data, -1, axis=-2))
        return segments.proj_data

    def get_vertices(self):
        return Point(self.proj_data)

    def get_edges(self):
        return Segment(self.edges)

    def circle_parameters(self, short_arc=True, degrees=True,
                          model=Model.POINCARE, flatten=False):
        if not flatten:
            return self.get_edges().circle_parameters(short_arc, degrees, model)

        flat_segments = self.get_edges().flatten_to_unit()
        return flat_segments.circle_parameters(short_arc, degrees, model)

    def regular_polygon(n, radius=None, angle=None, dimension=2):
        &#34;&#34;&#34;Get a regular polygon with n vertices, inscribed on a circle of
        radius hyp_radius.

        (This is actually vectorized.)

        &#34;&#34;&#34;
        if radius is None and angle is None:
            raise ValueError(
                &#34;Must provide either an angle or a radius to regular_polygon&#34;
            )

        if radius is None:
            radius = regular_polygon_radius(n, angle)

        hyp_radius = np.array(radius)
        tangent = TangentVector.get_base_tangent(dimension,
                                                 hyp_radius.shape).normalized()
        start_vertex = tangent.point_along(hyp_radius)

        cyclic_rep = HyperbolicRepresentation()
        cyclic_rep[&#34;a&#34;] = Isometry.standard_rotation(2 * np.pi / n, dimension=dimension)

        words = [&#34;a&#34; * i for i in range(n)]
        mats = cyclic_rep.isometries(words)

        vertices = mats.apply(start_vertex, &#34;pairwise_reversed&#34;)
        return Polygon(vertices)

    def regular_surface_polygon(g, dimension=2):
        &#34;&#34;&#34;Get a regular polygon which is the fundamental domain for the
        action of a hyperbolic surface group with genus g.

        &#34;&#34;&#34;
        return Polygon.regular_polygon(4 * g, radius=genus_g_surface_radius(g),
                                       dimension=dimension)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Polygon" href="projective.html#geometry_tools.projective.Polygon">Polygon</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Polygon.circle_parameters"><code class="name flex">
<span>def <span class="ident">circle_parameters</span></span>(<span>self, short_arc=True, degrees=True, model=Model.POINCARE, flatten=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_parameters(self, short_arc=True, degrees=True,
                      model=Model.POINCARE, flatten=False):
    if not flatten:
        return self.get_edges().circle_parameters(short_arc, degrees, model)

    flat_segments = self.get_edges().flatten_to_unit()
    return flat_segments.circle_parameters(short_arc, degrees, model)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Polygon.regular_polygon"><code class="name flex">
<span>def <span class="ident">regular_polygon</span></span>(<span>n, radius=None, angle=None, dimension=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a regular polygon with n vertices, inscribed on a circle of
radius hyp_radius.</p>
<p>(This is actually vectorized.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_polygon(n, radius=None, angle=None, dimension=2):
    &#34;&#34;&#34;Get a regular polygon with n vertices, inscribed on a circle of
    radius hyp_radius.

    (This is actually vectorized.)

    &#34;&#34;&#34;
    if radius is None and angle is None:
        raise ValueError(
            &#34;Must provide either an angle or a radius to regular_polygon&#34;
        )

    if radius is None:
        radius = regular_polygon_radius(n, angle)

    hyp_radius = np.array(radius)
    tangent = TangentVector.get_base_tangent(dimension,
                                             hyp_radius.shape).normalized()
    start_vertex = tangent.point_along(hyp_radius)

    cyclic_rep = HyperbolicRepresentation()
    cyclic_rep[&#34;a&#34;] = Isometry.standard_rotation(2 * np.pi / n, dimension=dimension)

    words = [&#34;a&#34; * i for i in range(n)]
    mats = cyclic_rep.isometries(words)

    vertices = mats.apply(start_vertex, &#34;pairwise_reversed&#34;)
    return Polygon(vertices)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Polygon.regular_surface_polygon"><code class="name flex">
<span>def <span class="ident">regular_surface_polygon</span></span>(<span>g, dimension=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a regular polygon which is the fundamental domain for the
action of a hyperbolic surface group with genus g.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regular_surface_polygon(g, dimension=2):
    &#34;&#34;&#34;Get a regular polygon which is the fundamental domain for the
    action of a hyperbolic surface group with genus g.

    &#34;&#34;&#34;
    return Polygon.regular_polygon(4 * g, radius=genus_g_surface_radius(g),
                                   dimension=dimension)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Point.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
<li><code><b><a title="geometry_tools.projective.Polygon" href="projective.html#geometry_tools.projective.Polygon">Polygon</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.Polygon.get_edges" href="projective.html#geometry_tools.projective.Polygon.get_edges">get_edges</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.get_vertices" href="projective.html#geometry_tools.projective.Polygon.get_vertices">get_vertices</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Segment"><code class="flex name class">
<span>class <span class="ident">Segment</span></span>
<span>(</span><span>endpoint1, endpoint2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model a geodesic segment in hyperbolic space.</p>
<p>If <code>endpoint2</code> is <code>None</code>, interpret <code>endpoint1</code> as either a (2
x&hellip;x n) <code>ndarray</code> (where n is the dimension of the underlying
vector space), or else a composite <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> object which can be
unpacked into two Points (which may themselves be composite).</p>
<p>If <code>endpoint2</code> is given, then both <code>endpoint1</code> and <code>endpoint2</code>
can be used to construct <code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> objects, which serve as the
endpoints for this pair of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>endpoint1</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>One (or both) endpoints of the point pair</dd>
<dt><strong><code>endpoint2</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The other endpoint of the point pair. If <code>None</code>,
<code>endpoint1</code> contains the data for both points in the pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Segment(Geodesic):
    &#34;&#34;&#34;Model a geodesic segment in hyperbolic space.&#34;&#34;&#34;

    def __init__(self, endpoint1, endpoint2=None):
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if endpoint2 is None:
            try:
                self._construct_from_object(endpoint1)
                return
            except (AttributeError, TypeError, GeometryError):
                pass

            try:
                self.set(endpoint1)
                return
            except (AttributeError, GeometryError) as e:
                pass

        self.set_endpoints(endpoint1, endpoint2)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.endpoints = self.proj_data[..., :2, :]
        self.ideal_basis = self.proj_data[..., 2:, :]

    def set_endpoints(self, endpoint1, endpoint2=None):
        # reimplemented to also compute ideal endpoints
        if endpoint2 is None:
            self.endpoints = Point(endpoint1).proj_data
            self._compute_ideal_endpoints(endpoint1)
            return

        pt1 = Point(endpoint1)
        pt2 = Point(endpoint2)
        self.endpoints = Point(np.stack(
            [pt1.proj_data, pt2.proj_data], axis=-2)
        )

        self._compute_ideal_endpoints(self.endpoints)

    def _assert_geometry_valid(self, proj_data):
        HyperbolicObject._assert_geometry_valid(self, proj_data)

        if (proj_data.shape[-2] != 4):
            raise GeometryError( (&#34;Underlying data for a hyperbolic&#34;
            &#34; segment must have shape (..., 4, n) but data&#34;
            &#34; has shape {}&#34;).format(proj_data.shape))

        if not CHECK_LIGHT_CONE:
            return

        if not timelike(proj_data[..., 0, :, :]).all():
            raise GeometryError( &#34;segment data at index [..., 0, :,&#34;
            &#34;:] must consist of timelike vectors&#34; )

        if not lightlike(proj_data[..., 1, :, :]).all():
            raise GeometryError( &#34;segment data at index [..., 1, :,&#34;
            &#34;:] must consist of lightlike vectors&#34; )

    def _compute_ideal_endpoints(self, endpoints):
        end_data = Point(endpoints).proj_data
        dim = end_data.shape[-1]
        products = end_data @ minkowski(dim) @ end_data.swapaxes(-1, -2)
        a11 = products[..., 0, 0]
        a22 = products[..., 1, 1]
        a12 = products[..., 0, 1]

        a = a11 - 2 * a12 + a22
        b = 2 * a12 - 2 * a22
        c = a22

        mu1 = (-b + np.sqrt(b * b - 4 * a * c)) / (2*a)
        mu2 = (-b - np.sqrt(b * b - 4 * a * c)) / (2*a)

        null1 = (mu1[..., np.newaxis] * end_data[..., 0, :] +
                 (1 - mu1)[..., np.newaxis] * end_data[..., 1, :])

        null2 = (mu2[..., np.newaxis] * end_data[..., 0, :] +
                 (1 - mu2)[..., np.newaxis] * end_data[..., 1, :])

        ideal_basis = np.stack([null1, null2], axis=-2)
        proj_data = np.concatenate([end_data, ideal_basis], axis=-2)

        self.set(proj_data)

    def geodesic(self):
        &#34;&#34;&#34;Get the bi-infinite geodesic spanned by this segment

        Returns
        -------
        Geodesic
            Geodesic in hyperbolic space spanned by this segment.
        &#34;&#34;&#34;
        return Geodesic(self.ideal_basis)

    def ideal_endpoint_coords(self, model=Model.KLEIN):
        &#34;&#34;&#34;Alias for Subspace.ideal_basis_coords.

        &#34;&#34;&#34;
        return self.ideal_basis_coords(model)

    def circle_parameters(self, degrees=True, model=Model.POINCARE):
        &#34;&#34;&#34;Get parameters describing a circular arc corresponding to this
        segment in the Poincare or halfspace models.

        Parameters
        ----------
        degrees : bool
            if `True`, return angles in degrees. Otherwise, return
            angles in radians
        model : Model
            hyperbolic model to use for the computation

        Returns
        -------
        tuple
            tuple `(centers, radii, thetas)`, where `centers`,
            `radii`, and `thetas` are `ndarray`s representing the
            centers, radii, and begin/end angles for the circle
            corresponding to this arc in the given model of hyperbolic
            space. Angles are always specified in counterclockwise
            order.

        &#34;&#34;&#34;
        center, radius = self.sphere_parameters(model)

        endpoints = self.endpoint_coords(model)

        thetas = utils.circle_angles(center, endpoints)

        if model == Model.POINCARE:
            thetas = utils.short_arc(thetas)
        elif model == Model.HALFSPACE:
            thetas = utils.right_to_left(thetas)

        if degrees:
            thetas *= 180 / np.pi

        return center, radius, thetas</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></li>
<li><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></li>
<li><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></li>
<li><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.PointPair" href="projective.html#geometry_tools.projective.PointPair">PointPair</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Segment.circle_parameters"><code class="name flex">
<span>def <span class="ident">circle_parameters</span></span>(<span>self, degrees=True, model=Model.POINCARE)</span>
</code></dt>
<dd>
<div class="desc"><p>Get parameters describing a circular arc corresponding to this
segment in the Poincare or halfspace models.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>degrees</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, return angles in degrees. Otherwise, return
angles in radians</dd>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>hyperbolic model to use for the computation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>tuple <code>(centers, radii, thetas)</code>, where <code>centers</code>,
<code>radii</code>, and <code>thetas</code> are <code>ndarray</code>s representing the
centers, radii, and begin/end angles for the circle
corresponding to this arc in the given model of hyperbolic
space. Angles are always specified in counterclockwise
order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_parameters(self, degrees=True, model=Model.POINCARE):
    &#34;&#34;&#34;Get parameters describing a circular arc corresponding to this
    segment in the Poincare or halfspace models.

    Parameters
    ----------
    degrees : bool
        if `True`, return angles in degrees. Otherwise, return
        angles in radians
    model : Model
        hyperbolic model to use for the computation

    Returns
    -------
    tuple
        tuple `(centers, radii, thetas)`, where `centers`,
        `radii`, and `thetas` are `ndarray`s representing the
        centers, radii, and begin/end angles for the circle
        corresponding to this arc in the given model of hyperbolic
        space. Angles are always specified in counterclockwise
        order.

    &#34;&#34;&#34;
    center, radius = self.sphere_parameters(model)

    endpoints = self.endpoint_coords(model)

    thetas = utils.circle_angles(center, endpoints)

    if model == Model.POINCARE:
        thetas = utils.short_arc(thetas)
    elif model == Model.HALFSPACE:
        thetas = utils.right_to_left(thetas)

    if degrees:
        thetas *= 180 / np.pi

    return center, radius, thetas</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Segment.geodesic"><code class="name flex">
<span>def <span class="ident">geodesic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the bi-infinite geodesic spanned by this segment</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></code></dt>
<dd>Geodesic in hyperbolic space spanned by this segment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geodesic(self):
    &#34;&#34;&#34;Get the bi-infinite geodesic spanned by this segment

    Returns
    -------
    Geodesic
        Geodesic in hyperbolic space spanned by this segment.
    &#34;&#34;&#34;
    return Geodesic(self.ideal_basis)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Segment.ideal_endpoint_coords"><code class="name flex">
<span>def <span class="ident">ideal_endpoint_coords</span></span>(<span>self, model=Model.KLEIN)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for Subspace.ideal_basis_coords.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ideal_endpoint_coords(self, model=Model.KLEIN):
    &#34;&#34;&#34;Alias for Subspace.ideal_basis_coords.

    &#34;&#34;&#34;
    return self.ideal_basis_coords(model)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.Geodesic.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.endpoint_affine_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_affine_coords">endpoint_affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.endpoint_coords" href="#geometry_tools.hyperbolic.PointPair.endpoint_coords">endpoint_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.endpoint_projective_coords" href="projective.html#geometry_tools.projective.PointPair.endpoint_projective_coords">endpoint_projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.from_reflection" href="#geometry_tools.hyperbolic.Geodesic.from_reflection">from_reflection</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.get_end_pair" href="#geometry_tools.hyperbolic.PointPair.get_end_pair">get_end_pair</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.get_endpoints" href="#geometry_tools.hyperbolic.PointPair.get_endpoints">get_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.ideal_basis_coords" href="#geometry_tools.hyperbolic.Subspace.ideal_basis_coords">ideal_basis_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.reflection_across" href="#geometry_tools.hyperbolic.Subspace.reflection_across">reflection_across</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.set_endpoints" href="projective.html#geometry_tools.projective.PointPair.set_endpoints">set_endpoints</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.spacelike_complement" href="#geometry_tools.hyperbolic.Subspace.spacelike_complement">spacelike_complement</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.sphere_parameters" href="#geometry_tools.hyperbolic.Subspace.sphere_parameters">sphere_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.Subspace"><code class="flex name class">
<span>class <span class="ident">Subspace</span></span>
<span>(</span><span>proj_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a geodesic subspace of hyperbolic space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>ndarray</code></dt>
<dd>Data used to construct a subspace (or array of
subspaces). If <code>proj_data</code> is a <code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code>, then
use underlying coordinate data to build an array of
subspaces. If <code>proj_data</code> is an <code>ndarray</code>, then interpret
this as coordinate data for an array of subspaces in the
projective model.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Subspace(IdealPoint):
    &#34;&#34;&#34;Model for a geodesic subspace of hyperbolic space.

    &#34;&#34;&#34;
    def __init__(self, proj_data):
        &#34;&#34;&#34;
        Parameters
        ----------
        proj_data : HyperbolicObject or ndarray
            Data used to construct a subspace (or array of
            subspaces). If `proj_data` is a `HyperbolicObject`, then
            use underlying coordinate data to build an array of
            subspaces. If `proj_data` is an `ndarray`, then interpret
            this as coordinate data for an array of subspaces in the
            projective model.

        &#34;&#34;&#34;
        HyperbolicObject.__init__(self, proj_data, unit_ndims=2)

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.ideal_basis = proj_data

    def ideal_basis_coords(self, model=Model.KLEIN):
        &#34;&#34;&#34;Get coordinates for a basis of this subspace lying in the ideal
           boundary of hyperbolic space

        Parameters
        ----------
        model : Model
            Model of hyperbolic space in which to compute coordinates

        Returns
        -------
        ndarray
            Coordinates for k vectors in the ideal boundary of
            hyperbolic space, giving a basis for this subspace.

        &#34;&#34;&#34;
        #we don&#39;t return proj_data directly, since we want subclasses
        #to be able to use this method even if the structure of the
        #underlying data is different.
        return Point(self.ideal_basis).coords(model)

    def spacelike_complement(self):
        &#34;&#34;&#34;Get a spacelike point in the orthogonal complement to this subspace

        Returns
        -------
        DualPoint
            A spacelike (i.e. Minkowski-positive) point which is
            Minkowski-orthogonal to this subspace. This is not
            uniquely determined (as a point in projective space)
            unless the subspace is a hyperplane.

        &#34;&#34;&#34;

        orthed = self._data_with_dual()
        return DualPoint(orthed[..., 0, :])

    def _data_with_dual(self):
        midpoints = np.sum(self.ideal_basis, axis=-2) / self.ideal_basis.shape[-2]

        poincare_ctr, poincare_rad = self.sphere_parameters(model=Model.POINCARE)
        spacelike_guess = Point(poincare_ctr, model=Model.KLEIN).coords(
            model=Model.PROJECTIVE
        )


        to_orthogonalize = np.concatenate(
            [np.expand_dims(midpoints, axis=-2),
            self.ideal_basis[..., 1:, :],
            np.expand_dims(spacelike_guess, axis=-2)],
            axis=-2)

        orthed = utils.indefinite_orthogonalize(self.minkowski,
                                                to_orthogonalize)
        return np.concatenate([
            np.expand_dims(orthed[..., -1, :], axis=-2),
            self.ideal_basis], axis=-2)

    def sphere_parameters(self, model=Model.POINCARE):
        &#34;&#34;&#34;Get parameters describing a k-sphere corresponding to this subspace
        in the Poincare model.

        Parameters
        ----------
        model : Model
            hyperbolic model to use. Acceptable values are
            `Model.POINCARE` and `Model.HALFSPACE`

        Returns
        -------
        tuple
            Tuple of the form `(centers, radii)`, where `centers` and
            `radii` are `ndarray`s respectively holding the centers
            and radii of spheres corresponding to this subspace in the
            given hyperbolic model.

        Raises
        ------
        GeometryError

        &#34;&#34;&#34;

        if model == Model.POINCARE:
            klein_basis = self.ideal_basis_coords(model=Model.KLEIN)
            klein_midpoint = klein_basis.sum(axis=-2) / klein_basis.shape[-2]
            poincare_midpoint = kleinian_to_poincare(klein_midpoint)
            poincare_extreme = utils.sphere_inversion(poincare_midpoint)

            center = (poincare_midpoint + poincare_extreme) / 2
            radius = np.sqrt(utils.normsq(poincare_midpoint - poincare_extreme)) / 2

        elif model == Model.HALFSPACE:
            halfspace_basis = self.ideal_basis_coords(model=Model.HALFSPACE)
            halfspace_midpoint = (halfspace_basis.sum(axis=-2) /
                                  halfspace_basis.shape[-2])

            #just use the first element of the basis
            center = halfspace_midpoint
            radius = np.sqrt(
                utils.normsq(halfspace_basis[..., 0, :] - halfspace_midpoint)
            )
        else:
            raise GeometryError(
                (&#34;Cannot compute spherical parameters for an object of type {}&#34;
                 &#34; in model: &#39;{}&#39;&#34;).format(self.__class__.__name__, model)
            )

        return center, radius

    def reflection_across(self):
        &#34;&#34;&#34;Get a hyperbolic isometry reflecting across this hyperplane.

        Returns
        -------
        Isometry
            Isometry reflecting across this hyperplane.

        &#34;&#34;&#34;
        dual_data = self._data_with_dual()
        if self.dimension + 1 != dual_data.shape[-2]:
            raise GeometryError(
                (&#34;Cannot compute a reflection across a subspace of &#34;
                 &#34;dimension {}&#34;).format(dual_data.shape[-2])
            )

        refdata = (np.linalg.inv(dual_data) @
                   self.minkowski @
                   dual_data)

        return Isometry(refdata, column_vectors=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Point" href="projective.html#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></li>
<li><a title="geometry_tools.hyperbolic.Hyperplane" href="#geometry_tools.hyperbolic.Hyperplane">Hyperplane</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.Subspace.ideal_basis_coords"><code class="name flex">
<span>def <span class="ident">ideal_basis_coords</span></span>(<span>self, model=Model.KLEIN)</span>
</code></dt>
<dd>
<div class="desc"><p>Get coordinates for a basis of this subspace lying in the ideal
boundary of hyperbolic space</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>Model of hyperbolic space in which to compute coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Coordinates for k vectors in the ideal boundary of
hyperbolic space, giving a basis for this subspace.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ideal_basis_coords(self, model=Model.KLEIN):
    &#34;&#34;&#34;Get coordinates for a basis of this subspace lying in the ideal
       boundary of hyperbolic space

    Parameters
    ----------
    model : Model
        Model of hyperbolic space in which to compute coordinates

    Returns
    -------
    ndarray
        Coordinates for k vectors in the ideal boundary of
        hyperbolic space, giving a basis for this subspace.

    &#34;&#34;&#34;
    #we don&#39;t return proj_data directly, since we want subclasses
    #to be able to use this method even if the structure of the
    #underlying data is different.
    return Point(self.ideal_basis).coords(model)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Subspace.reflection_across"><code class="name flex">
<span>def <span class="ident">reflection_across</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a hyperbolic isometry reflecting across this hyperplane.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code></dt>
<dd>Isometry reflecting across this hyperplane.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reflection_across(self):
    &#34;&#34;&#34;Get a hyperbolic isometry reflecting across this hyperplane.

    Returns
    -------
    Isometry
        Isometry reflecting across this hyperplane.

    &#34;&#34;&#34;
    dual_data = self._data_with_dual()
    if self.dimension + 1 != dual_data.shape[-2]:
        raise GeometryError(
            (&#34;Cannot compute a reflection across a subspace of &#34;
             &#34;dimension {}&#34;).format(dual_data.shape[-2])
        )

    refdata = (np.linalg.inv(dual_data) @
               self.minkowski @
               dual_data)

    return Isometry(refdata, column_vectors=False)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Subspace.spacelike_complement"><code class="name flex">
<span>def <span class="ident">spacelike_complement</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a spacelike point in the orthogonal complement to this subspace</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.DualPoint" href="#geometry_tools.hyperbolic.DualPoint">DualPoint</a></code></dt>
<dd>A spacelike (i.e. Minkowski-positive) point which is
Minkowski-orthogonal to this subspace. This is not
uniquely determined (as a point in projective space)
unless the subspace is a hyperplane.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spacelike_complement(self):
    &#34;&#34;&#34;Get a spacelike point in the orthogonal complement to this subspace

    Returns
    -------
    DualPoint
        A spacelike (i.e. Minkowski-positive) point which is
        Minkowski-orthogonal to this subspace. This is not
        uniquely determined (as a point in projective space)
        unless the subspace is a hyperplane.

    &#34;&#34;&#34;

    orthed = self._data_with_dual()
    return DualPoint(orthed[..., 0, :])</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.Subspace.sphere_parameters"><code class="name flex">
<span>def <span class="ident">sphere_parameters</span></span>(<span>self, model=Model.POINCARE)</span>
</code></dt>
<dd>
<div class="desc"><p>Get parameters describing a k-sphere corresponding to this subspace
in the Poincare model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></dt>
<dd>hyperbolic model to use. Acceptable values are
<code><a title="geometry_tools.hyperbolic.Model.POINCARE" href="#geometry_tools.hyperbolic.Model.POINCARE">Model.POINCARE</a></code> and <code><a title="geometry_tools.hyperbolic.Model.HALFSPACE" href="#geometry_tools.hyperbolic.Model.HALFSPACE">Model.HALFSPACE</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple of the form <code>(centers, radii)</code>, where <code>centers</code> and
<code>radii</code> are <code>ndarray</code>s respectively holding the centers
and radii of spheres corresponding to this subspace in the
given hyperbolic model.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>GeometryError</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere_parameters(self, model=Model.POINCARE):
    &#34;&#34;&#34;Get parameters describing a k-sphere corresponding to this subspace
    in the Poincare model.

    Parameters
    ----------
    model : Model
        hyperbolic model to use. Acceptable values are
        `Model.POINCARE` and `Model.HALFSPACE`

    Returns
    -------
    tuple
        Tuple of the form `(centers, radii)`, where `centers` and
        `radii` are `ndarray`s respectively holding the centers
        and radii of spheres corresponding to this subspace in the
        given hyperbolic model.

    Raises
    ------
    GeometryError

    &#34;&#34;&#34;

    if model == Model.POINCARE:
        klein_basis = self.ideal_basis_coords(model=Model.KLEIN)
        klein_midpoint = klein_basis.sum(axis=-2) / klein_basis.shape[-2]
        poincare_midpoint = kleinian_to_poincare(klein_midpoint)
        poincare_extreme = utils.sphere_inversion(poincare_midpoint)

        center = (poincare_midpoint + poincare_extreme) / 2
        radius = np.sqrt(utils.normsq(poincare_midpoint - poincare_extreme)) / 2

    elif model == Model.HALFSPACE:
        halfspace_basis = self.ideal_basis_coords(model=Model.HALFSPACE)
        halfspace_midpoint = (halfspace_basis.sum(axis=-2) /
                              halfspace_basis.shape[-2])

        #just use the first element of the basis
        center = halfspace_midpoint
        radius = np.sqrt(
            utils.normsq(halfspace_basis[..., 0, :] - halfspace_midpoint)
        )
    else:
        raise GeometryError(
            (&#34;Cannot compute spherical parameters for an object of type {}&#34;
             &#34; in model: &#39;{}&#39;&#34;).format(self.__class__.__name__, model)
        )

    return center, radius</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.hyperbolic.TangentVector"><code class="flex name class">
<span>class <span class="ident">TangentVector</span></span>
<span>(</span><span>point_data, vector=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model for a tangent vector in hyperbolic space.</p>
<p>If <code>vector</code> is <code>None</code>, interpret <code>point_data</code> as either an ndarray
of shape <code>(&hellip;, 2, n)</code> (where <code>n</code> is the dimension of the
underlying vector space), or else a composite HyperbolicObject
whose data can be unpacked into a point in projective space
and a tangent vector to a hyperboloid.</p>
<p>If <code>vector</code> is given, then <code>point_data</code> is used to construct
the basepoint for this tangent vector, and <code>vector</code> is used to
construct the tangent vector to the hyperboloid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point_data</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The basepoint of the tangent vector, or (if <code>vector</code> is
<code>None</code>) the data of the basepoint and the tangent vector.</dd>
<dt><strong><code>vector</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code> or <code>ndarray</code></dt>
<dd>The tangent vector data. If <code>None</code>, <code>point_data</code> contains
the data for the basepoint and the tangent vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TangentVector(HyperbolicObject):
    &#34;&#34;&#34;Model for a tangent vector in hyperbolic space.&#34;&#34;&#34;
    def __init__(self, point_data, vector=None):
        &#34;&#34;&#34;If `vector` is `None`, interpret `point_data` as either an ndarray
        of shape `(..., 2, n)` (where `n` is the dimension of the
        underlying vector space), or else a composite HyperbolicObject
        whose data can be unpacked into a point in projective space
        and a tangent vector to a hyperboloid.

        If `vector` is given, then `point_data` is used to construct
        the basepoint for this tangent vector, and `vector` is used to
        construct the tangent vector to the hyperboloid.

        Parameters
        ----------
        point_data : Point or ndarray
            The basepoint of the tangent vector, or (if `vector` is
            `None`) the data of the basepoint and the tangent vector.
        vector : HyperbolicObject or ndarray
            The tangent vector data. If `None`, `point_data` contains
            the data for the basepoint and the tangent vector.

        &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if vector is None:
            try:
                self._construct_from_object(point_data)
                return
            except TypeError:
                pass

            self.set(point_data)
            return

        self._compute_data(point_data, vector)

    def _assert_geometry_valid(self, proj_data):
        super()._assert_geometry_valid(proj_data)

        if proj_data.shape[-2] != 2:
            raise GeometryError(
                (&#34;Underlying data for a tangent vector in Hn must have shape&#34;
                 &#34; (..., 2, n) but data has shape {}&#34;).format(
                     proj_data.shape)
            )

        if not CHECK_LIGHT_CONE:
            return

        point_data = proj_data[..., 0, :]
        vector_data = proj_data[..., 1, :]

        if not timelike(point_data).all():
            raise GeometryError(&#34;tangent vector data at index [..., 0, :] must&#34;
                                &#34; consist of timelike vectors&#34;)

        products = utils.apply_bilinear(point_data, vector_data, self.minkowski)
        if (np.abs(products) &gt; ERROR_THRESHOLD).any():
            raise GeometryError(&#34;tangent vector must be orthogonal to point&#34;)

    def _compute_data(self, point, vector):
        #wrapping these as hyperbolic objects first
        pt = Point(point)

        #this should be a dual point, but we don&#39;t expect one until
        #after we project
        vec = HyperbolicObject(vector)

        projected = project_to_hyperboloid(pt.proj_data, vec.proj_data)

        self.set(np.stack([pt.proj_data, projected], axis=-2))

    def set(self, proj_data, **kwargs):
        HyperbolicObject.set(self, proj_data)
        self.point = self.proj_data[..., 0, :]
        self.vector = self.proj_data[..., 1, :]

    def normalized(self):
        &#34;&#34;&#34;Get a unit tangent vector in the same direction as this tangent
        vector.

        Returns
        -------
        TangentVector
            Normalized version of this tangent vector (with respect to
            the standard Minkowski inner product)

        &#34;&#34;&#34;
        normed_vec = utils.normalize(self.vector, self.minkowski)
        return TangentVector(self.point, normed_vec)

    def origin_to(self, force_oriented=True):
        &#34;&#34;&#34;Get an isometry taking the &#34;origin&#34; to this vector.

        The &#34;origin&#34; is a tangent vector whose basepoint lies at (0,
        0, ....) in Poincare or Kleinian coordinates, and whose
        tangent vector is parallel to the second standard basis
        vector.

        Parameters
        ----------
        force_oriented : bool
            If `True`, force the computed isometry to be
            orientation-preserving

        Returns
        -------
        Isometry
            Isometry taking the &#34;origin&#34; to this tangent vector.

    &#34;&#34;&#34;
        normed = utils.normalize(self.proj_data, self.minkowski)
        isom = utils.find_isometry(self.minkowski, normed,
                                   force_oriented)

        return Isometry(isom, column_vectors=False)

    def isometry_to(self, other, force_oriented=True):
        &#34;&#34;&#34;Get an isometry taking this tangent vector to a scalar multiple of
        the other.

        Parameters
        ----------
        other : TangentVector
            Tangent vector to translate this vector to
        force_oriented : bool
            If `True`, force the computed isometry to be
            orientation-preserving.

        Returns
        -------
        Isometry
            Isometry this tangent vector to `other`.

        &#34;&#34;&#34;
        return other.origin_to(force_oriented) @ self.origin_to(force_oriented).inv()

    def angle(self, other):
        &#34;&#34;&#34;Compute the angle between two tangent vectors.

        Parameters
        ----------
        other : TangentVector

        Returns
        -------
        float or ndarray
            The angle between `self` and `other`.

        &#34;&#34;&#34;
        v1 = project_to_hyperboloid(self.point, self.normalized().vector)
        v2 = project_to_hyperboloid(self.point, other.normalized().vector)

        product = utils.apply_bilinear(v1, v2, self.minkowski)
        return np.arccos(product)

    def point_along(self, distance):
        &#34;&#34;&#34;Get a point in hyperbolic space along the geodesic specified by
        this tangent vector.

        Parameters
        ----------
        distance : float or ndarray

        Returns
        -------
        Point
            Point in hyperbolic space along the geodesic ray defined
            by this tangent vector

        &#34;&#34;&#34;
        kleinian_shape = list(self.point.shape)
        kleinian_shape[-1] -= 1

        kleinian_pt = np.zeros(kleinian_shape)
        kleinian_pt[..., 0] = hyp_to_affine_dist(distance)

        basepoint = Point(kleinian_pt, model=Model.KLEIN)

        return self.origin_to().apply(basepoint, &#34;elementwise&#34;)

    @classmethod
    def get_base_tangent(cls, dimension, shape=()):
        &#34;&#34;&#34;Get an &#34;origin&#34; tangent vector.

        The basepoint of this tangent vector has coordinates (0, 0,
        ...) in Poincare/Klein coordinates, and the vector is parallel
        to the second standard basis vector in R^(n,1).

        Parameters
        ----------
        dimension : int
            Dimension of the hyperbolic space where this tangent vector lives
        shape : tuple
            Shape of the composite TangentVector object to return.

        Returns
        -------
        TangentVector
            An &#34;origin&#34; tangent vector.

        &#34;&#34;&#34;
        origin = Point.get_origin(dimension, shape)
        vector = np.zeros(() + (dimension + 1,))
        vector[..., 1] = 1.

        return TangentVector(origin, vector)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="projective.html#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.TangentVector.get_base_tangent"><code class="name flex">
<span>def <span class="ident">get_base_tangent</span></span>(<span>dimension, shape=())</span>
</code></dt>
<dd>
<div class="desc"><p>Get an "origin" tangent vector.</p>
<p>The basepoint of this tangent vector has coordinates (0, 0,
&hellip;) in Poincare/Klein coordinates, and the vector is parallel
to the second standard basis vector in R^(n,1).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dimension</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of the hyperbolic space where this tangent vector lives</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Shape of the composite TangentVector object to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></code></dt>
<dd>An "origin" tangent vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_base_tangent(cls, dimension, shape=()):
    &#34;&#34;&#34;Get an &#34;origin&#34; tangent vector.

    The basepoint of this tangent vector has coordinates (0, 0,
    ...) in Poincare/Klein coordinates, and the vector is parallel
    to the second standard basis vector in R^(n,1).

    Parameters
    ----------
    dimension : int
        Dimension of the hyperbolic space where this tangent vector lives
    shape : tuple
        Shape of the composite TangentVector object to return.

    Returns
    -------
    TangentVector
        An &#34;origin&#34; tangent vector.

    &#34;&#34;&#34;
    origin = Point.get_origin(dimension, shape)
    vector = np.zeros(() + (dimension + 1,))
    vector[..., 1] = 1.

    return TangentVector(origin, vector)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.hyperbolic.TangentVector.angle"><code class="name flex">
<span>def <span class="ident">angle</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle between two tangent vectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>ndarray</code></dt>
<dd>The angle between <code>self</code> and <code>other</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angle(self, other):
    &#34;&#34;&#34;Compute the angle between two tangent vectors.

    Parameters
    ----------
    other : TangentVector

    Returns
    -------
    float or ndarray
        The angle between `self` and `other`.

    &#34;&#34;&#34;
    v1 = project_to_hyperboloid(self.point, self.normalized().vector)
    v2 = project_to_hyperboloid(self.point, other.normalized().vector)

    product = utils.apply_bilinear(v1, v2, self.minkowski)
    return np.arccos(product)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.TangentVector.isometry_to"><code class="name flex">
<span>def <span class="ident">isometry_to</span></span>(<span>self, other, force_oriented=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an isometry taking this tangent vector to a scalar multiple of
the other.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></code></dt>
<dd>Tangent vector to translate this vector to</dd>
<dt><strong><code>force_oriented</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, force the computed isometry to be
orientation-preserving.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code></dt>
<dd>Isometry this tangent vector to <code>other</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isometry_to(self, other, force_oriented=True):
    &#34;&#34;&#34;Get an isometry taking this tangent vector to a scalar multiple of
    the other.

    Parameters
    ----------
    other : TangentVector
        Tangent vector to translate this vector to
    force_oriented : bool
        If `True`, force the computed isometry to be
        orientation-preserving.

    Returns
    -------
    Isometry
        Isometry this tangent vector to `other`.

    &#34;&#34;&#34;
    return other.origin_to(force_oriented) @ self.origin_to(force_oriented).inv()</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.TangentVector.normalized"><code class="name flex">
<span>def <span class="ident">normalized</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a unit tangent vector in the same direction as this tangent
vector.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></code></dt>
<dd>Normalized version of this tangent vector (with respect to
the standard Minkowski inner product)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalized(self):
    &#34;&#34;&#34;Get a unit tangent vector in the same direction as this tangent
    vector.

    Returns
    -------
    TangentVector
        Normalized version of this tangent vector (with respect to
        the standard Minkowski inner product)

    &#34;&#34;&#34;
    normed_vec = utils.normalize(self.vector, self.minkowski)
    return TangentVector(self.point, normed_vec)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.TangentVector.origin_to"><code class="name flex">
<span>def <span class="ident">origin_to</span></span>(<span>self, force_oriented=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an isometry taking the "origin" to this vector.</p>
<p>The "origin" is a tangent vector whose basepoint lies at (0,
0, ....) in Poincare or Kleinian coordinates, and whose
tangent vector is parallel to the second standard basis
vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>force_oriented</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, force the computed isometry to be
orientation-preserving</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code></dt>
<dd>Isometry taking the "origin" to this tangent vector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def origin_to(self, force_oriented=True):
    &#34;&#34;&#34;Get an isometry taking the &#34;origin&#34; to this vector.

    The &#34;origin&#34; is a tangent vector whose basepoint lies at (0,
    0, ....) in Poincare or Kleinian coordinates, and whose
    tangent vector is parallel to the second standard basis
    vector.

    Parameters
    ----------
    force_oriented : bool
        If `True`, force the computed isometry to be
        orientation-preserving

    Returns
    -------
    Isometry
        Isometry taking the &#34;origin&#34; to this tangent vector.

&#34;&#34;&#34;
    normed = utils.normalize(self.proj_data, self.minkowski)
    isom = utils.find_isometry(self.minkowski, normed,
                               force_oriented)

    return Isometry(isom, column_vectors=False)</code></pre>
</details>
</dd>
<dt id="geometry_tools.hyperbolic.TangentVector.point_along"><code class="name flex">
<span>def <span class="ident">point_along</span></span>(<span>self, distance)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a point in hyperbolic space along the geodesic specified by
this tangent vector.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code> or <code>ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></dt>
<dd>Point in hyperbolic space along the geodesic ray defined
by this tangent vector</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def point_along(self, distance):
    &#34;&#34;&#34;Get a point in hyperbolic space along the geodesic specified by
    this tangent vector.

    Parameters
    ----------
    distance : float or ndarray

    Returns
    -------
    Point
        Point in hyperbolic space along the geodesic ray defined
        by this tangent vector

    &#34;&#34;&#34;
    kleinian_shape = list(self.point.shape)
    kleinian_shape[-1] -= 1

    kleinian_pt = np.zeros(kleinian_shape)
    kleinian_pt[..., 0] = hyp_to_affine_dist(distance)

    basepoint = Point(kleinian_pt, model=Model.KLEIN)

    return self.origin_to().apply(basepoint, &#34;elementwise&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.affine_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.combine" href="projective.html#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.coords" href="#geometry_tools.hyperbolic.HyperbolicObject.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.flatten_to_unit" href="projective.html#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.projective_coords" href="projective.html#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.set" href="projective.html#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.shape" href="projective.html#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geometry_tools" href="index.html">geometry_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.genus_g_surface_radius" href="#geometry_tools.hyperbolic.genus_g_surface_radius">genus_g_surface_radius</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.get_boundary_point" href="#geometry_tools.hyperbolic.get_boundary_point">get_boundary_point</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.get_point" href="#geometry_tools.hyperbolic.get_point">get_point</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.halfspace_to_poincare" href="#geometry_tools.hyperbolic.halfspace_to_poincare">halfspace_to_poincare</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.hyp_to_affine_dist" href="#geometry_tools.hyperbolic.hyp_to_affine_dist">hyp_to_affine_dist</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.hyperboloid_coords" href="#geometry_tools.hyperbolic.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.identity" href="#geometry_tools.hyperbolic.identity">identity</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.kleinian_coords" href="#geometry_tools.hyperbolic.kleinian_coords">kleinian_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.kleinian_to_poincare" href="#geometry_tools.hyperbolic.kleinian_to_poincare">kleinian_to_poincare</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.lightlike" href="#geometry_tools.hyperbolic.lightlike">lightlike</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.minkowski" href="#geometry_tools.hyperbolic.minkowski">minkowski</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.poincare_to_halfspace" href="#geometry_tools.hyperbolic.poincare_to_halfspace">poincare_to_halfspace</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.poincare_to_kleinian" href="#geometry_tools.hyperbolic.poincare_to_kleinian">poincare_to_kleinian</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.polygon_interior_angle" href="#geometry_tools.hyperbolic.polygon_interior_angle">polygon_interior_angle</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.project_to_hyperboloid" href="#geometry_tools.hyperbolic.project_to_hyperboloid">project_to_hyperboloid</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.regular_polygon_radius" href="#geometry_tools.hyperbolic.regular_polygon_radius">regular_polygon_radius</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.sl2r_iso" href="#geometry_tools.hyperbolic.sl2r_iso">sl2r_iso</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.spacelike" href="#geometry_tools.hyperbolic.spacelike">spacelike</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.spacelike_to" href="#geometry_tools.hyperbolic.spacelike_to">spacelike_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.timelike" href="#geometry_tools.hyperbolic.timelike">timelike</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.timelike_to" href="#geometry_tools.hyperbolic.timelike_to">timelike_to</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geometry_tools.hyperbolic.BoundaryArc" href="#geometry_tools.hyperbolic.BoundaryArc">BoundaryArc</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.BoundaryArc.circle_parameters" href="#geometry_tools.hyperbolic.BoundaryArc.circle_parameters">circle_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.BoundaryArc.flip_orientation" href="#geometry_tools.hyperbolic.BoundaryArc.flip_orientation">flip_orientation</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.BoundaryArc.orientation" href="#geometry_tools.hyperbolic.BoundaryArc.orientation">orientation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.DualPoint" href="#geometry_tools.hyperbolic.DualPoint">DualPoint</a></code></h4>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Geodesic" href="#geometry_tools.hyperbolic.Geodesic">Geodesic</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Geodesic.circle_parameters" href="#geometry_tools.hyperbolic.Geodesic.circle_parameters">circle_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Geodesic.from_reflection" href="#geometry_tools.hyperbolic.Geodesic.from_reflection">from_reflection</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Horosphere" href="#geometry_tools.hyperbolic.Horosphere">Horosphere</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Horosphere.center_coords" href="#geometry_tools.hyperbolic.Horosphere.center_coords">center_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.intersect_geodesic" href="#geometry_tools.hyperbolic.Horosphere.intersect_geodesic">intersect_geodesic</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.ref_coords" href="#geometry_tools.hyperbolic.Horosphere.ref_coords">ref_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.set_center_ref" href="#geometry_tools.hyperbolic.Horosphere.set_center_ref">set_center_ref</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Horosphere.sphere_parameters" href="#geometry_tools.hyperbolic.Horosphere.sphere_parameters">sphere_parameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.HorosphereArc" href="#geometry_tools.hyperbolic.HorosphereArc">HorosphereArc</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.HorosphereArc.circle_parameters" href="#geometry_tools.hyperbolic.HorosphereArc.circle_parameters">circle_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HorosphereArc.set_center_endpoints" href="#geometry_tools.hyperbolic.HorosphereArc.set_center_endpoints">set_center_endpoints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.HyperbolicObject" href="#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.coords" href="#geometry_tools.hyperbolic.HyperbolicObject.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.kleinian_coords" href="#geometry_tools.hyperbolic.HyperbolicObject.kleinian_coords">kleinian_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicObject.minkowski" href="#geometry_tools.hyperbolic.HyperbolicObject.minkowski">minkowski</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.HyperbolicRepresentation" href="#geometry_tools.hyperbolic.HyperbolicRepresentation">HyperbolicRepresentation</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.HyperbolicRepresentation.isometries" href="#geometry_tools.hyperbolic.HyperbolicRepresentation.isometries">isometries</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.HyperbolicRepresentation.normalize" href="#geometry_tools.hyperbolic.HyperbolicRepresentation.normalize">normalize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Hyperplane" href="#geometry_tools.hyperbolic.Hyperplane">Hyperplane</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Hyperplane.from_reflection" href="#geometry_tools.hyperbolic.Hyperplane.from_reflection">from_reflection</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.IdealPoint" href="#geometry_tools.hyperbolic.IdealPoint">IdealPoint</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.IdealPoint.from_angle" href="#geometry_tools.hyperbolic.IdealPoint.from_angle">from_angle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Isometry" href="#geometry_tools.hyperbolic.Isometry">Isometry</a></code></h4>
<ul class="two-column">
<li><code><a title="geometry_tools.hyperbolic.Isometry.axis" href="#geometry_tools.hyperbolic.Isometry.axis">axis</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Isometry.elliptic" href="#geometry_tools.hyperbolic.Isometry.elliptic">elliptic</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Isometry.fixed_point" href="#geometry_tools.hyperbolic.Isometry.fixed_point">fixed_point</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Isometry.fixed_point_pair" href="#geometry_tools.hyperbolic.Isometry.fixed_point_pair">fixed_point_pair</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Isometry.isometry_type" href="#geometry_tools.hyperbolic.Isometry.isometry_type">isometry_type</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Isometry.standard_loxodromic" href="#geometry_tools.hyperbolic.Isometry.standard_loxodromic">standard_loxodromic</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Isometry.standard_rotation" href="#geometry_tools.hyperbolic.Isometry.standard_rotation">standard_rotation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Model" href="#geometry_tools.hyperbolic.Model">Model</a></code></h4>
<ul class="two-column">
<li><code><a title="geometry_tools.hyperbolic.Model.AFFINE" href="#geometry_tools.hyperbolic.Model.AFFINE">AFFINE</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.HALFPLANE" href="#geometry_tools.hyperbolic.Model.HALFPLANE">HALFPLANE</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.HALFSPACE" href="#geometry_tools.hyperbolic.Model.HALFSPACE">HALFSPACE</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.HYPERBOLOID" href="#geometry_tools.hyperbolic.Model.HYPERBOLOID">HYPERBOLOID</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.KLEIN" href="#geometry_tools.hyperbolic.Model.KLEIN">KLEIN</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.KLEINIAN" href="#geometry_tools.hyperbolic.Model.KLEINIAN">KLEINIAN</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.POINCARE" href="#geometry_tools.hyperbolic.Model.POINCARE">POINCARE</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.PROJECTIVE" href="#geometry_tools.hyperbolic.Model.PROJECTIVE">PROJECTIVE</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Model.aliases" href="#geometry_tools.hyperbolic.Model.aliases">aliases</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Point" href="#geometry_tools.hyperbolic.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Point.coords" href="#geometry_tools.hyperbolic.Point.coords">coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.distance" href="#geometry_tools.hyperbolic.Point.distance">distance</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.get_origin" href="#geometry_tools.hyperbolic.Point.get_origin">get_origin</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.halfspace_coords" href="#geometry_tools.hyperbolic.Point.halfspace_coords">halfspace_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.hyperboloid_coords" href="#geometry_tools.hyperbolic.Point.hyperboloid_coords">hyperboloid_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.origin_to" href="#geometry_tools.hyperbolic.Point.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.poincare_coords" href="#geometry_tools.hyperbolic.Point.poincare_coords">poincare_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Point.unit_tangent_towards" href="#geometry_tools.hyperbolic.Point.unit_tangent_towards">unit_tangent_towards</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.PointPair" href="#geometry_tools.hyperbolic.PointPair">PointPair</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.PointPair.endpoint_coords" href="#geometry_tools.hyperbolic.PointPair.endpoint_coords">endpoint_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_end_pair" href="#geometry_tools.hyperbolic.PointPair.get_end_pair">get_end_pair</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.PointPair.get_endpoints" href="#geometry_tools.hyperbolic.PointPair.get_endpoints">get_endpoints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Polygon" href="#geometry_tools.hyperbolic.Polygon">Polygon</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Polygon.circle_parameters" href="#geometry_tools.hyperbolic.Polygon.circle_parameters">circle_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Polygon.regular_polygon" href="#geometry_tools.hyperbolic.Polygon.regular_polygon">regular_polygon</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Polygon.regular_surface_polygon" href="#geometry_tools.hyperbolic.Polygon.regular_surface_polygon">regular_surface_polygon</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Segment" href="#geometry_tools.hyperbolic.Segment">Segment</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Segment.circle_parameters" href="#geometry_tools.hyperbolic.Segment.circle_parameters">circle_parameters</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Segment.geodesic" href="#geometry_tools.hyperbolic.Segment.geodesic">geodesic</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Segment.ideal_endpoint_coords" href="#geometry_tools.hyperbolic.Segment.ideal_endpoint_coords">ideal_endpoint_coords</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.Subspace" href="#geometry_tools.hyperbolic.Subspace">Subspace</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.hyperbolic.Subspace.ideal_basis_coords" href="#geometry_tools.hyperbolic.Subspace.ideal_basis_coords">ideal_basis_coords</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.reflection_across" href="#geometry_tools.hyperbolic.Subspace.reflection_across">reflection_across</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.spacelike_complement" href="#geometry_tools.hyperbolic.Subspace.spacelike_complement">spacelike_complement</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.Subspace.sphere_parameters" href="#geometry_tools.hyperbolic.Subspace.sphere_parameters">sphere_parameters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.hyperbolic.TangentVector" href="#geometry_tools.hyperbolic.TangentVector">TangentVector</a></code></h4>
<ul class="two-column">
<li><code><a title="geometry_tools.hyperbolic.TangentVector.angle" href="#geometry_tools.hyperbolic.TangentVector.angle">angle</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.TangentVector.get_base_tangent" href="#geometry_tools.hyperbolic.TangentVector.get_base_tangent">get_base_tangent</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.TangentVector.isometry_to" href="#geometry_tools.hyperbolic.TangentVector.isometry_to">isometry_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.TangentVector.normalized" href="#geometry_tools.hyperbolic.TangentVector.normalized">normalized</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.TangentVector.origin_to" href="#geometry_tools.hyperbolic.TangentVector.origin_to">origin_to</a></code></li>
<li><code><a title="geometry_tools.hyperbolic.TangentVector.point_along" href="#geometry_tools.hyperbolic.TangentVector.point_along">point_along</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geometry_tools.projective API documentation</title>
<meta name="description" content="Work with projective space in numerical coordinates." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geometry_tools.projective</code></h1>
</header>
<section id="section-intro">
<p>Work with projective space in numerical coordinates.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Work with projective space in numerical coordinates.

&#34;&#34;&#34;

from copy import copy

import numpy as np
from scipy.spatial import ConvexHull

from geometry_tools import utils
from geometry_tools import representation


class GeometryError(Exception):
    &#34;&#34;&#34;Thrown if there&#39;s an attempt to construct a geometric object with
    numerical data that doesn&#39;t make sense for that type of object.

    &#34;&#34;&#34;
    pass

class ProjectiveObject:
    &#34;&#34;&#34;Represent some object in projective geometry (possibly a composite
    object).

    The underlying data of a projective object is stored as a numpy
    ndarray. The last `unit_ndims` ndims of this array describe a
    *single* instance of this type of object.

    For example, a `Polygon` object has `unit_ndims` equal to 2, since
    a single `Polygon` is represented by an array of shape `(n,d)`,
    where `n` is the number of vertices and `d` is the dimension of
    the underlying vector space. So, a `Polygon` object whose
    underlying array has shape `(5, 6, 4, 3)` represents a 5x6 array
    of quadrilaterals in RP^2 (i.e. the projectivization of R^3).

    &#34;&#34;&#34;
    def __init__(self, proj_data, aux_data=None, dual_data=None,
                 unit_ndims=1, aux_ndims=0, dual_ndims=0):
        &#34;&#34;&#34;Parameters
        -----------

        proj_data : ndarray
            underyling data describing this projective object

        aux_data : ndarray
            auxiliary data describing this projective
            object. Auxiliary data is any data which is in principle
            computable from `proj_data`, but is convenient to keep as
            part of the object definition for transformation purposes.

        dual_data : ndarray
            data describing this projective object which transforms
            covariantly, i.e. as a dual vector in projective space.

        unit_ndims : int
            number of ndims of an array representing a &#34;unit&#34; version
            of this object. For example, an object representing a
            single point in hyperbolic space has `unit_ndims` 1, while
            an object representing a line segment has `unit_ndims`
            equal to 2.

        aux_ndims : int
            like `unit_ndims`, but for auxiliary data.

        dual_ndims : int
            like `unit_ndims`, but for covariant (dual) data.

        &#34;&#34;&#34;
        self.unit_ndims = unit_ndims
        self.aux_ndims = aux_ndims
        self.dual_ndims = dual_ndims

        try:
            self._construct_from_object(proj_data)
        except TypeError:
            self.set(proj_data, aux_data, dual_data)

    @property
    def dimension(self):
        return self.proj_data.shape[-1] - 1

    def _assert_geometry_valid(self, proj_data):
        if proj_data.ndim &lt; self.unit_ndims:
            raise GeometryError(
                (&#34;{} expects an array with ndim at least {}, got array of shape {}&#34;
                ).format(
                    self.__class__.__name__, self.unit_ndims, proj_data.shape
                )
            )
    def _assert_aux_valid(self, aux_data):
        if aux_data is None and self.aux_ndims == 0:
            return

        if aux_data.ndim &lt; self.aux_ndims:
            raise GeometryError(
                (&#34;{} expects an auxiliary array with ndim at least {}, got array of shape&#34;
                ).format(
                    self.__class__.__name__, self.unit_ndims, proj_data.shape
                )
            )

    def _compute_aux_data(self, proj_data):
        return None

    def _construct_from_object(self, hyp_obj):
        &#34;&#34;&#34;if we&#39;re passed a hyperbolic object or an array of hyperbolic
        objects, build a new one out of them

        &#34;&#34;&#34;

        try:
            self.set(hyp_obj.proj_data,
                     aux_data=hyp_obj.aux_data,
                     dual_data=hyp_obj.dual_data)
            return
        except AttributeError:
            pass

        try:
            unrolled_obj = list(hyp_obj)

            if len(unrolled_obj) == 0:
                raise IndexError

            hyp_array = np.array([obj.proj_data for obj in unrolled_obj])
            aux_array = np.array([obj.aux_data for obj in unrolled_obj])
            dual_array = np.array([obj.dual_data for obj in unrolled_obj])

            if (aux_array == None).any():
                aux_array = None

            if (dual_array == None).any():
                dual_array = None

            self.set(hyp_array, aux_data=aux_array,
                     dual_data=dual_array)
            return

        except (TypeError, AttributeError, IndexError) as e:
            pass

        raise TypeError

    @property
    def shape(self):
        &#34;&#34;&#34;Get the shape of the ndarray of &#34;unit objects&#34; this
        ProjectiveObject represents.

        Returns
        -------
        tuple


        &#34;&#34;&#34;
        return self.proj_data.shape[:-1 * self.unit_ndims]

    def set(self, proj_data, aux_data=None, dual_data=None):
        &#34;&#34;&#34;set the underlying data of the hyperbolic object.

        Subclasses may override this method to give special names to
        portions of the underlying data.

        Parameters
        ----------
        proj_data : ndarray
            underyling data representing this projective object.

        aux_data : ndarray
            underyling auxiliary data for this projective object.

        dual_data : ndarray
            underlying dual data for this projective object.

        &#34;&#34;&#34;

        # TODO: assert dual geometry valid here as well.  Right now we
        # don&#39;t bother because the only dual geometry we&#39;re using is
        # technically also auxilliary...

        proj_data = np.array(proj_data)

        self._assert_geometry_valid(proj_data)
        if aux_data is None:
            aux_data = self._compute_aux_data(proj_data)

        self._assert_aux_valid(aux_data)

        self.proj_data = proj_data
        self.aux_data = aux_data
        self.dual_data = dual_data

    def flatten_to_unit(self, unit=None):
        &#34;&#34;&#34;Get a flattened version of the projective object.

        This method reshapes the underlying data of the projective
        object to get a &#34;flat&#34; composite list of objects. For example,
        if called on a Segment object whose underlying array has shape
        (4, 5, 2, 3), this method uses the `unit_ndims` data member to
        interprets this array as an array of segments with shape
        (4,5), and returns a Segment object whose underlying array has
        shape (20, 2, 3).

        Parameters
        ----------

        unit : int
            the number of ndims to treat as a &#34;unit&#34; when flattening
            this object into units.

        &#34;&#34;&#34;

        aux_unit = unit
        dual_unit = unit
        if unit is None:
            unit = self.unit_ndims
            aux_unit = self.aux_ndims
            dual_unit = self.dual_ndims

        flattened = copy(self)
        new_shape = (-1,) + self.proj_data.shape[-1 * unit:]
        new_proj_data = np.reshape(self.proj_data, new_shape)

        new_aux_data = None
        if self.aux_data is not None:
            new_aux_shape = (-1,) + self.aux_data.shape[-1 * aux_unit:]
            new_aux_data = np.reshape(self.aux_data, new_aux_shape)

        new_dual_data = None
        if self.dual_data is not None:
            new_dual_shape = (-1,) + self.dual_data.shape[-1 * dual_unit:]
            new_dual_data = np.reshape(self.dual_data, new_dual_shape)

        flattened.set(new_proj_data, aux_data=new_aux_data,
                      dual_data=new_dual_data)

        return flattened

    def flatten_to_aux(self):
        return self.flatten_to_unit(self.aux_ndims)

    def __repr__(self):
        return &#34;({}, {})&#34;.format(
            self.__class__,
            self.proj_data.__repr__()
        )

    def __str__(self):
        return &#34;{} with data:\n{}&#34;.format(
            self.__class__.__name__, self.proj_data.__str__()
        )

    def __getitem__(self, item):
        return self.__class__(self.proj_data[item])

    def __setitem__(self, key, value):
        self.proj_data[key] = self.__class__(value).proj_data

    def __len__(self):
        if len(self.proj_data.shape) == self.unit_ndims:
            raise TypeError(&#34;len() of unsized object&#34;)

        return len(self.proj_data)

    def projective_coords(self, proj_data=None):
        &#34;&#34;&#34;Wrapper for ProjectiveObject.set, since underlying coordinates are
        projective.&#34;&#34;&#34;
        if proj_data is not None:
            self.set(proj_data)

        return self.proj_data

    def affine_coords(self, aff_data=None, chart_index=0):
        &#34;&#34;&#34;Get or set affine coordinates for this object.

        Parameters
        ----------
        aff_data : ndarray
            if not `None`, coordinate data for this point in an affine
            chart.

        chart_index : int
            index of standard affine chart to get/set coordinates in

        Returns
        -------
        ndarray
            affine coordinates of this Point, in the specified
            standard affine chart.

        &#34;&#34;&#34;
        if aff_data is not None:
            self.set(projective_coords(aff_data, chart_index=chart_index))

        return affine_coords(self.proj_data, chart_index=chart_index,
                             column_vectors=False)

    @staticmethod
    def _assert_prop_equal(objects, propname):

        if len(objects) == 0:
            return

        properties = np.array([obj.__dict__[propname]
                               for obj in objects])

        if (properties[0] != properties).any():
            raise GeometryError(
                f&#34;{propname} does not match for objects.&#34;
            )


    @classmethod
    def combine(cls, to_combine):
        &#34;&#34;&#34;Construct a new ProjectiveObject of the same type combining the
        data of `self` and `other`.

        Both `self` and `other` will be flattened to unit dimensions
        before combining. If dimensions of the underlying data do not
        match, this will raise an error.

        Parameters
        ----------
        other : ProjectiveObject of the same type as `self`.
            ProjectiveObject to combine with

        Returns
        -------
        ProjectiveObject
            Object of the same type as `self` containing (flattened)
            combined data.

        &#34;&#34;&#34;
        if len(to_combine) == 0:
            return

        cls._assert_prop_equal(to_combine, &#34;unit_ndims&#34;)
        cls._assert_prop_equal(to_combine, &#34;aux_ndims&#34;)
        cls._assert_prop_equal(to_combine, &#34;dual_ndims&#34;)

        unit_ndims = to_combine[0].unit_ndims
        aux_ndims = to_combine[0].aux_ndims
        dual_ndims = to_combine[0].dual_ndims

        flattened_objs = [
            obj.flatten_to_unit()
            for obj in to_combine
        ]

        # first make a generic ProjectiveObject
        new_data = np.concatenate(
            [obj.proj_data for obj in flattened_objs],
            axis=-(unit_ndims+1)
        )
        new_aux = None
        new_dual = None

        if aux_ndims &gt; 0:
            new_data = np.concatenate(
                [obj.aux_data for obj in flattened_objs],
                axis=-(aux_ndims+1)
            )
            new_aux = np.concatenate([flat_self.aux_data, flat_other.aux_data],
                                     axis=-(self.aux_ndims+1))
        if dual_ndims &gt; 0:
            new_data = np.concatenate(
                [obj.dual_data for obj in flattened_objs],
                axis=-(dual_ndims+1)
            )

        newObj = ProjectiveObject(new_data, new_aux, new_dual,
                                  unit_ndims=unit_ndims,
                                  aux_ndims=aux_ndims,
                                  dual_ndims=dual_ndims)

        # construct an object with the correct type from this underlying data
        return cls(newObj)




class Point(ProjectiveObject):
    &#34;&#34;&#34;A point (or collection of points) in projective space.
    &#34;&#34;&#34;

    def __init__(self, point, chart_index=None):
        &#34;&#34;&#34;Parameters
        ----------
        point : ndarray or ProjectiveObject or iterable
            Data to use to construct a Point object. If `point` is an
            `ndarray`, then it is interpreted as data in either
            projective or affine coordinates, depending on whether
            `chart_index` is specified. If `point` is a
            `ProjectiveObject`, then construct a `Point` from the
            underlying data of that object.
        chart_index : int
            if `None` (default), then assume that `point` is data in
            projective coordinates, or a ProjectiveObject. Otherwise,
            interpret `point` as data in affine coordinates, and use
            `chart_index` as the index of the standard affine chart
            those coordinates are in.

        &#34;&#34;&#34;

        self.unit_ndims = 1
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(point)
            return
        except TypeError:
            pass

        if chart_index is None:
            self.projective_coords(point)
        else:
            self.affine_coords(point, chart_index)

    def in_affine_chart(self, index):
        return self.proj_data[..., index] != 0

class PointPair(Point):
    &#34;&#34;&#34;A pair of points (or a composite object consisting of a collection
    of pairs of points) in projective space.

    This is mostly useful as an interface for subclasses which provide
    more involved functionality.
    &#34;&#34;&#34;
    def __init__(self, endpoint1, endpoint2=None):
        &#34;&#34;&#34;If `endpoint2` is `None`, interpret `endpoint1` as either an
        `ndarray` of shape (2, ..., n) (where n is the dimension of
        the underlying vector space), or else a composite `Point`
        object which can be unpacked into two Points (which may
        themselves be composite).

        If `endpoint2` is given, then both `endpoint1` and `endpoint2`
        can be used to construct `Point` objects, which serve as the
        endpoints for this pair of points.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

    &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if endpoint2 is None:
            try:
                self._construct_from_object(endpoint1)
                return
            except (AttributeError, TypeError, GeometryError):
                pass

        self.set_endpoints(endpoint1, endpoint2)

    def set(self, proj_data, **kwargs):
        ProjectiveObject.set(self, proj_data)
        self.endpoints = self.proj_data[..., :2, :]

    def set_endpoints(self, endpoint1, endpoint2=None):
        &#34;&#34;&#34;Set the endpoints of a segment.

        If `endpoint2` is `None`, expect `endpoint1` to be an array of
        points with shape `(..., 2, n)`. Otherwise, expect `endpoint1`
        and `endpoint2` to be arrays of points with the same shape.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

        &#34;&#34;&#34;
        if endpoint2 is None:
            self.set(Point(endpoint1).proj_data)
            return

        pt1 = Point(endpoint1)
        pt2 = Point(endpoint2)
        self.set(np.stack([pt1.proj_data, pt2.proj_data], axis=-2))

    def get_endpoints(self):
        &#34;&#34;&#34;Get a Point representing the endpoints of this pair

        Returns
        -------
        Point
            A composite Point object representing the endpoints of
            this (possibly composite) PointPair

        &#34;&#34;&#34;
        return Point(self.endpoints)

    def get_end_pair(self):
        &#34;&#34;&#34;Return a pair of point objects, one for each endpoint

        Returns
        -------
        tuple
            Tuple of the form `(endpoint1, endpoint2)`, where
            `endpoint1` and `endpoint2` are (possibly composite)
            `Point` objects representing the endpoints of this pair

        &#34;&#34;&#34;
        return (Point(self.endpoints[..., 0, :]),
                Point(self.endpoints[..., 1, :]))

    def endpoint_affine_coords(self, chart_index=0):
        &#34;&#34;&#34;Get endpoints of this segment in affine coordinates

        Parameters
        ----------
        chart_index : int
            Index of the standard affine chart to take coordinates in

        Returns
        -------
        ndarray
            Affine coordinates of the endpoints of this pair of
            points.

        &#34;&#34;&#34;
        return self.get_endpoints().affine_coords(chart_index=chart_index)

    def endpoint_projective_coords(self):
        &#34;&#34;&#34;Get endpoints of this segment in projective coordinates.

        Returns
        -------
        ndarray
            Projective coordinates of the endpoints of this pair of
            points.

        &#34;&#34;&#34;
        return self.get_endpoints().projective_coords()

class Polygon(Point):
    &#34;&#34;&#34;A finite-sided polygon in projective space.
    &#34;&#34;&#34;
    def __init__(self, vertices, aux_data=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        vertices : Point or ndarray
            vertices of the polygon, as either an ndarray or a
            composite Point object (provided in the proper order for
            this polygon).

        aux_data : PointPair or ndarray
            Data to use to construct the edges of the polygon. If
            `None`, use the vertex data to compute the edge data.

        &#34;&#34;&#34;
        ProjectiveObject.__init__(self, vertices, aux_data,
                                  unit_ndims=2, aux_ndims=3)

    def in_standard_chart(self):
        coord_signs = np.sign(self.projective_coords()[..., 0])
        return np.all(coord_signs == 1, axis=-1) | np.all(coord_signs == -1, axis=-1)

    def set(self, proj_data, aux_data=None, dual_data=None):
        ProjectiveObject.set(self, proj_data, aux_data)
        self.vertices = self.proj_data
        self.edges = self.aux_data

    def _compute_aux_data(self, proj_data):
        segments = PointPair(proj_data, np.roll(proj_data, -1, axis=-2))
        return segments.proj_data

    def get_edges(self):
        &#34;&#34;&#34;Get the edges of this polygon

        Returns
        -------
        PointPair
            Edges of this polygon, as a composite PointPair object.

        &#34;&#34;&#34;
        return PointPair(self.edges)

    def get_vertices(self):
        &#34;&#34;&#34;Get the vertices of the polygon.

        Returns
        -------
        Point
            Vertices of this polygon, as a composite Point object.

        &#34;&#34;&#34;
        return Point(self.proj_data)

class ConvexPolygon(Polygon):
    &#34;&#34;&#34;A finite-sided convex polygon in projective space.
    &#34;&#34;&#34;

    def __init__(self, vertices, aux_data=None, dual_data=None):
        r&#34;&#34;&#34;When providing point data for this polygon, non-extreme points
        (i.e. points in the interior of the convex hull) are
        discarded. To determine which points lie in the interior of
        the convex hull, the constructor either:

        - uses the provided `dual_data` to determine an affine
          chart in which the convex polygon lies (this chart is
          the complement of the hyperplane specified in
          `dual_data`), or

        - interprets the projective coordinates of the provided points
          as preferred lifts of those points in \(\mathbb{R}^n\), and
          computes an affine chart containing the projectivization of
          the convex hull of those lifts.

        Parameters
        ----------
        vertices : Point or ndarray
            points contained in this polygon
        aux_data : PointPair or None
            Data to construct the edges of this polygon. If `None`,
            use vertex data to construct edge data.
        dual_data : ProjectiveObject
            Dual vector specifying an affine chart containing every
            point in this convex polygon. If `None`, then compute a
            dual vector using lifts of the vertex data.

    &#34;&#34;&#34;

        ProjectiveObject.__init__(self, vertices, aux_data=aux_data,
                                  dual_data=dual_data, unit_ndims=2,
                                  aux_ndims=3, dual_ndims=1)
    def add_points(self, points, in_place=False):
        &#34;&#34;&#34;Add points to an existing convex polygon.

        Parameters
        ----------
        points : Point or ndarray
            Points to add to the convex polygon. Redundant points
            (lying in the interior of the convex hull) will be
            discarded.
        in_place : bool
            if `True`, modify this convex polygon object in-place
            instead of returning a new one.

        Raises
        ------
        GeometryError
            Raised if points are added to a composite ConvexPolygon
            (currently unsupported)

        Returns
        -------
        ConvexPolygon
            if `in_place` is `False`, return a modified ConvexPolygon
            object with the new points added.

        &#34;&#34;&#34;

        if len(self.proj_data.shape) &gt; 2:
            raise GeometryError(
                &#34;Adding new points to a composite ConvexPolygon object is currently&#34;
                &#34; unsupported.&#34;
            )

        to_add = Point(points)
        new_data = np.concatenate((self.proj_data, to_add.proj_data), axis=-2)

        if in_place:
            self.set(new_data)
            return

        new_poly = ConvexPolygon(new_data)
        return new_poly

    def _convexify(self):
        if len(self.proj_data.shape) &gt; 2:
            raise GeometryError(
                &#34;Cannot auto-convexify a composite ConvexPolygon object.&#34;
            )

        dim = self.proj_data.shape[-1]
        self.dual_data = utils.find_positive_functional(self.proj_data)

        to_std_aff = np.linalg.inv(utils.find_isometry(np.identity(dim),
                                                       self.dual_data))

        standardized_coords = Point(
            self.proj_data @ to_std_aff
        ).affine_coords(chart_index=0)

        vertex_indices = ConvexHull(standardized_coords).vertices

        self.proj_data = self.proj_data[vertex_indices]
        self.aux_data = self._compute_aux_data(self.proj_data)

    def set(self, proj_data, aux_data=None, dual_data=None):
        ProjectiveObject.set(self, proj_data, aux_data, dual_data)
        if dual_data is None:
            self._convexify()

class Transformation(ProjectiveObject):
    &#34;&#34;&#34;A projective transformation (or a composite object consisting of a
    collection of projective transformations).
    &#34;&#34;&#34;
    def __init__(self, proj_data, column_vectors=False):
        &#34;&#34;&#34;By default, the underlying data for a projective
        transformation is a *row matrix* (or an ndarray of row
        matrices), acting on vectors on the *right*.

        Parameters
        ----------
        proj_data : ProjectiveObject or ndarray
            Data to use to construct a projective transformation (or
            array of projective transformations).
        column_vectors : bool
            If `True`, interpret proj_data as a *column matrix* acting
            on the left. Otherwise proj_data gives a *row matrix*.
        &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(proj_data)
        except TypeError:
            if column_vectors:
                self.set(proj_data.swapaxes(-1,-2))
            else:
                self.set(proj_data)

    def _assert_geometry_valid(self, proj_data):
        ProjectiveObject._assert_geometry_valid(self, proj_data)
        if (len(proj_data.shape) &lt; 2 or
            proj_data.shape[-2] != proj_data.shape[-1]):
            raise GeometryError(
                (&#34;Projective transformation must be ndarray of n x n&#34;
                 &#34; matrices, got array with shape {}&#34;).format(
                     proj_data.shape))

    def set(self, proj_data, **kwargs):
        ProjectiveObject.set(self, proj_data)
        self.matrix = proj_data
        self.proj_data = proj_data

    def _apply_to_data(self, proj_data, broadcast, unit_ndims=1, dual=False):
        matrix = self.matrix
        if dual:
            matrix = np.linalg.inv(matrix).swapaxes(-1, -2)
        return utils.matrix_product(proj_data,
                                    matrix,
                                    unit_ndims, self.unit_ndims,
                                    broadcast=broadcast)

    def apply(self, proj_obj, broadcast=&#34;elementwise&#34;):
        &#34;&#34;&#34;Apply this transformation to another object in projective space.

        Parameters
        ----------
        proj_obj : ProjectiveObject or ndarray
            Projective object to apply this transformation to. This object
            may be composite.
        broadcast : string
            Broadcasting behavior for applying composite
            transformation objects. If &#34;elementwise&#34;, then the shape
            of this (composite) transformation object and the shape of
            the (composite) object to apply transformations to need to
            be broadcastable. If &#34;pairwise&#34;, then apply every element
            of this (composite) transformation object to every element
            of the target object (i.e. take an outer product).

        Returns
        -------
        ProjectiveObject
            Transformed (possibly composite) projective object. The
            type of this object is the same type as the original
            (untransformed) object. If the original object was
            provided as an ndarray, then the returned object has type
            ProjectiveObject.

        &#34;&#34;&#34;
        new_obj = copy(proj_obj)

        try:
            proj_data = new_obj.proj_data
            proj_product = self._apply_to_data(new_obj.proj_data, broadcast,
                                               new_obj.unit_ndims)
            aux_data = new_obj.aux_data
            aux_product = None

            if aux_data is not None:
                aux_product = self._apply_to_data(new_obj.aux_data, broadcast,
                                                  new_obj.aux_ndims)

            dual_data = new_obj.dual_data
            dual_product = None
            if dual_data is not None:
                dual_product = self._apply_to_data(new_obj.dual_data, broadcast,
                                                   new_obj.dual_ndims)

            new_obj.set(proj_product,
                        aux_data=aux_product,
                        dual_data=dual_product)

            return new_obj
        except AttributeError:
            pass

        #otherwise, it&#39;s an array of vectors which we&#39;ll interpret as
        #some kind of hyperbolic object
        product = self._apply_to_data(proj_obj, broadcast)
        return self._data_to_object(product)

    def _data_to_object(self, data):
        return ProjectiveObject(data)

    def inv(self):
        &#34;&#34;&#34;Get the inverse of this transformation.

        Returns
        -------
        ProjectiveTransformation
            Inverse of this transformation.
        &#34;&#34;&#34;
        return self.__class__(np.linalg.inv(self.matrix))

    def __matmul__(self, other):
        return self.apply(other)

class ProjectiveRepresentation(representation.Representation):
    &#34;&#34;&#34;A representation (of a free group) lying in PGL(V). Passing words
    (in the generators) to this representation yields `Transformation`
    objects.
    &#34;&#34;&#34;
    def __getitem__(self, word):
        matrix = self._word_value(word)
        return Transformation(matrix, column_vectors=True)

    def __setitem__(self, generator, matrix):
        transform = Transformation(matrix, column_vectors=True)
        representation.Representation.__setitem__(self, generator,
                                                  transform.matrix.T)

    def transformations(self, words):
        &#34;&#34;&#34;Get a composite transformation, representing a sequence of words in
        the generators for this representation.

        Parameters
        ----------
        words : iterable of strings
            Sequence of words to apply this representation to.

        Returns
        -------
        Transformation
            Composite transformation object containing one
            transformation for each word in `words`.

        &#34;&#34;&#34;
        return Transformation(self.elements(words), column_vectors=True)

    def automaton_accepted(self, automaton, length,
                           maxlen=True, with_words=False,
                           start_state=None, end_state=None,
                           precomputed=None):
        result = representation.Representation.automaton_accepted(
            self, automaton, length,
            with_words=with_words,
            start_state=start_state,
            end_state=end_state,
            precomputed=precomputed
        )

        if with_words:
            matrix_array, words = result
        else:
            matrix_array = result

        transformations = Transformation(matrix_array, column_vectors=True)

        if with_words:
            return transformations, words

        return transformations


def hyperplane_coordinate_transform(normal):
    r&#34;&#34;&#34;Find an orthogonal matrix taking the affine chart \(\{\vec{x} :
       \vec{x} \cdot \vec{n} \ne 0\}\) to the standard affine chart
       \(\{\vec{x} = (x_0, \ldots, x_n) : x_0 \ne 0\}\).

    Parameters
    ----------
    normal : array
        The vector \(\vec{n}\), normal to some hyperplane in R^n.

    Returns
    -------
    Transformation
        Projective transformation (orthogonal in the standard inner
        product on R^n) taking the desired affine chart to the
        standard chart with index 0.

    &#34;&#34;&#34;
    mat = utils.find_definite_isometry(normal)
    return Transformation(mat, column_vectors=True).inv()

def affine_coords(points, chart_index=None, column_vectors=False):
    &#34;&#34;&#34;Get affine coordinates for an array of points in projective space
    in one of the standard affine charts.

    Parameters
    ----------
    points: ndarray
        `ndarray` of points in projective space. the last dimension is
        assumed to be the same as the dimension of the underlying
        vector space.

    chart_index: int
        which of the n affine charts to take coordinates in. If
        `None`, determine the chart automatically.

    column_vectors: bool
        if `True`, interpret the second-to-last index as the dimension
        of the underlying vector space.

    Returns
    -------
    ndarray
        If chart_index is specified, return an array of points in
        affine coordinates in that chart. Otherwise, return a tuple
        `(affine, chart_index)`, where `chart_index` is the affine
        chart used.

        If `column_vectors` is `False` (the default), then the last
        index of the returned array is the dimension of the affine
        space. Otherwise, the second-to-last index is the dimension of
        affine space.

    &#34;&#34;&#34;
    apoints = np.array(points)

    if column_vectors:
        apoints = apoints.swapaxes(-1, -2)

    _chart_index = chart_index

    #auto-determine chart
    if chart_index is None:
        _chart_index = np.argmax(
            np.min(np.abs(apoints), axis=tuple(range(len(apoints.shape) - 1)))
        )

    if (apoints[..., _chart_index] == 0).any():
        if chart_index is not None:
            raise GeometryError(
                &#34;points don&#39;t lie in the specified affine chart&#34;
            )
        else:
            raise GeometryError(
                &#34;points don&#39;t lie in any standard affine chart&#34;
            )

    affine = np.delete(
        (apoints.T / apoints.T[_chart_index]).T,
        _chart_index, axis=-1
    )

    if column_vectors:
        affine = affine.swapaxes(-1, -2)

    if chart_index is None:
        return (affine, _chart_index)
    else:
        return affine

def projective_coords(points, chart_index=0, column_vectors=False):
    &#34;&#34;&#34;Get projective coordinates for points in affine space

    Parameters
    ----------
    points : ndarray or sequence
        Points in affine coordinates. The last dimension of the array
        is the dimension of affine space.

    chart_index: int
        Index of the affine chart we assume these points are lying in

    column_vectors: bool
        If `True`, interpret the second-to-last index as the dimension
        of affine space.

    Returns
    -------
    ndarray
        Projective coordinates of the given points. The last dimension
        of the array is the dimension of the underlying vector space
        (or the second-to-last dimension, if `column_vectors` is
        `True`).

    &#34;&#34;&#34;
    coords = np.array(points)

    if column_vectors:
        coords = coords.swapaxes(-1, -2)

    result = np.zeros(coords.shape[:-1] + (coords.shape[-1] + 1,),
                      dtype=coords.dtype)

    indices = np.arange(coords.shape[-1])
    indices[chart_index:] += 1

    result[..., indices] = coords
    result[..., chart_index] = 1.

    if column_vectors:
        result = result.swapaxes(-1, -2)

    return result

def identity(dimension):
    &#34;&#34;&#34;Get the identity projective transformation.

    Parameters
    ----------
    dimension : int
        Dimension of the projective space to act on.

    Returns
    -------
    Transformation
        The identity map on RP^n, where n = `dimension`.

    &#34;&#34;&#34;

    return Transformation(np.identity(dimension + 1))

def affine_linear_map(linear_map, chart_index=0, column_vectors=True):
    &#34;&#34;&#34;Get a projective transformation restricting to a linear map on a
       standard affine chart.

    Parameters
    ----------
    linear_map : ndarray
        A linear map giving an affine transformation on a standard
        affine chart

    chart_index : int
        Index of the standard affine chart where this projective
        transformation acts

    column_vectors :
        It `True`, interpret `linear_map` as a matrix acting on column
        vectors (on the left). Otherwise, `linear_map` acts on row
        vectors (on the right).

    Returns
    -------
    Transformation
        Projective transformation preserving a standard affine chart
        and acting by a linear map on that affine space (i.e. fixing a
        point in that affine space).

    &#34;&#34;&#34;
    h, w = linear_map.shape

    tf_mat = np.block(
        [[linear_map[:chart_index, :chart_index],
          np.zeros((chart_index, 1)), linear_map[:chart_index, chart_index:]],
         [np.zeros((1, chart_index)), 1., np.zeros((1, w - chart_index))],
         [linear_map[chart_index:, :chart_index],
          np.zeros((h - chart_index, 1)), linear_map[chart_index:, chart_index:]]])

    return Transformation(tf_mat, column_vectors=column_vectors)

def affine_translation(translation, chart_index=0):
    &#34;&#34;&#34;Get a translation in a standard affine chart.

    Parameters
    ----------
    translation : ndarray
        vector to translate along in affine space
    chart_index : int
        index of the standard affine chart this translation acts on

    Returns
    -------
    Transformation
        Projective transformation preserving a standard affine chart
        and acting by an affine translation in that affine space.

    &#34;&#34;&#34;
    tf = np.identity(len(translation) + 1)
    tf[chart_index, :chart_index] = translation[:chart_index]
    tf[chart_index, chart_index + 1:] = translation[chart_index:]

    return Transformation(tf, column_vectors=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geometry_tools.projective.affine_coords"><code class="name flex">
<span>def <span class="ident">affine_coords</span></span>(<span>points, chart_index=None, column_vectors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get affine coordinates for an array of points in projective space
in one of the standard affine charts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>ndarray</code></dt>
<dd><code>ndarray</code> of points in projective space. the last dimension is
assumed to be the same as the dimension of the underlying
vector space.</dd>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>which of the n affine charts to take coordinates in. If
<code>None</code>, determine the chart automatically.</dd>
<dt><strong><code>column_vectors</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, interpret the second-to-last index as the dimension
of the underlying vector space.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>
<p>If chart_index is specified, return an array of points in
affine coordinates in that chart. Otherwise, return a tuple
<code>(affine, chart_index)</code>, where <code>chart_index</code> is the affine
chart used.</p>
<p>If <code>column_vectors</code> is <code>False</code> (the default), then the last
index of the returned array is the dimension of the affine
space. Otherwise, the second-to-last index is the dimension of
affine space.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_coords(points, chart_index=None, column_vectors=False):
    &#34;&#34;&#34;Get affine coordinates for an array of points in projective space
    in one of the standard affine charts.

    Parameters
    ----------
    points: ndarray
        `ndarray` of points in projective space. the last dimension is
        assumed to be the same as the dimension of the underlying
        vector space.

    chart_index: int
        which of the n affine charts to take coordinates in. If
        `None`, determine the chart automatically.

    column_vectors: bool
        if `True`, interpret the second-to-last index as the dimension
        of the underlying vector space.

    Returns
    -------
    ndarray
        If chart_index is specified, return an array of points in
        affine coordinates in that chart. Otherwise, return a tuple
        `(affine, chart_index)`, where `chart_index` is the affine
        chart used.

        If `column_vectors` is `False` (the default), then the last
        index of the returned array is the dimension of the affine
        space. Otherwise, the second-to-last index is the dimension of
        affine space.

    &#34;&#34;&#34;
    apoints = np.array(points)

    if column_vectors:
        apoints = apoints.swapaxes(-1, -2)

    _chart_index = chart_index

    #auto-determine chart
    if chart_index is None:
        _chart_index = np.argmax(
            np.min(np.abs(apoints), axis=tuple(range(len(apoints.shape) - 1)))
        )

    if (apoints[..., _chart_index] == 0).any():
        if chart_index is not None:
            raise GeometryError(
                &#34;points don&#39;t lie in the specified affine chart&#34;
            )
        else:
            raise GeometryError(
                &#34;points don&#39;t lie in any standard affine chart&#34;
            )

    affine = np.delete(
        (apoints.T / apoints.T[_chart_index]).T,
        _chart_index, axis=-1
    )

    if column_vectors:
        affine = affine.swapaxes(-1, -2)

    if chart_index is None:
        return (affine, _chart_index)
    else:
        return affine</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.affine_linear_map"><code class="name flex">
<span>def <span class="ident">affine_linear_map</span></span>(<span>linear_map, chart_index=0, column_vectors=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a projective transformation restricting to a linear map on a
standard affine chart.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>linear_map</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>A linear map giving an affine transformation on a standard
affine chart</dd>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the standard affine chart where this projective
transformation acts</dd>
</dl>
<p>column_vectors :
It <code>True</code>, interpret <code>linear_map</code> as a matrix acting on column
vectors (on the left). Otherwise, <code>linear_map</code> acts on row
vectors (on the right).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code></dt>
<dd>Projective transformation preserving a standard affine chart
and acting by a linear map on that affine space (i.e. fixing a
point in that affine space).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_linear_map(linear_map, chart_index=0, column_vectors=True):
    &#34;&#34;&#34;Get a projective transformation restricting to a linear map on a
       standard affine chart.

    Parameters
    ----------
    linear_map : ndarray
        A linear map giving an affine transformation on a standard
        affine chart

    chart_index : int
        Index of the standard affine chart where this projective
        transformation acts

    column_vectors :
        It `True`, interpret `linear_map` as a matrix acting on column
        vectors (on the left). Otherwise, `linear_map` acts on row
        vectors (on the right).

    Returns
    -------
    Transformation
        Projective transformation preserving a standard affine chart
        and acting by a linear map on that affine space (i.e. fixing a
        point in that affine space).

    &#34;&#34;&#34;
    h, w = linear_map.shape

    tf_mat = np.block(
        [[linear_map[:chart_index, :chart_index],
          np.zeros((chart_index, 1)), linear_map[:chart_index, chart_index:]],
         [np.zeros((1, chart_index)), 1., np.zeros((1, w - chart_index))],
         [linear_map[chart_index:, :chart_index],
          np.zeros((h - chart_index, 1)), linear_map[chart_index:, chart_index:]]])

    return Transformation(tf_mat, column_vectors=column_vectors)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.affine_translation"><code class="name flex">
<span>def <span class="ident">affine_translation</span></span>(<span>translation, chart_index=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a translation in a standard affine chart.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>translation</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>vector to translate along in affine space</dd>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the standard affine chart this translation acts on</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code></dt>
<dd>Projective transformation preserving a standard affine chart
and acting by an affine translation in that affine space.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_translation(translation, chart_index=0):
    &#34;&#34;&#34;Get a translation in a standard affine chart.

    Parameters
    ----------
    translation : ndarray
        vector to translate along in affine space
    chart_index : int
        index of the standard affine chart this translation acts on

    Returns
    -------
    Transformation
        Projective transformation preserving a standard affine chart
        and acting by an affine translation in that affine space.

    &#34;&#34;&#34;
    tf = np.identity(len(translation) + 1)
    tf[chart_index, :chart_index] = translation[:chart_index]
    tf[chart_index, chart_index + 1:] = translation[chart_index:]

    return Transformation(tf, column_vectors=False)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.hyperplane_coordinate_transform"><code class="name flex">
<span>def <span class="ident">hyperplane_coordinate_transform</span></span>(<span>normal)</span>
</code></dt>
<dd>
<div class="desc"><p>Find an orthogonal matrix taking the affine chart <span><span class="MathJax_Preview">\{\vec{x} :
\vec{x} \cdot \vec{n} \ne 0\}</span><script type="math/tex">\{\vec{x} :
\vec{x} \cdot \vec{n} \ne 0\}</script></span> to the standard affine chart
<span><span class="MathJax_Preview">\{\vec{x} = (x_0, \ldots, x_n) : x_0 \ne 0\}</span><script type="math/tex">\{\vec{x} = (x_0, \ldots, x_n) : x_0 \ne 0\}</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>normal</code></strong> :&ensp;<code>array</code></dt>
<dd>The vector <span><span class="MathJax_Preview">\vec{n}</span><script type="math/tex">\vec{n}</script></span>, normal to some hyperplane in R^n.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code></dt>
<dd>Projective transformation (orthogonal in the standard inner
product on R^n) taking the desired affine chart to the
standard chart with index 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperplane_coordinate_transform(normal):
    r&#34;&#34;&#34;Find an orthogonal matrix taking the affine chart \(\{\vec{x} :
       \vec{x} \cdot \vec{n} \ne 0\}\) to the standard affine chart
       \(\{\vec{x} = (x_0, \ldots, x_n) : x_0 \ne 0\}\).

    Parameters
    ----------
    normal : array
        The vector \(\vec{n}\), normal to some hyperplane in R^n.

    Returns
    -------
    Transformation
        Projective transformation (orthogonal in the standard inner
        product on R^n) taking the desired affine chart to the
        standard chart with index 0.

    &#34;&#34;&#34;
    mat = utils.find_definite_isometry(normal)
    return Transformation(mat, column_vectors=True).inv()</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.identity"><code class="name flex">
<span>def <span class="ident">identity</span></span>(<span>dimension)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the identity projective transformation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dimension</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of the projective space to act on.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code></dt>
<dd>The identity map on RP^n, where n = <code>dimension</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identity(dimension):
    &#34;&#34;&#34;Get the identity projective transformation.

    Parameters
    ----------
    dimension : int
        Dimension of the projective space to act on.

    Returns
    -------
    Transformation
        The identity map on RP^n, where n = `dimension`.

    &#34;&#34;&#34;

    return Transformation(np.identity(dimension + 1))</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.projective_coords"><code class="name flex">
<span>def <span class="ident">projective_coords</span></span>(<span>points, chart_index=0, column_vectors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get projective coordinates for points in affine space</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>ndarray</code> or <code>sequence</code></dt>
<dd>Points in affine coordinates. The last dimension of the array
is the dimension of affine space.</dd>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the affine chart we assume these points are lying in</dd>
<dt><strong><code>column_vectors</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, interpret the second-to-last index as the dimension
of affine space.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Projective coordinates of the given points. The last dimension
of the array is the dimension of the underlying vector space
(or the second-to-last dimension, if <code>column_vectors</code> is
<code>True</code>).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projective_coords(points, chart_index=0, column_vectors=False):
    &#34;&#34;&#34;Get projective coordinates for points in affine space

    Parameters
    ----------
    points : ndarray or sequence
        Points in affine coordinates. The last dimension of the array
        is the dimension of affine space.

    chart_index: int
        Index of the affine chart we assume these points are lying in

    column_vectors: bool
        If `True`, interpret the second-to-last index as the dimension
        of affine space.

    Returns
    -------
    ndarray
        Projective coordinates of the given points. The last dimension
        of the array is the dimension of the underlying vector space
        (or the second-to-last dimension, if `column_vectors` is
        `True`).

    &#34;&#34;&#34;
    coords = np.array(points)

    if column_vectors:
        coords = coords.swapaxes(-1, -2)

    result = np.zeros(coords.shape[:-1] + (coords.shape[-1] + 1,),
                      dtype=coords.dtype)

    indices = np.arange(coords.shape[-1])
    indices[chart_index:] += 1

    result[..., indices] = coords
    result[..., chart_index] = 1.

    if column_vectors:
        result = result.swapaxes(-1, -2)

    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geometry_tools.projective.ConvexPolygon"><code class="flex name class">
<span>class <span class="ident">ConvexPolygon</span></span>
<span>(</span><span>vertices, aux_data=None, dual_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A finite-sided convex polygon in projective space.</p>
<p>When providing point data for this polygon, non-extreme points
(i.e. points in the interior of the convex hull) are
discarded. To determine which points lie in the interior of
the convex hull, the constructor either:</p>
<ul>
<li>
<p>uses the provided <code>dual_data</code> to determine an affine
chart in which the convex polygon lies (this chart is
the complement of the hyperplane specified in
<code>dual_data</code>), or</p>
</li>
<li>
<p>interprets the projective coordinates of the provided points
as preferred lifts of those points in <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>, and
computes an affine chart containing the projectivization of
the convex hull of those lifts.</p>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vertices</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>points contained in this polygon</dd>
<dt><strong><code>aux_data</code></strong> :&ensp;<code><a title="geometry_tools.projective.PointPair" href="#geometry_tools.projective.PointPair">PointPair</a></code> or <code>None</code></dt>
<dd>Data to construct the edges of this polygon. If <code>None</code>,
use vertex data to construct edge data.</dd>
<dt><strong><code>dual_data</code></strong> :&ensp;<code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code></dt>
<dd>Dual vector specifying an affine chart containing every
point in this convex polygon. If <code>None</code>, then compute a
dual vector using lifts of the vertex data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvexPolygon(Polygon):
    &#34;&#34;&#34;A finite-sided convex polygon in projective space.
    &#34;&#34;&#34;

    def __init__(self, vertices, aux_data=None, dual_data=None):
        r&#34;&#34;&#34;When providing point data for this polygon, non-extreme points
        (i.e. points in the interior of the convex hull) are
        discarded. To determine which points lie in the interior of
        the convex hull, the constructor either:

        - uses the provided `dual_data` to determine an affine
          chart in which the convex polygon lies (this chart is
          the complement of the hyperplane specified in
          `dual_data`), or

        - interprets the projective coordinates of the provided points
          as preferred lifts of those points in \(\mathbb{R}^n\), and
          computes an affine chart containing the projectivization of
          the convex hull of those lifts.

        Parameters
        ----------
        vertices : Point or ndarray
            points contained in this polygon
        aux_data : PointPair or None
            Data to construct the edges of this polygon. If `None`,
            use vertex data to construct edge data.
        dual_data : ProjectiveObject
            Dual vector specifying an affine chart containing every
            point in this convex polygon. If `None`, then compute a
            dual vector using lifts of the vertex data.

    &#34;&#34;&#34;

        ProjectiveObject.__init__(self, vertices, aux_data=aux_data,
                                  dual_data=dual_data, unit_ndims=2,
                                  aux_ndims=3, dual_ndims=1)
    def add_points(self, points, in_place=False):
        &#34;&#34;&#34;Add points to an existing convex polygon.

        Parameters
        ----------
        points : Point or ndarray
            Points to add to the convex polygon. Redundant points
            (lying in the interior of the convex hull) will be
            discarded.
        in_place : bool
            if `True`, modify this convex polygon object in-place
            instead of returning a new one.

        Raises
        ------
        GeometryError
            Raised if points are added to a composite ConvexPolygon
            (currently unsupported)

        Returns
        -------
        ConvexPolygon
            if `in_place` is `False`, return a modified ConvexPolygon
            object with the new points added.

        &#34;&#34;&#34;

        if len(self.proj_data.shape) &gt; 2:
            raise GeometryError(
                &#34;Adding new points to a composite ConvexPolygon object is currently&#34;
                &#34; unsupported.&#34;
            )

        to_add = Point(points)
        new_data = np.concatenate((self.proj_data, to_add.proj_data), axis=-2)

        if in_place:
            self.set(new_data)
            return

        new_poly = ConvexPolygon(new_data)
        return new_poly

    def _convexify(self):
        if len(self.proj_data.shape) &gt; 2:
            raise GeometryError(
                &#34;Cannot auto-convexify a composite ConvexPolygon object.&#34;
            )

        dim = self.proj_data.shape[-1]
        self.dual_data = utils.find_positive_functional(self.proj_data)

        to_std_aff = np.linalg.inv(utils.find_isometry(np.identity(dim),
                                                       self.dual_data))

        standardized_coords = Point(
            self.proj_data @ to_std_aff
        ).affine_coords(chart_index=0)

        vertex_indices = ConvexHull(standardized_coords).vertices

        self.proj_data = self.proj_data[vertex_indices]
        self.aux_data = self._compute_aux_data(self.proj_data)

    def set(self, proj_data, aux_data=None, dual_data=None):
        ProjectiveObject.set(self, proj_data, aux_data, dual_data)
        if dual_data is None:
            self._convexify()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></li>
<li><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.ConvexPolygon.add_points"><code class="name flex">
<span>def <span class="ident">add_points</span></span>(<span>self, points, in_place=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add points to an existing convex polygon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>Points to add to the convex polygon. Redundant points
(lying in the interior of the convex hull) will be
discarded.</dd>
<dt><strong><code>in_place</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, modify this convex polygon object in-place
instead of returning a new one.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="geometry_tools.projective.GeometryError" href="#geometry_tools.projective.GeometryError">GeometryError</a></code></dt>
<dd>Raised if points are added to a composite ConvexPolygon
(currently unsupported)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.ConvexPolygon" href="#geometry_tools.projective.ConvexPolygon">ConvexPolygon</a></code></dt>
<dd>if <code>in_place</code> is <code>False</code>, return a modified ConvexPolygon
object with the new points added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_points(self, points, in_place=False):
    &#34;&#34;&#34;Add points to an existing convex polygon.

    Parameters
    ----------
    points : Point or ndarray
        Points to add to the convex polygon. Redundant points
        (lying in the interior of the convex hull) will be
        discarded.
    in_place : bool
        if `True`, modify this convex polygon object in-place
        instead of returning a new one.

    Raises
    ------
    GeometryError
        Raised if points are added to a composite ConvexPolygon
        (currently unsupported)

    Returns
    -------
    ConvexPolygon
        if `in_place` is `False`, return a modified ConvexPolygon
        object with the new points added.

    &#34;&#34;&#34;

    if len(self.proj_data.shape) &gt; 2:
        raise GeometryError(
            &#34;Adding new points to a composite ConvexPolygon object is currently&#34;
            &#34; unsupported.&#34;
        )

    to_add = Point(points)
    new_data = np.concatenate((self.proj_data, to_add.proj_data), axis=-2)

    if in_place:
        self.set(new_data)
        return

    new_poly = ConvexPolygon(new_data)
    return new_poly</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.Polygon.affine_coords" href="#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.combine" href="#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.flatten_to_unit" href="#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.get_edges" href="#geometry_tools.projective.Polygon.get_edges">get_edges</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.get_vertices" href="#geometry_tools.projective.Polygon.get_vertices">get_vertices</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.projective_coords" href="#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.set" href="#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.shape" href="#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.projective.GeometryError"><code class="flex name class">
<span>class <span class="ident">GeometryError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Thrown if there's an attempt to construct a geometric object with
numerical data that doesn't make sense for that type of object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeometryError(Exception):
    &#34;&#34;&#34;Thrown if there&#39;s an attempt to construct a geometric object with
    numerical data that doesn&#39;t make sense for that type of object.

    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="geometry_tools.projective.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>point, chart_index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A point (or collection of points) in projective space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>point</code></strong> :&ensp;<code>ndarray</code> or <code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code> or <code>iterable</code></dt>
<dd>Data to use to construct a Point object. If <code>point</code> is an
<code>ndarray</code>, then it is interpreted as data in either
projective or affine coordinates, depending on whether
<code>chart_index</code> is specified. If <code>point</code> is a
<code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code>, then construct a <code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> from the
underlying data of that object.</dd>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>if <code>None</code> (default), then assume that <code>point</code> is data in
projective coordinates, or a ProjectiveObject. Otherwise,
interpret <code>point</code> as data in affine coordinates, and use
<code>chart_index</code> as the index of the standard affine chart
those coordinates are in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(ProjectiveObject):
    &#34;&#34;&#34;A point (or collection of points) in projective space.
    &#34;&#34;&#34;

    def __init__(self, point, chart_index=None):
        &#34;&#34;&#34;Parameters
        ----------
        point : ndarray or ProjectiveObject or iterable
            Data to use to construct a Point object. If `point` is an
            `ndarray`, then it is interpreted as data in either
            projective or affine coordinates, depending on whether
            `chart_index` is specified. If `point` is a
            `ProjectiveObject`, then construct a `Point` from the
            underlying data of that object.
        chart_index : int
            if `None` (default), then assume that `point` is data in
            projective coordinates, or a ProjectiveObject. Otherwise,
            interpret `point` as data in affine coordinates, and use
            `chart_index` as the index of the standard affine chart
            those coordinates are in.

        &#34;&#34;&#34;

        self.unit_ndims = 1
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(point)
            return
        except TypeError:
            pass

        if chart_index is None:
            self.projective_coords(point)
        else:
            self.affine_coords(point, chart_index)

    def in_affine_chart(self, index):
        return self.proj_data[..., index] != 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.complex_projective.CP1Point" href="complex_projective.html#geometry_tools.complex_projective.CP1Point">CP1Point</a></li>
<li><a title="geometry_tools.hyperbolic.Point" href="hyperbolic.html#geometry_tools.hyperbolic.Point">Point</a></li>
<li><a title="geometry_tools.projective.PointPair" href="#geometry_tools.projective.PointPair">PointPair</a></li>
<li><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.Point.in_affine_chart"><code class="name flex">
<span>def <span class="ident">in_affine_chart</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_affine_chart(self, index):
    return self.proj_data[..., index] != 0</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.ProjectiveObject.affine_coords" href="#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.combine" href="#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.flatten_to_unit" href="#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.projective_coords" href="#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.set" href="#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.shape" href="#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.projective.PointPair"><code class="flex name class">
<span>class <span class="ident">PointPair</span></span>
<span>(</span><span>endpoint1, endpoint2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A pair of points (or a composite object consisting of a collection
of pairs of points) in projective space.</p>
<p>This is mostly useful as an interface for subclasses which provide
more involved functionality.</p>
<p>If <code>endpoint2</code> is <code>None</code>, interpret <code>endpoint1</code> as either an
<code>ndarray</code> of shape (2, &hellip;, n) (where n is the dimension of
the underlying vector space), or else a composite <code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code>
object which can be unpacked into two Points (which may
themselves be composite).</p>
<p>If <code>endpoint2</code> is given, then both <code>endpoint1</code> and <code>endpoint2</code>
can be used to construct <code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> objects, which serve as the
endpoints for this pair of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>endpoint1</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>One (or both) endpoints of the point pair</dd>
<dt><strong><code>endpoint2</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The other endpoint of the point pair. If <code>None</code>,
<code>endpoint1</code> contains the data for both points in the pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PointPair(Point):
    &#34;&#34;&#34;A pair of points (or a composite object consisting of a collection
    of pairs of points) in projective space.

    This is mostly useful as an interface for subclasses which provide
    more involved functionality.
    &#34;&#34;&#34;
    def __init__(self, endpoint1, endpoint2=None):
        &#34;&#34;&#34;If `endpoint2` is `None`, interpret `endpoint1` as either an
        `ndarray` of shape (2, ..., n) (where n is the dimension of
        the underlying vector space), or else a composite `Point`
        object which can be unpacked into two Points (which may
        themselves be composite).

        If `endpoint2` is given, then both `endpoint1` and `endpoint2`
        can be used to construct `Point` objects, which serve as the
        endpoints for this pair of points.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

    &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        if endpoint2 is None:
            try:
                self._construct_from_object(endpoint1)
                return
            except (AttributeError, TypeError, GeometryError):
                pass

        self.set_endpoints(endpoint1, endpoint2)

    def set(self, proj_data, **kwargs):
        ProjectiveObject.set(self, proj_data)
        self.endpoints = self.proj_data[..., :2, :]

    def set_endpoints(self, endpoint1, endpoint2=None):
        &#34;&#34;&#34;Set the endpoints of a segment.

        If `endpoint2` is `None`, expect `endpoint1` to be an array of
        points with shape `(..., 2, n)`. Otherwise, expect `endpoint1`
        and `endpoint2` to be arrays of points with the same shape.

        Parameters
        ----------
        endpoint1 : Point or ndarray
            One (or both) endpoints of the point pair
        endpoint2 : Point or ndarray
            The other endpoint of the point pair. If `None`,
            `endpoint1` contains the data for both points in the pair.

        &#34;&#34;&#34;
        if endpoint2 is None:
            self.set(Point(endpoint1).proj_data)
            return

        pt1 = Point(endpoint1)
        pt2 = Point(endpoint2)
        self.set(np.stack([pt1.proj_data, pt2.proj_data], axis=-2))

    def get_endpoints(self):
        &#34;&#34;&#34;Get a Point representing the endpoints of this pair

        Returns
        -------
        Point
            A composite Point object representing the endpoints of
            this (possibly composite) PointPair

        &#34;&#34;&#34;
        return Point(self.endpoints)

    def get_end_pair(self):
        &#34;&#34;&#34;Return a pair of point objects, one for each endpoint

        Returns
        -------
        tuple
            Tuple of the form `(endpoint1, endpoint2)`, where
            `endpoint1` and `endpoint2` are (possibly composite)
            `Point` objects representing the endpoints of this pair

        &#34;&#34;&#34;
        return (Point(self.endpoints[..., 0, :]),
                Point(self.endpoints[..., 1, :]))

    def endpoint_affine_coords(self, chart_index=0):
        &#34;&#34;&#34;Get endpoints of this segment in affine coordinates

        Parameters
        ----------
        chart_index : int
            Index of the standard affine chart to take coordinates in

        Returns
        -------
        ndarray
            Affine coordinates of the endpoints of this pair of
            points.

        &#34;&#34;&#34;
        return self.get_endpoints().affine_coords(chart_index=chart_index)

    def endpoint_projective_coords(self):
        &#34;&#34;&#34;Get endpoints of this segment in projective coordinates.

        Returns
        -------
        ndarray
            Projective coordinates of the endpoints of this pair of
            points.

        &#34;&#34;&#34;
        return self.get_endpoints().projective_coords()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.PointPair" href="hyperbolic.html#geometry_tools.hyperbolic.PointPair">PointPair</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.PointPair.endpoint_affine_coords"><code class="name flex">
<span>def <span class="ident">endpoint_affine_coords</span></span>(<span>self, chart_index=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get endpoints of this segment in affine coordinates</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the standard affine chart to take coordinates in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Affine coordinates of the endpoints of this pair of
points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endpoint_affine_coords(self, chart_index=0):
    &#34;&#34;&#34;Get endpoints of this segment in affine coordinates

    Parameters
    ----------
    chart_index : int
        Index of the standard affine chart to take coordinates in

    Returns
    -------
    ndarray
        Affine coordinates of the endpoints of this pair of
        points.

    &#34;&#34;&#34;
    return self.get_endpoints().affine_coords(chart_index=chart_index)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.PointPair.endpoint_projective_coords"><code class="name flex">
<span>def <span class="ident">endpoint_projective_coords</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get endpoints of this segment in projective coordinates.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Projective coordinates of the endpoints of this pair of
points.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endpoint_projective_coords(self):
    &#34;&#34;&#34;Get endpoints of this segment in projective coordinates.

    Returns
    -------
    ndarray
        Projective coordinates of the endpoints of this pair of
        points.

    &#34;&#34;&#34;
    return self.get_endpoints().projective_coords()</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.PointPair.get_end_pair"><code class="name flex">
<span>def <span class="ident">get_end_pair</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a pair of point objects, one for each endpoint</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple of the form <code>(endpoint1, endpoint2)</code>, where
<code>endpoint1</code> and <code>endpoint2</code> are (possibly composite)
<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> objects representing the endpoints of this pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_end_pair(self):
    &#34;&#34;&#34;Return a pair of point objects, one for each endpoint

    Returns
    -------
    tuple
        Tuple of the form `(endpoint1, endpoint2)`, where
        `endpoint1` and `endpoint2` are (possibly composite)
        `Point` objects representing the endpoints of this pair

    &#34;&#34;&#34;
    return (Point(self.endpoints[..., 0, :]),
            Point(self.endpoints[..., 1, :]))</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.PointPair.get_endpoints"><code class="name flex">
<span>def <span class="ident">get_endpoints</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a Point representing the endpoints of this pair</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code></dt>
<dd>A composite Point object representing the endpoints of
this (possibly composite) PointPair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_endpoints(self):
    &#34;&#34;&#34;Get a Point representing the endpoints of this pair

    Returns
    -------
    Point
        A composite Point object representing the endpoints of
        this (possibly composite) PointPair

    &#34;&#34;&#34;
    return Point(self.endpoints)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.PointPair.set_endpoints"><code class="name flex">
<span>def <span class="ident">set_endpoints</span></span>(<span>self, endpoint1, endpoint2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the endpoints of a segment.</p>
<p>If <code>endpoint2</code> is <code>None</code>, expect <code>endpoint1</code> to be an array of
points with shape <code>(&hellip;, 2, n)</code>. Otherwise, expect <code>endpoint1</code>
and <code>endpoint2</code> to be arrays of points with the same shape.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>endpoint1</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>One (or both) endpoints of the point pair</dd>
<dt><strong><code>endpoint2</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>The other endpoint of the point pair. If <code>None</code>,
<code>endpoint1</code> contains the data for both points in the pair.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_endpoints(self, endpoint1, endpoint2=None):
    &#34;&#34;&#34;Set the endpoints of a segment.

    If `endpoint2` is `None`, expect `endpoint1` to be an array of
    points with shape `(..., 2, n)`. Otherwise, expect `endpoint1`
    and `endpoint2` to be arrays of points with the same shape.

    Parameters
    ----------
    endpoint1 : Point or ndarray
        One (or both) endpoints of the point pair
    endpoint2 : Point or ndarray
        The other endpoint of the point pair. If `None`,
        `endpoint1` contains the data for both points in the pair.

    &#34;&#34;&#34;
    if endpoint2 is None:
        self.set(Point(endpoint1).proj_data)
        return

    pt1 = Point(endpoint1)
    pt2 = Point(endpoint2)
    self.set(np.stack([pt1.proj_data, pt2.proj_data], axis=-2))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.Point.affine_coords" href="#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Point.combine" href="#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.Point.flatten_to_unit" href="#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.Point.projective_coords" href="#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Point.set" href="#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.Point.shape" href="#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.projective.Polygon"><code class="flex name class">
<span>class <span class="ident">Polygon</span></span>
<span>(</span><span>vertices, aux_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A finite-sided polygon in projective space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vertices</code></strong> :&ensp;<code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code> or <code>ndarray</code></dt>
<dd>vertices of the polygon, as either an ndarray or a
composite Point object (provided in the proper order for
this polygon).</dd>
<dt><strong><code>aux_data</code></strong> :&ensp;<code><a title="geometry_tools.projective.PointPair" href="#geometry_tools.projective.PointPair">PointPair</a></code> or <code>ndarray</code></dt>
<dd>Data to use to construct the edges of the polygon. If
<code>None</code>, use the vertex data to compute the edge data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polygon(Point):
    &#34;&#34;&#34;A finite-sided polygon in projective space.
    &#34;&#34;&#34;
    def __init__(self, vertices, aux_data=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        vertices : Point or ndarray
            vertices of the polygon, as either an ndarray or a
            composite Point object (provided in the proper order for
            this polygon).

        aux_data : PointPair or ndarray
            Data to use to construct the edges of the polygon. If
            `None`, use the vertex data to compute the edge data.

        &#34;&#34;&#34;
        ProjectiveObject.__init__(self, vertices, aux_data,
                                  unit_ndims=2, aux_ndims=3)

    def in_standard_chart(self):
        coord_signs = np.sign(self.projective_coords()[..., 0])
        return np.all(coord_signs == 1, axis=-1) | np.all(coord_signs == -1, axis=-1)

    def set(self, proj_data, aux_data=None, dual_data=None):
        ProjectiveObject.set(self, proj_data, aux_data)
        self.vertices = self.proj_data
        self.edges = self.aux_data

    def _compute_aux_data(self, proj_data):
        segments = PointPair(proj_data, np.roll(proj_data, -1, axis=-2))
        return segments.proj_data

    def get_edges(self):
        &#34;&#34;&#34;Get the edges of this polygon

        Returns
        -------
        PointPair
            Edges of this polygon, as a composite PointPair object.

        &#34;&#34;&#34;
        return PointPair(self.edges)

    def get_vertices(self):
        &#34;&#34;&#34;Get the vertices of the polygon.

        Returns
        -------
        Point
            Vertices of this polygon, as a composite Point object.

        &#34;&#34;&#34;
        return Point(self.proj_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Polygon" href="hyperbolic.html#geometry_tools.hyperbolic.Polygon">Polygon</a></li>
<li><a title="geometry_tools.projective.ConvexPolygon" href="#geometry_tools.projective.ConvexPolygon">ConvexPolygon</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.Polygon.get_edges"><code class="name flex">
<span>def <span class="ident">get_edges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the edges of this polygon</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.PointPair" href="#geometry_tools.projective.PointPair">PointPair</a></code></dt>
<dd>Edges of this polygon, as a composite PointPair object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_edges(self):
    &#34;&#34;&#34;Get the edges of this polygon

    Returns
    -------
    PointPair
        Edges of this polygon, as a composite PointPair object.

    &#34;&#34;&#34;
    return PointPair(self.edges)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.Polygon.get_vertices"><code class="name flex">
<span>def <span class="ident">get_vertices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the vertices of the polygon.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code></dt>
<dd>Vertices of this polygon, as a composite Point object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertices(self):
    &#34;&#34;&#34;Get the vertices of the polygon.

    Returns
    -------
    Point
        Vertices of this polygon, as a composite Point object.

    &#34;&#34;&#34;
    return Point(self.proj_data)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.Polygon.in_standard_chart"><code class="name flex">
<span>def <span class="ident">in_standard_chart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_standard_chart(self):
    coord_signs = np.sign(self.projective_coords()[..., 0])
    return np.all(coord_signs == 1, axis=-1) | np.all(coord_signs == -1, axis=-1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.Point.affine_coords" href="#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Point.combine" href="#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.Point.flatten_to_unit" href="#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.Point.projective_coords" href="#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.Point.set" href="#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.Point.shape" href="#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.projective.ProjectiveObject"><code class="flex name class">
<span>class <span class="ident">ProjectiveObject</span></span>
<span>(</span><span>proj_data, aux_data=None, dual_data=None, unit_ndims=1, aux_ndims=0, dual_ndims=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent some object in projective geometry (possibly a composite
object).</p>
<p>The underlying data of a projective object is stored as a numpy
ndarray. The last <code>unit_ndims</code> ndims of this array describe a
<em>single</em> instance of this type of object.</p>
<p>For example, a <code><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></code> object has <code>unit_ndims</code> equal to 2, since
a single <code><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></code> is represented by an array of shape <code>(n,d)</code>,
where <code>n</code> is the number of vertices and <code>d</code> is the dimension of
the underlying vector space. So, a <code><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></code> object whose
underlying array has shape <code>(5, 6, 4, 3)</code> represents a 5x6 array
of quadrilaterals in RP^2 (i.e. the projectivization of R^3).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>underyling data describing this projective object</dd>
<dt><strong><code>aux_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>auxiliary data describing this projective
object. Auxiliary data is any data which is in principle
computable from <code>proj_data</code>, but is convenient to keep as
part of the object definition for transformation purposes.</dd>
<dt><strong><code>dual_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>data describing this projective object which transforms
covariantly, i.e. as a dual vector in projective space.</dd>
<dt><strong><code>unit_ndims</code></strong> :&ensp;<code>int</code></dt>
<dd>number of ndims of an array representing a "unit" version
of this object. For example, an object representing a
single point in hyperbolic space has <code>unit_ndims</code> 1, while
an object representing a line segment has <code>unit_ndims</code>
equal to 2.</dd>
<dt><strong><code>aux_ndims</code></strong> :&ensp;<code>int</code></dt>
<dd>like <code>unit_ndims</code>, but for auxiliary data.</dd>
<dt><strong><code>dual_ndims</code></strong> :&ensp;<code>int</code></dt>
<dd>like <code>unit_ndims</code>, but for covariant (dual) data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectiveObject:
    &#34;&#34;&#34;Represent some object in projective geometry (possibly a composite
    object).

    The underlying data of a projective object is stored as a numpy
    ndarray. The last `unit_ndims` ndims of this array describe a
    *single* instance of this type of object.

    For example, a `Polygon` object has `unit_ndims` equal to 2, since
    a single `Polygon` is represented by an array of shape `(n,d)`,
    where `n` is the number of vertices and `d` is the dimension of
    the underlying vector space. So, a `Polygon` object whose
    underlying array has shape `(5, 6, 4, 3)` represents a 5x6 array
    of quadrilaterals in RP^2 (i.e. the projectivization of R^3).

    &#34;&#34;&#34;
    def __init__(self, proj_data, aux_data=None, dual_data=None,
                 unit_ndims=1, aux_ndims=0, dual_ndims=0):
        &#34;&#34;&#34;Parameters
        -----------

        proj_data : ndarray
            underyling data describing this projective object

        aux_data : ndarray
            auxiliary data describing this projective
            object. Auxiliary data is any data which is in principle
            computable from `proj_data`, but is convenient to keep as
            part of the object definition for transformation purposes.

        dual_data : ndarray
            data describing this projective object which transforms
            covariantly, i.e. as a dual vector in projective space.

        unit_ndims : int
            number of ndims of an array representing a &#34;unit&#34; version
            of this object. For example, an object representing a
            single point in hyperbolic space has `unit_ndims` 1, while
            an object representing a line segment has `unit_ndims`
            equal to 2.

        aux_ndims : int
            like `unit_ndims`, but for auxiliary data.

        dual_ndims : int
            like `unit_ndims`, but for covariant (dual) data.

        &#34;&#34;&#34;
        self.unit_ndims = unit_ndims
        self.aux_ndims = aux_ndims
        self.dual_ndims = dual_ndims

        try:
            self._construct_from_object(proj_data)
        except TypeError:
            self.set(proj_data, aux_data, dual_data)

    @property
    def dimension(self):
        return self.proj_data.shape[-1] - 1

    def _assert_geometry_valid(self, proj_data):
        if proj_data.ndim &lt; self.unit_ndims:
            raise GeometryError(
                (&#34;{} expects an array with ndim at least {}, got array of shape {}&#34;
                ).format(
                    self.__class__.__name__, self.unit_ndims, proj_data.shape
                )
            )
    def _assert_aux_valid(self, aux_data):
        if aux_data is None and self.aux_ndims == 0:
            return

        if aux_data.ndim &lt; self.aux_ndims:
            raise GeometryError(
                (&#34;{} expects an auxiliary array with ndim at least {}, got array of shape&#34;
                ).format(
                    self.__class__.__name__, self.unit_ndims, proj_data.shape
                )
            )

    def _compute_aux_data(self, proj_data):
        return None

    def _construct_from_object(self, hyp_obj):
        &#34;&#34;&#34;if we&#39;re passed a hyperbolic object or an array of hyperbolic
        objects, build a new one out of them

        &#34;&#34;&#34;

        try:
            self.set(hyp_obj.proj_data,
                     aux_data=hyp_obj.aux_data,
                     dual_data=hyp_obj.dual_data)
            return
        except AttributeError:
            pass

        try:
            unrolled_obj = list(hyp_obj)

            if len(unrolled_obj) == 0:
                raise IndexError

            hyp_array = np.array([obj.proj_data for obj in unrolled_obj])
            aux_array = np.array([obj.aux_data for obj in unrolled_obj])
            dual_array = np.array([obj.dual_data for obj in unrolled_obj])

            if (aux_array == None).any():
                aux_array = None

            if (dual_array == None).any():
                dual_array = None

            self.set(hyp_array, aux_data=aux_array,
                     dual_data=dual_array)
            return

        except (TypeError, AttributeError, IndexError) as e:
            pass

        raise TypeError

    @property
    def shape(self):
        &#34;&#34;&#34;Get the shape of the ndarray of &#34;unit objects&#34; this
        ProjectiveObject represents.

        Returns
        -------
        tuple


        &#34;&#34;&#34;
        return self.proj_data.shape[:-1 * self.unit_ndims]

    def set(self, proj_data, aux_data=None, dual_data=None):
        &#34;&#34;&#34;set the underlying data of the hyperbolic object.

        Subclasses may override this method to give special names to
        portions of the underlying data.

        Parameters
        ----------
        proj_data : ndarray
            underyling data representing this projective object.

        aux_data : ndarray
            underyling auxiliary data for this projective object.

        dual_data : ndarray
            underlying dual data for this projective object.

        &#34;&#34;&#34;

        # TODO: assert dual geometry valid here as well.  Right now we
        # don&#39;t bother because the only dual geometry we&#39;re using is
        # technically also auxilliary...

        proj_data = np.array(proj_data)

        self._assert_geometry_valid(proj_data)
        if aux_data is None:
            aux_data = self._compute_aux_data(proj_data)

        self._assert_aux_valid(aux_data)

        self.proj_data = proj_data
        self.aux_data = aux_data
        self.dual_data = dual_data

    def flatten_to_unit(self, unit=None):
        &#34;&#34;&#34;Get a flattened version of the projective object.

        This method reshapes the underlying data of the projective
        object to get a &#34;flat&#34; composite list of objects. For example,
        if called on a Segment object whose underlying array has shape
        (4, 5, 2, 3), this method uses the `unit_ndims` data member to
        interprets this array as an array of segments with shape
        (4,5), and returns a Segment object whose underlying array has
        shape (20, 2, 3).

        Parameters
        ----------

        unit : int
            the number of ndims to treat as a &#34;unit&#34; when flattening
            this object into units.

        &#34;&#34;&#34;

        aux_unit = unit
        dual_unit = unit
        if unit is None:
            unit = self.unit_ndims
            aux_unit = self.aux_ndims
            dual_unit = self.dual_ndims

        flattened = copy(self)
        new_shape = (-1,) + self.proj_data.shape[-1 * unit:]
        new_proj_data = np.reshape(self.proj_data, new_shape)

        new_aux_data = None
        if self.aux_data is not None:
            new_aux_shape = (-1,) + self.aux_data.shape[-1 * aux_unit:]
            new_aux_data = np.reshape(self.aux_data, new_aux_shape)

        new_dual_data = None
        if self.dual_data is not None:
            new_dual_shape = (-1,) + self.dual_data.shape[-1 * dual_unit:]
            new_dual_data = np.reshape(self.dual_data, new_dual_shape)

        flattened.set(new_proj_data, aux_data=new_aux_data,
                      dual_data=new_dual_data)

        return flattened

    def flatten_to_aux(self):
        return self.flatten_to_unit(self.aux_ndims)

    def __repr__(self):
        return &#34;({}, {})&#34;.format(
            self.__class__,
            self.proj_data.__repr__()
        )

    def __str__(self):
        return &#34;{} with data:\n{}&#34;.format(
            self.__class__.__name__, self.proj_data.__str__()
        )

    def __getitem__(self, item):
        return self.__class__(self.proj_data[item])

    def __setitem__(self, key, value):
        self.proj_data[key] = self.__class__(value).proj_data

    def __len__(self):
        if len(self.proj_data.shape) == self.unit_ndims:
            raise TypeError(&#34;len() of unsized object&#34;)

        return len(self.proj_data)

    def projective_coords(self, proj_data=None):
        &#34;&#34;&#34;Wrapper for ProjectiveObject.set, since underlying coordinates are
        projective.&#34;&#34;&#34;
        if proj_data is not None:
            self.set(proj_data)

        return self.proj_data

    def affine_coords(self, aff_data=None, chart_index=0):
        &#34;&#34;&#34;Get or set affine coordinates for this object.

        Parameters
        ----------
        aff_data : ndarray
            if not `None`, coordinate data for this point in an affine
            chart.

        chart_index : int
            index of standard affine chart to get/set coordinates in

        Returns
        -------
        ndarray
            affine coordinates of this Point, in the specified
            standard affine chart.

        &#34;&#34;&#34;
        if aff_data is not None:
            self.set(projective_coords(aff_data, chart_index=chart_index))

        return affine_coords(self.proj_data, chart_index=chart_index,
                             column_vectors=False)

    @staticmethod
    def _assert_prop_equal(objects, propname):

        if len(objects) == 0:
            return

        properties = np.array([obj.__dict__[propname]
                               for obj in objects])

        if (properties[0] != properties).any():
            raise GeometryError(
                f&#34;{propname} does not match for objects.&#34;
            )


    @classmethod
    def combine(cls, to_combine):
        &#34;&#34;&#34;Construct a new ProjectiveObject of the same type combining the
        data of `self` and `other`.

        Both `self` and `other` will be flattened to unit dimensions
        before combining. If dimensions of the underlying data do not
        match, this will raise an error.

        Parameters
        ----------
        other : ProjectiveObject of the same type as `self`.
            ProjectiveObject to combine with

        Returns
        -------
        ProjectiveObject
            Object of the same type as `self` containing (flattened)
            combined data.

        &#34;&#34;&#34;
        if len(to_combine) == 0:
            return

        cls._assert_prop_equal(to_combine, &#34;unit_ndims&#34;)
        cls._assert_prop_equal(to_combine, &#34;aux_ndims&#34;)
        cls._assert_prop_equal(to_combine, &#34;dual_ndims&#34;)

        unit_ndims = to_combine[0].unit_ndims
        aux_ndims = to_combine[0].aux_ndims
        dual_ndims = to_combine[0].dual_ndims

        flattened_objs = [
            obj.flatten_to_unit()
            for obj in to_combine
        ]

        # first make a generic ProjectiveObject
        new_data = np.concatenate(
            [obj.proj_data for obj in flattened_objs],
            axis=-(unit_ndims+1)
        )
        new_aux = None
        new_dual = None

        if aux_ndims &gt; 0:
            new_data = np.concatenate(
                [obj.aux_data for obj in flattened_objs],
                axis=-(aux_ndims+1)
            )
            new_aux = np.concatenate([flat_self.aux_data, flat_other.aux_data],
                                     axis=-(self.aux_ndims+1))
        if dual_ndims &gt; 0:
            new_data = np.concatenate(
                [obj.dual_data for obj in flattened_objs],
                axis=-(dual_ndims+1)
            )

        newObj = ProjectiveObject(new_data, new_aux, new_dual,
                                  unit_ndims=unit_ndims,
                                  aux_ndims=aux_ndims,
                                  dual_ndims=dual_ndims)

        # construct an object with the correct type from this underlying data
        return cls(newObj)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.complex_projective.CP1Object" href="complex_projective.html#geometry_tools.complex_projective.CP1Object">CP1Object</a></li>
<li><a title="geometry_tools.hyperbolic.HyperbolicObject" href="hyperbolic.html#geometry_tools.hyperbolic.HyperbolicObject">HyperbolicObject</a></li>
<li><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></li>
<li><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geometry_tools.projective.ProjectiveObject.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>to_combine)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a new ProjectiveObject of the same type combining the
data of <code>self</code> and <code>other</code>.</p>
<p>Both <code>self</code> and <code>other</code> will be flattened to unit dimensions
before combining. If dimensions of the underlying data do not
match, this will raise an error.</p>
<h2 id="parameters">Parameters</h2>
<p>other : ProjectiveObject of the same type as <code>self</code>.
ProjectiveObject to combine with</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code></dt>
<dd>Object of the same type as <code>self</code> containing (flattened)
combined data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def combine(cls, to_combine):
    &#34;&#34;&#34;Construct a new ProjectiveObject of the same type combining the
    data of `self` and `other`.

    Both `self` and `other` will be flattened to unit dimensions
    before combining. If dimensions of the underlying data do not
    match, this will raise an error.

    Parameters
    ----------
    other : ProjectiveObject of the same type as `self`.
        ProjectiveObject to combine with

    Returns
    -------
    ProjectiveObject
        Object of the same type as `self` containing (flattened)
        combined data.

    &#34;&#34;&#34;
    if len(to_combine) == 0:
        return

    cls._assert_prop_equal(to_combine, &#34;unit_ndims&#34;)
    cls._assert_prop_equal(to_combine, &#34;aux_ndims&#34;)
    cls._assert_prop_equal(to_combine, &#34;dual_ndims&#34;)

    unit_ndims = to_combine[0].unit_ndims
    aux_ndims = to_combine[0].aux_ndims
    dual_ndims = to_combine[0].dual_ndims

    flattened_objs = [
        obj.flatten_to_unit()
        for obj in to_combine
    ]

    # first make a generic ProjectiveObject
    new_data = np.concatenate(
        [obj.proj_data for obj in flattened_objs],
        axis=-(unit_ndims+1)
    )
    new_aux = None
    new_dual = None

    if aux_ndims &gt; 0:
        new_data = np.concatenate(
            [obj.aux_data for obj in flattened_objs],
            axis=-(aux_ndims+1)
        )
        new_aux = np.concatenate([flat_self.aux_data, flat_other.aux_data],
                                 axis=-(self.aux_ndims+1))
    if dual_ndims &gt; 0:
        new_data = np.concatenate(
            [obj.dual_data for obj in flattened_objs],
            axis=-(dual_ndims+1)
        )

    newObj = ProjectiveObject(new_data, new_aux, new_dual,
                              unit_ndims=unit_ndims,
                              aux_ndims=aux_ndims,
                              dual_ndims=dual_ndims)

    # construct an object with the correct type from this underlying data
    return cls(newObj)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geometry_tools.projective.ProjectiveObject.dimension"><code class="name">var <span class="ident">dimension</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dimension(self):
    return self.proj_data.shape[-1] - 1</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.ProjectiveObject.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Get the shape of the ndarray of "unit objects" this
ProjectiveObject represents.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    &#34;&#34;&#34;Get the shape of the ndarray of &#34;unit objects&#34; this
    ProjectiveObject represents.

    Returns
    -------
    tuple


    &#34;&#34;&#34;
    return self.proj_data.shape[:-1 * self.unit_ndims]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.ProjectiveObject.affine_coords"><code class="name flex">
<span>def <span class="ident">affine_coords</span></span>(<span>self, aff_data=None, chart_index=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set affine coordinates for this object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aff_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>if not <code>None</code>, coordinate data for this point in an affine
chart.</dd>
<dt><strong><code>chart_index</code></strong> :&ensp;<code>int</code></dt>
<dd>index of standard affine chart to get/set coordinates in</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>affine coordinates of this Point, in the specified
standard affine chart.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_coords(self, aff_data=None, chart_index=0):
    &#34;&#34;&#34;Get or set affine coordinates for this object.

    Parameters
    ----------
    aff_data : ndarray
        if not `None`, coordinate data for this point in an affine
        chart.

    chart_index : int
        index of standard affine chart to get/set coordinates in

    Returns
    -------
    ndarray
        affine coordinates of this Point, in the specified
        standard affine chart.

    &#34;&#34;&#34;
    if aff_data is not None:
        self.set(projective_coords(aff_data, chart_index=chart_index))

    return affine_coords(self.proj_data, chart_index=chart_index,
                         column_vectors=False)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.ProjectiveObject.flatten_to_aux"><code class="name flex">
<span>def <span class="ident">flatten_to_aux</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_to_aux(self):
    return self.flatten_to_unit(self.aux_ndims)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.ProjectiveObject.flatten_to_unit"><code class="name flex">
<span>def <span class="ident">flatten_to_unit</span></span>(<span>self, unit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a flattened version of the projective object.</p>
<p>This method reshapes the underlying data of the projective
object to get a "flat" composite list of objects. For example,
if called on a Segment object whose underlying array has shape
(4, 5, 2, 3), this method uses the <code>unit_ndims</code> data member to
interprets this array as an array of segments with shape
(4,5), and returns a Segment object whose underlying array has
shape (20, 2, 3).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of ndims to treat as a "unit" when flattening
this object into units.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_to_unit(self, unit=None):
    &#34;&#34;&#34;Get a flattened version of the projective object.

    This method reshapes the underlying data of the projective
    object to get a &#34;flat&#34; composite list of objects. For example,
    if called on a Segment object whose underlying array has shape
    (4, 5, 2, 3), this method uses the `unit_ndims` data member to
    interprets this array as an array of segments with shape
    (4,5), and returns a Segment object whose underlying array has
    shape (20, 2, 3).

    Parameters
    ----------

    unit : int
        the number of ndims to treat as a &#34;unit&#34; when flattening
        this object into units.

    &#34;&#34;&#34;

    aux_unit = unit
    dual_unit = unit
    if unit is None:
        unit = self.unit_ndims
        aux_unit = self.aux_ndims
        dual_unit = self.dual_ndims

    flattened = copy(self)
    new_shape = (-1,) + self.proj_data.shape[-1 * unit:]
    new_proj_data = np.reshape(self.proj_data, new_shape)

    new_aux_data = None
    if self.aux_data is not None:
        new_aux_shape = (-1,) + self.aux_data.shape[-1 * aux_unit:]
        new_aux_data = np.reshape(self.aux_data, new_aux_shape)

    new_dual_data = None
    if self.dual_data is not None:
        new_dual_shape = (-1,) + self.dual_data.shape[-1 * dual_unit:]
        new_dual_data = np.reshape(self.dual_data, new_dual_shape)

    flattened.set(new_proj_data, aux_data=new_aux_data,
                  dual_data=new_dual_data)

    return flattened</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.ProjectiveObject.projective_coords"><code class="name flex">
<span>def <span class="ident">projective_coords</span></span>(<span>self, proj_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for ProjectiveObject.set, since underlying coordinates are
projective.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projective_coords(self, proj_data=None):
    &#34;&#34;&#34;Wrapper for ProjectiveObject.set, since underlying coordinates are
    projective.&#34;&#34;&#34;
    if proj_data is not None:
        self.set(proj_data)

    return self.proj_data</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.ProjectiveObject.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, proj_data, aux_data=None, dual_data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>set the underlying data of the hyperbolic object.</p>
<p>Subclasses may override this method to give special names to
portions of the underlying data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>underyling data representing this projective object.</dd>
<dt><strong><code>aux_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>underyling auxiliary data for this projective object.</dd>
<dt><strong><code>dual_data</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>underlying dual data for this projective object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, proj_data, aux_data=None, dual_data=None):
    &#34;&#34;&#34;set the underlying data of the hyperbolic object.

    Subclasses may override this method to give special names to
    portions of the underlying data.

    Parameters
    ----------
    proj_data : ndarray
        underyling data representing this projective object.

    aux_data : ndarray
        underyling auxiliary data for this projective object.

    dual_data : ndarray
        underlying dual data for this projective object.

    &#34;&#34;&#34;

    # TODO: assert dual geometry valid here as well.  Right now we
    # don&#39;t bother because the only dual geometry we&#39;re using is
    # technically also auxilliary...

    proj_data = np.array(proj_data)

    self._assert_geometry_valid(proj_data)
    if aux_data is None:
        aux_data = self._compute_aux_data(proj_data)

    self._assert_aux_valid(aux_data)

    self.proj_data = proj_data
    self.aux_data = aux_data
    self.dual_data = dual_data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geometry_tools.projective.ProjectiveRepresentation"><code class="flex name class">
<span>class <span class="ident">ProjectiveRepresentation</span></span>
<span>(</span><span>representation=None, generator_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation (of a free group) lying in PGL(V). Passing words
(in the generators) to this representation yields <code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code>
objects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>representation</code></strong> :&ensp;<code>Representation</code></dt>
<dd>Representation to copy elements from</dd>
<dt><strong><code>generator_names</code></strong> :&ensp;<code>iterable</code> of <code>strings</code></dt>
<dd>Names to use for the generators. These must be initialized
as arrays later to use the representation properly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectiveRepresentation(representation.Representation):
    &#34;&#34;&#34;A representation (of a free group) lying in PGL(V). Passing words
    (in the generators) to this representation yields `Transformation`
    objects.
    &#34;&#34;&#34;
    def __getitem__(self, word):
        matrix = self._word_value(word)
        return Transformation(matrix, column_vectors=True)

    def __setitem__(self, generator, matrix):
        transform = Transformation(matrix, column_vectors=True)
        representation.Representation.__setitem__(self, generator,
                                                  transform.matrix.T)

    def transformations(self, words):
        &#34;&#34;&#34;Get a composite transformation, representing a sequence of words in
        the generators for this representation.

        Parameters
        ----------
        words : iterable of strings
            Sequence of words to apply this representation to.

        Returns
        -------
        Transformation
            Composite transformation object containing one
            transformation for each word in `words`.

        &#34;&#34;&#34;
        return Transformation(self.elements(words), column_vectors=True)

    def automaton_accepted(self, automaton, length,
                           maxlen=True, with_words=False,
                           start_state=None, end_state=None,
                           precomputed=None):
        result = representation.Representation.automaton_accepted(
            self, automaton, length,
            with_words=with_words,
            start_state=start_state,
            end_state=end_state,
            precomputed=precomputed
        )

        if with_words:
            matrix_array, words = result
        else:
            matrix_array = result

        transformations = Transformation(matrix_array, column_vectors=True)

        if with_words:
            return transformations, words

        return transformations</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.representation.Representation" href="representation.html#geometry_tools.representation.Representation">Representation</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.HyperbolicRepresentation" href="hyperbolic.html#geometry_tools.hyperbolic.HyperbolicRepresentation">HyperbolicRepresentation</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.ProjectiveRepresentation.transformations"><code class="name flex">
<span>def <span class="ident">transformations</span></span>(<span>self, words)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a composite transformation, representing a sequence of words in
the generators for this representation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>words</code></strong> :&ensp;<code>iterable</code> of <code>strings</code></dt>
<dd>Sequence of words to apply this representation to.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code></dt>
<dd>Composite transformation object containing one
transformation for each word in <code>words</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transformations(self, words):
    &#34;&#34;&#34;Get a composite transformation, representing a sequence of words in
    the generators for this representation.

    Parameters
    ----------
    words : iterable of strings
        Sequence of words to apply this representation to.

    Returns
    -------
    Transformation
        Composite transformation object containing one
        transformation for each word in `words`.

    &#34;&#34;&#34;
    return Transformation(self.elements(words), column_vectors=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.representation.Representation" href="representation.html#geometry_tools.representation.Representation">Representation</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.representation.Representation.automaton_accepted" href="representation.html#geometry_tools.representation.Representation.automaton_accepted">automaton_accepted</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.elements" href="representation.html#geometry_tools.representation.Representation.elements">elements</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.free_words_less_than" href="representation.html#geometry_tools.representation.Representation.free_words_less_than">free_words_less_than</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.free_words_of_length" href="representation.html#geometry_tools.representation.Representation.free_words_of_length">free_words_of_length</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.freely_reduced_elements" href="representation.html#geometry_tools.representation.Representation.freely_reduced_elements">freely_reduced_elements</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.semi_gens" href="representation.html#geometry_tools.representation.Representation.semi_gens">semi_gens</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.symmetric_square" href="representation.html#geometry_tools.representation.Representation.symmetric_square">symmetric_square</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.tensor_product" href="representation.html#geometry_tools.representation.Representation.tensor_product">tensor_product</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geometry_tools.projective.Transformation"><code class="flex name class">
<span>class <span class="ident">Transformation</span></span>
<span>(</span><span>proj_data, column_vectors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A projective transformation (or a composite object consisting of a
collection of projective transformations).</p>
<p>By default, the underlying data for a projective
transformation is a <em>row matrix</em> (or an ndarray of row
matrices), acting on vectors on the <em>right</em>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_data</code></strong> :&ensp;<code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code> or <code>ndarray</code></dt>
<dd>Data to use to construct a projective transformation (or
array of projective transformations).</dd>
<dt><strong><code>column_vectors</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, interpret proj_data as a <em>column matrix</em> acting
on the left. Otherwise proj_data gives a <em>row matrix</em>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformation(ProjectiveObject):
    &#34;&#34;&#34;A projective transformation (or a composite object consisting of a
    collection of projective transformations).
    &#34;&#34;&#34;
    def __init__(self, proj_data, column_vectors=False):
        &#34;&#34;&#34;By default, the underlying data for a projective
        transformation is a *row matrix* (or an ndarray of row
        matrices), acting on vectors on the *right*.

        Parameters
        ----------
        proj_data : ProjectiveObject or ndarray
            Data to use to construct a projective transformation (or
            array of projective transformations).
        column_vectors : bool
            If `True`, interpret proj_data as a *column matrix* acting
            on the left. Otherwise proj_data gives a *row matrix*.
        &#34;&#34;&#34;
        self.unit_ndims = 2
        self.aux_ndims = 0
        self.dual_ndims = 0

        try:
            self._construct_from_object(proj_data)
        except TypeError:
            if column_vectors:
                self.set(proj_data.swapaxes(-1,-2))
            else:
                self.set(proj_data)

    def _assert_geometry_valid(self, proj_data):
        ProjectiveObject._assert_geometry_valid(self, proj_data)
        if (len(proj_data.shape) &lt; 2 or
            proj_data.shape[-2] != proj_data.shape[-1]):
            raise GeometryError(
                (&#34;Projective transformation must be ndarray of n x n&#34;
                 &#34; matrices, got array with shape {}&#34;).format(
                     proj_data.shape))

    def set(self, proj_data, **kwargs):
        ProjectiveObject.set(self, proj_data)
        self.matrix = proj_data
        self.proj_data = proj_data

    def _apply_to_data(self, proj_data, broadcast, unit_ndims=1, dual=False):
        matrix = self.matrix
        if dual:
            matrix = np.linalg.inv(matrix).swapaxes(-1, -2)
        return utils.matrix_product(proj_data,
                                    matrix,
                                    unit_ndims, self.unit_ndims,
                                    broadcast=broadcast)

    def apply(self, proj_obj, broadcast=&#34;elementwise&#34;):
        &#34;&#34;&#34;Apply this transformation to another object in projective space.

        Parameters
        ----------
        proj_obj : ProjectiveObject or ndarray
            Projective object to apply this transformation to. This object
            may be composite.
        broadcast : string
            Broadcasting behavior for applying composite
            transformation objects. If &#34;elementwise&#34;, then the shape
            of this (composite) transformation object and the shape of
            the (composite) object to apply transformations to need to
            be broadcastable. If &#34;pairwise&#34;, then apply every element
            of this (composite) transformation object to every element
            of the target object (i.e. take an outer product).

        Returns
        -------
        ProjectiveObject
            Transformed (possibly composite) projective object. The
            type of this object is the same type as the original
            (untransformed) object. If the original object was
            provided as an ndarray, then the returned object has type
            ProjectiveObject.

        &#34;&#34;&#34;
        new_obj = copy(proj_obj)

        try:
            proj_data = new_obj.proj_data
            proj_product = self._apply_to_data(new_obj.proj_data, broadcast,
                                               new_obj.unit_ndims)
            aux_data = new_obj.aux_data
            aux_product = None

            if aux_data is not None:
                aux_product = self._apply_to_data(new_obj.aux_data, broadcast,
                                                  new_obj.aux_ndims)

            dual_data = new_obj.dual_data
            dual_product = None
            if dual_data is not None:
                dual_product = self._apply_to_data(new_obj.dual_data, broadcast,
                                                   new_obj.dual_ndims)

            new_obj.set(proj_product,
                        aux_data=aux_product,
                        dual_data=dual_product)

            return new_obj
        except AttributeError:
            pass

        #otherwise, it&#39;s an array of vectors which we&#39;ll interpret as
        #some kind of hyperbolic object
        product = self._apply_to_data(proj_obj, broadcast)
        return self._data_to_object(product)

    def _data_to_object(self, data):
        return ProjectiveObject(data)

    def inv(self):
        &#34;&#34;&#34;Get the inverse of this transformation.

        Returns
        -------
        ProjectiveTransformation
            Inverse of this transformation.
        &#34;&#34;&#34;
        return self.__class__(np.linalg.inv(self.matrix))

    def __matmul__(self, other):
        return self.apply(other)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.hyperbolic.Isometry" href="hyperbolic.html#geometry_tools.hyperbolic.Isometry">Isometry</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.projective.Transformation.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, proj_obj, broadcast='elementwise')</span>
</code></dt>
<dd>
<div class="desc"><p>Apply this transformation to another object in projective space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>proj_obj</code></strong> :&ensp;<code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code> or <code>ndarray</code></dt>
<dd>Projective object to apply this transformation to. This object
may be composite.</dd>
<dt><strong><code>broadcast</code></strong> :&ensp;<code>string</code></dt>
<dd>Broadcasting behavior for applying composite
transformation objects. If "elementwise", then the shape
of this (composite) transformation object and the shape of
the (composite) object to apply transformations to need to
be broadcastable. If "pairwise", then apply every element
of this (composite) transformation object to every element
of the target object (i.e. take an outer product).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code></dt>
<dd>Transformed (possibly composite) projective object. The
type of this object is the same type as the original
(untransformed) object. If the original object was
provided as an ndarray, then the returned object has type
ProjectiveObject.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, proj_obj, broadcast=&#34;elementwise&#34;):
    &#34;&#34;&#34;Apply this transformation to another object in projective space.

    Parameters
    ----------
    proj_obj : ProjectiveObject or ndarray
        Projective object to apply this transformation to. This object
        may be composite.
    broadcast : string
        Broadcasting behavior for applying composite
        transformation objects. If &#34;elementwise&#34;, then the shape
        of this (composite) transformation object and the shape of
        the (composite) object to apply transformations to need to
        be broadcastable. If &#34;pairwise&#34;, then apply every element
        of this (composite) transformation object to every element
        of the target object (i.e. take an outer product).

    Returns
    -------
    ProjectiveObject
        Transformed (possibly composite) projective object. The
        type of this object is the same type as the original
        (untransformed) object. If the original object was
        provided as an ndarray, then the returned object has type
        ProjectiveObject.

    &#34;&#34;&#34;
    new_obj = copy(proj_obj)

    try:
        proj_data = new_obj.proj_data
        proj_product = self._apply_to_data(new_obj.proj_data, broadcast,
                                           new_obj.unit_ndims)
        aux_data = new_obj.aux_data
        aux_product = None

        if aux_data is not None:
            aux_product = self._apply_to_data(new_obj.aux_data, broadcast,
                                              new_obj.aux_ndims)

        dual_data = new_obj.dual_data
        dual_product = None
        if dual_data is not None:
            dual_product = self._apply_to_data(new_obj.dual_data, broadcast,
                                               new_obj.dual_ndims)

        new_obj.set(proj_product,
                    aux_data=aux_product,
                    dual_data=dual_product)

        return new_obj
    except AttributeError:
        pass

    #otherwise, it&#39;s an array of vectors which we&#39;ll interpret as
    #some kind of hyperbolic object
    product = self._apply_to_data(proj_obj, broadcast)
    return self._data_to_object(product)</code></pre>
</details>
</dd>
<dt id="geometry_tools.projective.Transformation.inv"><code class="name flex">
<span>def <span class="ident">inv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the inverse of this transformation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ProjectiveTransformation</code></dt>
<dd>Inverse of this transformation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inv(self):
    &#34;&#34;&#34;Get the inverse of this transformation.

    Returns
    -------
    ProjectiveTransformation
        Inverse of this transformation.
    &#34;&#34;&#34;
    return self.__class__(np.linalg.inv(self.matrix))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.projective.ProjectiveObject.affine_coords" href="#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.combine" href="#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.flatten_to_unit" href="#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.projective_coords" href="#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.set" href="#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.shape" href="#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geometry_tools" href="index.html">geometry_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geometry_tools.projective.affine_coords" href="#geometry_tools.projective.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.affine_linear_map" href="#geometry_tools.projective.affine_linear_map">affine_linear_map</a></code></li>
<li><code><a title="geometry_tools.projective.affine_translation" href="#geometry_tools.projective.affine_translation">affine_translation</a></code></li>
<li><code><a title="geometry_tools.projective.hyperplane_coordinate_transform" href="#geometry_tools.projective.hyperplane_coordinate_transform">hyperplane_coordinate_transform</a></code></li>
<li><code><a title="geometry_tools.projective.identity" href="#geometry_tools.projective.identity">identity</a></code></li>
<li><code><a title="geometry_tools.projective.projective_coords" href="#geometry_tools.projective.projective_coords">projective_coords</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geometry_tools.projective.ConvexPolygon" href="#geometry_tools.projective.ConvexPolygon">ConvexPolygon</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.projective.ConvexPolygon.add_points" href="#geometry_tools.projective.ConvexPolygon.add_points">add_points</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.projective.GeometryError" href="#geometry_tools.projective.GeometryError">GeometryError</a></code></h4>
</li>
<li>
<h4><code><a title="geometry_tools.projective.Point" href="#geometry_tools.projective.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.projective.Point.in_affine_chart" href="#geometry_tools.projective.Point.in_affine_chart">in_affine_chart</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.projective.PointPair" href="#geometry_tools.projective.PointPair">PointPair</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.projective.PointPair.endpoint_affine_coords" href="#geometry_tools.projective.PointPair.endpoint_affine_coords">endpoint_affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.PointPair.endpoint_projective_coords" href="#geometry_tools.projective.PointPair.endpoint_projective_coords">endpoint_projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.PointPair.get_end_pair" href="#geometry_tools.projective.PointPair.get_end_pair">get_end_pair</a></code></li>
<li><code><a title="geometry_tools.projective.PointPair.get_endpoints" href="#geometry_tools.projective.PointPair.get_endpoints">get_endpoints</a></code></li>
<li><code><a title="geometry_tools.projective.PointPair.set_endpoints" href="#geometry_tools.projective.PointPair.set_endpoints">set_endpoints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.projective.Polygon" href="#geometry_tools.projective.Polygon">Polygon</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.projective.Polygon.get_edges" href="#geometry_tools.projective.Polygon.get_edges">get_edges</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.get_vertices" href="#geometry_tools.projective.Polygon.get_vertices">get_vertices</a></code></li>
<li><code><a title="geometry_tools.projective.Polygon.in_standard_chart" href="#geometry_tools.projective.Polygon.in_standard_chart">in_standard_chart</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.projective.ProjectiveObject" href="#geometry_tools.projective.ProjectiveObject">ProjectiveObject</a></code></h4>
<ul class="two-column">
<li><code><a title="geometry_tools.projective.ProjectiveObject.affine_coords" href="#geometry_tools.projective.ProjectiveObject.affine_coords">affine_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.combine" href="#geometry_tools.projective.ProjectiveObject.combine">combine</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.dimension" href="#geometry_tools.projective.ProjectiveObject.dimension">dimension</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.flatten_to_aux" href="#geometry_tools.projective.ProjectiveObject.flatten_to_aux">flatten_to_aux</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.flatten_to_unit" href="#geometry_tools.projective.ProjectiveObject.flatten_to_unit">flatten_to_unit</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.projective_coords" href="#geometry_tools.projective.ProjectiveObject.projective_coords">projective_coords</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.set" href="#geometry_tools.projective.ProjectiveObject.set">set</a></code></li>
<li><code><a title="geometry_tools.projective.ProjectiveObject.shape" href="#geometry_tools.projective.ProjectiveObject.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.projective.ProjectiveRepresentation" href="#geometry_tools.projective.ProjectiveRepresentation">ProjectiveRepresentation</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.projective.ProjectiveRepresentation.transformations" href="#geometry_tools.projective.ProjectiveRepresentation.transformations">transformations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.projective.Transformation" href="#geometry_tools.projective.Transformation">Transformation</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.projective.Transformation.apply" href="#geometry_tools.projective.Transformation.apply">apply</a></code></li>
<li><code><a title="geometry_tools.projective.Transformation.inv" href="#geometry_tools.projective.Transformation.inv">inv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
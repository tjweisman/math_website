<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geometry_tools.utils API documentation</title>
<meta name="description" content="Provide utility functions used by the various geometry tools in
this package." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geometry_tools.utils</code></h1>
</header>
<section id="section-intro">
<p>Provide utility functions used by the various geometry tools in
this package.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provide utility functions used by the various geometry tools in
this package.

&#34;&#34;&#34;
import numpy as np

from scipy.optimize import linprog

def rotation_matrix(angle):
    r&#34;&#34;&#34;Get a 2x2 rotation matrix rotating counterclockwise by the
    specified angle.

    Parameters
    ----------
    angle : float
        angle to rotate by

    Returns
    -------
    ndarray
        numpy array of shape (2,2) of the form
        \(\begin{pmatrix}\cos \theta &amp; -\sin \theta\\\sin\theta &amp; \cos \theta
        \end{pmatrix}\)

    &#34;&#34;&#34;
    return np.array([[np.cos(angle), -1*np.sin(angle)],
                     [np.sin(angle), np.cos(angle)]])

def permutation_matrix(permutation):
    &#34;&#34;&#34;Return a permutation matrix representing the given permutation.

    Parameters
    ----------
    permutation: iterable
        a sequence of n numbers (indices), specifying a permutation of
        (1, ... n).

    Returns
    -------
    ndarray
        square 2-dimensional array, giving a permutation matrix.

    &#34;&#34;&#34;
    n = len(permutation)
    p_mat = np.zeros((n, n))
    for i,j in enumerate(permutation):
        p_mat[i,j] = 1.

    return p_mat

def diagonalize_form(bilinear_form, order_eigenvalues=&#34;signed&#34;, reverse=False):
    r&#34;&#34;&#34;Return a matrix conjugating a symmetric real bilinear form to a
    diagonal form.

    Parameters
    ----------
    bilinear_form: ndarray
        numpy array of shape (n, n) representing, a symmetric bilinear
        form in standard coordinates
    order_eigenvalues: {&#39;signed&#39;, &#39;minkowski&#39;}
        If &#34;signed&#34; (the default), conjugate to a diagonal bilinear
        form on R^n, whose eigenvectors are ordered in order of
        increasing eigenvalue.

        If &#34;minkowski&#34;, conjugate to a diagonal bilinear form whose
        basis vectors are ordered so that lightlike basis vectors come
        first, followed by spacelike basis vectors, followed by
        timelike basis vectors. (lightlike vectors pair to a negative
        value under the form, spacelike vectors pair to a positive
        value, and timelike vectors pair to zero).
    reverse : bool
        if True, reverse the order of the basis vectors for the
        diagonal bilinear form (from the order specified by
        `order_eigenvalues`).

    Returns
    -------
    ndarray
        numpy array of shape (n, n), representing a coordinate change
        taking the given bilinear form to a diagonal form. If \(B\) is
        the matrix given by bilinear_form, and \(D\) is a diagonal
        matrix with the same signature as \(B\), then this function
        returns a matrix \(M\) such that \(M^TDM = B\).

    &#34;&#34;&#34;
    n, _ = bilinear_form.shape

    eigs, U = np.linalg.eigh(bilinear_form)
    D = np.diag(1 / np.sqrt(np.abs(eigs)))


    perm = np.identity(n)

    if order_eigenvalues:
        if order_eigenvalues == &#34;signed&#34;:
            order = np.argsort(eigs)
        if order_eigenvalues == &#34;minkowski&#34;:
            negative = np.count_nonzero(eigs &lt; 0)
            positive = np.count_nonzero(eigs &gt; 0)

            if negative &lt;= positive:
                order = np.concatenate(
                    ((eigs &lt; 0).nonzero()[0],
                     (eigs &gt; 0).nonzero()[0],
                     (eigs == 0).nonzero()[0])
                )
            else:
                order = np.concatenate(
                    ((eigs &gt; 0).nonzero()[0],
                     (eigs &lt; 0).nonzero()[0],
                     (eigs == 0).nonzero()[0])
                )
        if reverse:
            order = np.flip(order)

        perm = permutation_matrix(order)

    W = U @ D @ np.linalg.inv(perm)

    return W

def circle_angles(center, coords):
    &#34;&#34;&#34;Return angles relative to the center of a circle.

    Parameters
    ----------
    center: ndarray
        numpy array with shape (..., 2) representing x,y coordinates
        the centers of some circles.
    coords: ndarray
        numpy array with shape (..., 2) representing x,y coordinates
        of some points.

    Returns
    -------
    ndarray
        angles (relative to x-axis) of each of the pair of points
        specified by coords.

    &#34;&#34;&#34;
    xs = (coords - np.expand_dims(center, axis=-2))[..., 0]
    ys = (coords - np.expand_dims(center, axis=-2))[..., 1]

    return np.arctan2(ys, xs)

def apply_bilinear(v1, v2, bilinear_form=None):
    &#34;&#34;&#34;Apply a bilinar form to a pair of arrays of vectors.

    Parameters
    ----------
    v1, v2: ndarray
        ndarrays of shape (..., n) giving arrays of vectors.
    bilinear_form: ndarray
        ndarray of shape (n, n) specifying a matrix representing a
        symmetric bilinear form to use to pair v1 and v2. If
        `None`, use the standard (Euclidean) bilinear form on R^n.

    Returns
    -------
    ndarray
        ndarray representing the result of pairing the vectors in v1
        with v2.

    &#34;&#34;&#34;

    if bilinear_form is None:
        bilinear_form = np.identity(v1.shape[-1])

    return ((v1 @ bilinear_form) * v2).sum(-1)

def normsq(vectors, bilinear_form=None):
    &#34;&#34;&#34;Evaluate the norm squared of an array of vectors, with respect to a
       bilinear form.

    Equivalent to a call of apply_bilinear(vectors, vectors, bilinear_form).

    &#34;&#34;&#34;
    return apply_bilinear(vectors, vectors, bilinear_form)


def normalize(vectors, bilinear_form=None):
    &#34;&#34;&#34;Normalize an array of vectors, with respect to a bilinear form.

    Parameters
    ----------
    vectors: ndarray
        ndarray of shape (..., n)
    bilinear_form: ndarray or None
        bilinear form to use to evaluate the norms in vectors. If
        None, use the standard (Euclidean) bilinear form on R^n.

    Returns
    -------
    ndarray
        ndarray with the same shape as vectors. Each vector in this
        array has norm either +1 or -1, depending on whether the
        original vector had positive or negative square-norm (with
        respect to the given bilinear form).

    &#34;&#34;&#34;
    norms = normsq(vectors, bilinear_form)
    return vectors / np.sqrt(np.abs(np.expand_dims(norms, axis=-1)))

def short_arc(thetas):
    &#34;&#34;&#34;Reorder angles so that the counterclockwise arc between them is
    shorter than the clockwise angle.

    Parameters
    ----------
    thetas: ndarray
        numpy array of shape (..., 2), giving ordered pairs of angles
        in the range (-2pi, 2pi)

    Returns
    -------
    ndarray
        numpy array with the same shape as thetas. The ordered pairs
        in this array are arranged so that for each pair `(a, b)`, the
        counterclockwise arc from `a` to `b` is shorter than the
        counterclockwise arc from `b` to `a`.

    &#34;&#34;&#34;
    shifted_thetas = np.copy(thetas)

    shifted_thetas[shifted_thetas &lt; 0] += 2 * np.pi
    shifted_thetas.sort(axis=-1)

    to_flip = shifted_thetas[...,1] - shifted_thetas[...,0] &gt; np.pi
    shifted_thetas[to_flip] = np.flip(shifted_thetas[to_flip], axis=-1)

    return shifted_thetas

def right_to_left(thetas):
    &#34;&#34;&#34;Reorder angles so that the counterclockwise arc goes right to left.

    Parameters
    ----------
    thetas: ndarray
        numpy array of shape (..., 2), giving ordered pairs of angles.

    Returns
    -------
    ndarray
        numpy array with the same shape as `thetas`. The ordered pairs
        in this array are arranged so that for each pair `(a, b)`, the
        cosine of `b` is at most the cosine of `a`.

    &#34;&#34;&#34;
    flipped_thetas = np.copy(thetas)

    to_flip = np.cos(thetas[..., 0]) &lt; np.cos(thetas[..., 1])
    flipped_thetas[to_flip] = np.flip(thetas[to_flip], axis=-1)

    return flipped_thetas


def arc_include(thetas, reference_theta):
    &#34;&#34;&#34;Reorder angles so that the counterclockwise arc between them always
    includes some reference point on the circle.

    Parameters
    ----------
    thetas : ndarray(float)
        pairs of angles in the range (-2pi, 2pi).
    reference_theta: ndarray(float)
         angles in the range (-2pi, 2pi)

    Returns
    -------
    theta_p : ndarray(float)
        pairs of angles of the same shape as `thetas`, so that
        `reference_theta` lies in the counterclockwise angle between
        `theta_p[..., 0]` and `theta_p[..., 1]`.

    &#34;&#34;&#34;

    s_thetas = np.copy(thetas)
    s_theta1 = thetas[..., 1] - thetas[..., 0]
    s_reference = np.expand_dims(reference_theta - thetas[..., 0],
                                 axis=-1)

    s_theta1[s_theta1 &lt; 0] += 2 * np.pi
    s_reference[s_reference &lt; 0] += 2 * np.pi

    to_swap = (s_theta1 &lt; s_reference[..., 0])

    s_thetas[to_swap] = np.flip(s_thetas[to_swap], axis=-1)
    return s_thetas

def sphere_inversion(points):
    r&#34;&#34;&#34;Apply unit sphere inversion to points in R^n.

    This realizes the map \(v \mapsto v / ||v||^2\).

    Parameters
    ----------
    points : ndarray
        Array of shape `(..., n)` giving a set of points in R^n

    Returns
    -------
    ndarray
        The image of the `points` array under sphere inversion.

    &#34;&#34;&#34;
    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        return (points.T / (normsq(points)).T).T

def swap_matrix(i, j, n):
    &#34;&#34;&#34;Return a permutation matrix representing a single transposition.

    Parameters
    ----------
    i, j : int
        Indices swapped by a transposition.
    n : int
        dimension of the permutation matrix.

    Returns
    -------
    ndarray
        Array of shape `(n, n)` giving a transposition matrix.

    &#34;&#34;&#34;
    permutation = list(range(n))
    permutation[i] = j
    permutation[j] = i
    return permutation_matrix(permutation)

def projection(v1, v2, bilinear_form):
    r&#34;&#34;&#34;Return the projection of `v1` onto `v2` with respect to some
    bilinear form.

    The returned vector `w` is parallel to `v2`, and `v1 - w` is
    orthogonal to `v2` with respect to the given bilinear form.
    `w` is determined by the formula
    \[
    v_2 \cdot \langle v_1, v_2 \rangle / \langle v_2, v_2 \rangle,
    \]
    where \(\langle \cdot, \cdot \rangle\) is the pairing determined by
    `bilinear_form`.

    Parameters
    ----------
    v1 : ndarray
        vector in R^n to project
    v2 : ndarray
        vector in R^n to project onto
    bilinear_form : ndarray
        array of shape `(n, n)` giving a bilinear form to use for the
        projection.

    Returns
    -------
    w : ndarray
        vector in R^n giving the projection of `v1` onto `v2`.

    &#34;&#34;&#34;

    return (v2.T *
            apply_bilinear(v1, v2, bilinear_form).T /
            normsq(v2, bilinear_form).T).T

def indefinite_orthogonalize(form, matrices):
    &#34;&#34;&#34;Apply the Gram-Schmidt algorithm, but for a possibly indefinite
    bilinear form.

    Parameters
    ----------
    form : ndarray of shape `(n,n)`
        bilinear form to orthogonalize with respect to

    matrices : ndarray of shape `(..., k, n)`
        array of k row vectors to orthogonalize.

    Returns
    -------
    result : ndarray
        array with the same shape as `matrices`. The last two
        dimensions of this array give matrices with mutually
        orthogonal rows, with respect to the given bilinear form.

        For all `j &lt;= k`, the subspace spanned by the first `j` rows
        of `result` is the same as the subspace spanned by the first
        `j` rows of `matrices`.

    &#34;&#34;&#34;
    if len(matrices.shape) &lt; 2:
        return normalize(matrices, form)

    n, m = matrices.shape[-2:]

    result = np.zeros_like(matrices)

    #we&#39;re using a python for loop, but only over dimension^2 which
    #is probably small

    for i in range(n):
        row = matrices[..., i, :]
        for j in range(i):
            row -= projection(row, result[..., j, :], form)
        result[..., i, :] = row

    return normalize(result, form)

def find_isometry(form, partial_map, force_oriented=False):
    &#34;&#34;&#34;find a form-preserving matrix agreeing with a specified map on
    the flag defined by the standard basis.

    Parameters
    ----------
    form : ndarray of shape `(n, n)`
        the bilinear map to preserve

    partial_map : ndarray of shape `(..., k, n)`
        array representing the images of the first k standard basis
        vectors (row vectors)

    force_oriented : boolean
        whether we should apply a reflection to force the resulting
        map to be orientation-preserving.

    Returns
    -------
    ndarray
        array of shape `(..., n, n)` representing an array of matrices
        whose rows and columns are &#34;orthonormal&#34; with respect to the
        bilinear form (since the form may be indefinite, &#34;normal&#34;
        vectors may have norm -1).

        For all `j &lt;= k`, the subspace spanned by the first `j`
        standard basis vectors is sent to the subspace spanned by the
        first `j` rows of the result.

    &#34;&#34;&#34;

    orth_partial = indefinite_orthogonalize(form, partial_map)
    if len(orth_partial.shape) &lt; 2:
        orth_partial = np.expand_dims(orth_partial, axis=0)

    _, _, vh = np.linalg.svd(orth_partial @ form)

    kernel = vh[..., orth_partial.shape[-2]:, :]

    orth_kernel = indefinite_orthogonalize(form, kernel)
    iso = np.concatenate([orth_partial, orth_kernel], axis=-2)

    if force_oriented:
        iso = make_orientation_preserving(iso)

    return iso

def find_definite_isometry(partial_map, force_oriented=False):
    &#34;&#34;&#34;find an orthogonal matrix agreeing with a specified map on
    the flag defined by the standard basis.

    Parameters
    ----------
    partial_map : ndarray of shape `(..., k, n)`
        array representing the images of the first k standard basis
        vectors (row vectors)

    force_oriented : boolean
        whether we should apply a reflection to force the resulting
        map to be orientation-preserving.

    Returns
    -------
    ndarray
        array of shape `(..., n, n)` representing an array of matrices
        with orthonormal rows and columns.

        For all `j &lt;= k`, the subspace spanned by the first `j`
        standard basis vectors is sent to the subspace spanned by the
        first `j` rows of the result.

    &#34;&#34;&#34;
    pmap = np.array(partial_map)
    if len(pmap.shape) &lt; 2:
        pmap = pmap.reshape((len(pmap), 1))
    h, w = pmap.shape[-2:]
    n = max(h, w)
    if w &gt; h:
        mat = np.concatenate([pmap.swapaxes(-1, -2),
                             np.identity(n)], axis=-1)
    else:
        mat = np.concatenate([pmap, np.identity(n)], axis=-1)

    q, r = np.linalg.qr(mat)

    iso = np.sign(r[..., 0,0]) * q

    if force_oriented:
        iso = make_orientation_preserving(iso)

    return iso

def make_orientation_preserving(matrix):
    &#34;&#34;&#34;apply a reflection to the last row of matrix to make it orientation
    preserving.

    if matrix is already orientation preserving, do nothing.

    Parameters
    ----------
    matrix : ndarray of shape `(..., n, n)`
        ndarray of linear maps

    Returns
    -------
    result : ndarray
        array with the same shape as `matrices`, representating an
        ndarray of linear maps. If `A` is an orientation-reversing
        matrix in `matrices`, then the corresponding matrix in
        `result` has its last row negated.
    &#34;&#34;&#34;
    preserved = matrix.copy()
    preserved[np.linalg.det(preserved) &lt; 0, -1, :] *= -1
    return preserved

def expand_unit_axes(array, unit_axes, new_axes):
    &#34;&#34;&#34;expand the last axes of an array to make it suitable for ndarray
    pairwise multiplication.

    `array` is an ndarray, viewed as an array of arrays, each of which
    has `unit_axes` axes. That is, its shape decomposes into a pair of
    tuples `([axes 1], [axes 2])`, where `[axes 2]` is a tuple of
    length `unit_axes`.

    Parameters
    ----------
    array : ndarray
        ndarray to expand
    unit_axes : int
        number of axes of `array` to treat as a &#34;unit&#34;
    new_axes : int
        number of axes to add to the array

    Returns
    -------
    ndarray
        ndarray of shape `([object axes], 1, ..., 1, [unit axes])`,
        where the number of 1&#39;s is either `new_axes - unit_axes`, or 0
        if this is negative.

    &#34;&#34;&#34;
    if new_axes &lt;= unit_axes:
        return array

    return np.expand_dims(array.T, axis=tuple(range(unit_axes, new_axes))).T

def squeeze_excess(array, unit_axes, other_unit_axes):
    &#34;&#34;&#34;Squeeze all excess axes from an ndarray of arrays with unit_axes axes.

    This undoes expand_unit_axes.

    Parameters
    ----------
    array : ndarray
        ndarray of shape
        `([object axes], [excess axes], [unit axes])`, where `[unit axes]`
        is a tuple of length `unit_axes`, and `[excess axes]` is a
        tuple of length `other_unit_axes - unit_axes`.
    unit_axes : int
        number of axes to view as &#34;units&#34; in `array`. That is, `array`
        is viewed as an ndarray of arrays each with `unit_axes` axes.
    other_unit_axes : int
        axes to avoid squeezing when we reshape the array.

    Returns
    -------
    ndarray
        Reshaped array with certain length-1 axes removed. If the
        input array has shape
        `([object axes], [excess axes], [unit axes])`,
        squeeze out all the ones in `[excess axes]`.

    &#34;&#34;&#34;
    squeezable = np.array(array.T.shape[unit_axes:other_unit_axes])
    (to_squeeze,) = np.nonzero(squeezable == 1)
    to_squeeze += unit_axes

    return np.squeeze(array.T, axis=tuple(to_squeeze)).T

def matrix_product(array1, array2, unit_axis_1=2, unit_axis_2=2,
                   broadcast=&#34;elementwise&#34;):
    &#34;&#34;&#34;Multiply two ndarrays of ndarrays together.

    Each array in the input is viewed as an ndarray of smaller
    ndarrays with a specified number of axes. The shapes of these
    smaller arrays must broadcast against each other (i.e. be
    compatible with the numpy `@` operator).

    For the dimensions of the outer ndarray, the behavior of this
    function depends on the broadcast rule provided by the `broadcast`
    keyword.

    Parameters
    ----------
    array1, array2 : ndarray
        ndarrays of ndarrays to multiply together
    unit_axis_1, unit_axis_2 : int
        Each of `array1` and `array2` is viewed as an array with
        `unit_axis_1` and `unit_axis_2` ndims, respectively. By
        default both are set to 2, meaning this function multiplies a
        pair of ndarrays of matrices (2-dim arrays).
    broadcast : {&#39;elementwise&#39;, &#39;pairwise&#39;, &#39;pairwise_reversed&#39;}
        broadcast rule to use when multiplying arrays.

        If the broadcast rule is &#39;elementwise&#39; (the default), assume that
        the shape of one outer array broadcasts against the shape of
        the other outer array, and multiply with the same rules as the
        numpy `@` operator.

        If &#39;pairwise&#39;, multiply every element in the first outer array
        by every element in the second outer array, and return a new
        array of arrays with expanded axes. If &#39;pairwise_reversed&#39;, do
        the same thing, but use the axes of the second array first in
        the result.

    Returns
    -------
    result : ndarray

        result of matrix multiplication.

        If `array1` and `array2` have shapes
        `([outer ndims 1], [inner ndims 1])` and
        `([outer ndims 2], [inner ndims 2])` (where
        `[inner ndims]` are tuples with length `unit_axis_1` and
        `unit_axis_2`, respectively) then:

        - if `broadcast` is &#39;elementwise&#39;, `result` has shape
          `([result ndims], [product ndims])`, where `[result ndims]`
          is the result of broadcasting the outer ndims against each
          other, and `[product ndims]` is the result of broadcasting
          the inner ndims against each other.

        - if `broadcast` is &#39;pairwise&#39;, result has shape `([outer
          ndims 1], [outer ndims 2], [product ndims])`.

        - if `broadcast` is &#39;pairwise_reversed&#39;, result has shape
          `([outer ndims 2], [outer ndims 1], [product ndims])`

    &#34;&#34;&#34;

    reshape1 = expand_unit_axes(array1, unit_axis_1, unit_axis_2)
    reshape2 = expand_unit_axes(array2, unit_axis_2, unit_axis_1)

    if broadcast == &#34;pairwise&#34; or broadcast == &#34;pairwise_reversed&#34;:
        large_axes = max(unit_axis_1, unit_axis_2)

        excess1 = reshape1.ndim - large_axes
        excess2 = reshape2.ndim - large_axes

        if excess1 &gt; 0:
            if broadcast == &#34;pairwise_reversed&#34;:
                reshape1 = np.expand_dims(reshape1,
                                          axis=tuple(range(excess1, excess1 + excess2)))
            else:
                reshape1 = np.expand_dims(reshape1,
                                          axis=tuple(range(excess2)))

        if excess2 &gt; 0:
            if broadcast == &#34;pairwise_reversed&#34;:
                reshape2 = np.expand_dims(reshape2, axis=tuple(range(excess1)))
            else:
                reshape2 = np.expand_dims(reshape2,
                                          axis=tuple(range(excess2, excess1 + excess2)))

    product = reshape1 @ reshape2

    if unit_axis_1 &lt; unit_axis_2:
        product = squeeze_excess(product, unit_axis_1, unit_axis_2)

    return product

def find_positive_functional(positive_points):
    &#34;&#34;&#34;Find a dual vector which evaluates to a positive real on a given
       array of vectors, using scipy&#39;s linear programming routines.

    Parameters
    ----------
    positive_points : ndarray
        array of vectors to find a dual vector for. If this is a
        2-dimensional array, then find a single dual vector which is
        positive when paired with every row of the array.

        If the array has shape (..., k, n), then find an array of dual
        vectors such that the vectors in the array pair positively
        with the corresponding k vectors in positive_points.

    Returns
    -------
    duals : ndarray
        array of dual vectors. If positive_points has shape (d1, ...,
        dj, k, n), then `duals` has shape (d1, ..., dj, n).

    &#34;&#34;&#34;
    dim = positive_points.shape[-1]
    codim = positive_points.shape[-2]

    functionals = np.zeros(positive_points.shape[:-2] +
                           (positive_points.shape[-1],))

    for ind in np.ndindex(positive_points.shape[:-2]):
        res = linprog(
            np.zeros(dim),
            -1 * positive_points[ind],
            -1 * np.ones(codim),
            bounds=(None, None))

        if not res.success:
            return None

        functionals[ind] = res.x

    return normalize(functionals)

def invert_gen(generator):
    if generator.lower() == generator:
        return generator.upper()
    return generator.lower()

def first_sign_switch(array):
    signs = np.sign(array)
    row_i, col_i = np.nonzero(signs != np.expand_dims(signs[..., 0], axis=-1))
    _, init_inds = np.unique(row_i, return_index=True)
    return col_i[init_inds]

def circle_through(p1, p2, p3):
    &#34;&#34;&#34;Get the unique circle passing through three points in the plane.

    This does NOT check for colinearity and will just return nans in
    that case.

    Parameters
    ----------
    p1, p2, p3 : ndarray of shape `(..., 2)`
        Euclidean coordinates of three points in the plane (or three
        arrays of points)

    Returns
    -------
    tuple
        tuple of the form `(center, radius)`, where `center` is an
        ndarray containing Euclidean coordinates of the center of the
        determined circle, and `radius` is either a float or an
        ndarray containing the radius of the determined circle.

    &#34;&#34;&#34;
    t_p1 = p1 - p3
    t_p2 = p2 - p3

    x1 = t_p1[..., 0]
    y1 = t_p1[..., 1]

    x2 = t_p2[..., 0]
    y2 = t_p2[..., 1]

    r_sq = np.stack([x1**2 + y1**2, x2**2 + y2**2], axis=-1)
    r_sq = np.expand_dims(r_sq, axis=-2)

    mats = np.stack([t_p1, t_p2], axis=-1)

    # we&#39;ll act on the right
    t_ctrs = np.squeeze(r_sq @ np.linalg.inv(mats), axis=-2)/2.

    radii = np.linalg.norm(t_ctrs, axis=-1)

    return (t_ctrs + p3, radii)

def r_to_c(real_coords):
    return real_coords[..., 0] + real_coords[..., 1]*1.0j

def c_to_r(cx_array):
    return cx_array.astype(&#39;complex&#39;).view(&#39;(2,)float&#39;)

def order_eigs(eigenvalues, eigenvectors):
    &#34;&#34;&#34;Sort eigenvalue/eigenvector tuples by increasing modulus.

    This function accepts the eigenvalue/eigenvector data returned by
    the `np.linalg.eig` function.

    Parameters
    ----------
    eigenvalues : ndarray
        Array of shape (..., n) representing eigenvalues of some
        matrices
    eigenvectors : ndarray
        Array of shape (..., n, n) representing eigenvectors of some
        matrices (as column vectors).

    Returns
    -------
    tuple
        Tuple of the form `(eigvals, eigvecs)`, where both eigvals and
        eigvecs have the same data as the input arrays, but arranged
        so that eigenvalues and eigenvectors are in increasing order
        of modulus.

    &#34;&#34;&#34;
    eigorder = np.argsort(np.abs(eigenvalues), axis=-1)
    eigvecs = np.take_along_axis(eigenvectors, np.expand_dims(eigorder, axis=-2), axis=-1)
    eigvals = np.take_along_axis(eigenvalues, eigorder, axis=-1)

    return eigvals, eigvecs

def affine_disks_contain(cout, rout, cin, rin,
                         broadcast=&#34;elementwise&#34;):
    if broadcast == &#34;pairwise&#34;:
        pairwise_dists = np.linalg.norm(
            np.expand_dims(cout, 0) - np.expand_dims(cin, 1),
            axis=-1
        )
        radial_diffs = np.expand_dims(rout, 0) - np.expand_dims(rin, 1)
        return pairwise_dists &lt; radial_diffs

    return np.linalg.norm(cout - cin, axis=-1) &lt; (rout - rin)


def disk_containments(c1, r1, c2, r2,
                      broadcast=&#34;elementwise&#34;):
    if broadcast == &#34;pairwise&#34;:
        pairwise_dists = np.linalg.norm(
            np.expand_dims(cout, 0) - np.expand_dims(cin, 1),
            axis=-1
        )
        radial_diff1 = np.expand_dims(rout, 0) - np.expand_dims(rin, 1)
        return (pairwise_dists &lt; radial_diffs,
                pairwise_dists &lt; -radial_diffs)

    dists = np.linalg.norm(cout - cin, axis=-1)
    return (dists &lt; (rout - rin),
            dists &lt; (rin - rout))

def disk_interactions(c1, r1, c2, r2,
                      broadcast=&#34;elementwise&#34;):
    # WARNING: this will only work for Nx2 arrays
    if broadcast == &#34;pairwise&#34;:
        pairwise_dists = np.linalg.norm(
            np.expand_dims(c1, 1) - np.expand_dims(c2, 0),
            axis=-1
        )
        radial_diff = np.expand_dims(r1, 1) - np.expand_dims(r2, 0)
        radial_sum = np.expand_dims(r1, 1) + np.expand_dims(r2, 0)
        return (pairwise_dists &lt; radial_diff,
                pairwise_dists &lt; -radial_diff,
                pairwise_dists &lt; radial_sum)

    dists = np.linalg.norm(c1 - c2, axis=-1)

    return (dists &lt; (r1 - r2),
            dists &lt; (r2 - r1),
            dists &lt; (r2 + r1))</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="geometry_tools.utils.cp1" href="cp1.html">geometry_tools.utils.cp1</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geometry_tools.utils.affine_disks_contain"><code class="name flex">
<span>def <span class="ident">affine_disks_contain</span></span>(<span>cout, rout, cin, rin, broadcast='elementwise')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affine_disks_contain(cout, rout, cin, rin,
                         broadcast=&#34;elementwise&#34;):
    if broadcast == &#34;pairwise&#34;:
        pairwise_dists = np.linalg.norm(
            np.expand_dims(cout, 0) - np.expand_dims(cin, 1),
            axis=-1
        )
        radial_diffs = np.expand_dims(rout, 0) - np.expand_dims(rin, 1)
        return pairwise_dists &lt; radial_diffs

    return np.linalg.norm(cout - cin, axis=-1) &lt; (rout - rin)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.apply_bilinear"><code class="name flex">
<span>def <span class="ident">apply_bilinear</span></span>(<span>v1, v2, bilinear_form=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a bilinar form to a pair of arrays of vectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v1</code></strong>, <strong><code>v2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>ndarrays of shape (&hellip;, n) giving arrays of vectors.</dd>
<dt><strong><code>bilinear_form</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>ndarray of shape (n, n) specifying a matrix representing a
symmetric bilinear form to use to pair v1 and v2. If
<code>None</code>, use the standard (Euclidean) bilinear form on R^n.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>ndarray representing the result of pairing the vectors in v1
with v2.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_bilinear(v1, v2, bilinear_form=None):
    &#34;&#34;&#34;Apply a bilinar form to a pair of arrays of vectors.

    Parameters
    ----------
    v1, v2: ndarray
        ndarrays of shape (..., n) giving arrays of vectors.
    bilinear_form: ndarray
        ndarray of shape (n, n) specifying a matrix representing a
        symmetric bilinear form to use to pair v1 and v2. If
        `None`, use the standard (Euclidean) bilinear form on R^n.

    Returns
    -------
    ndarray
        ndarray representing the result of pairing the vectors in v1
        with v2.

    &#34;&#34;&#34;

    if bilinear_form is None:
        bilinear_form = np.identity(v1.shape[-1])

    return ((v1 @ bilinear_form) * v2).sum(-1)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.arc_include"><code class="name flex">
<span>def <span class="ident">arc_include</span></span>(<span>thetas, reference_theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder angles so that the counterclockwise arc between them always
includes some reference point on the circle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thetas</code></strong> :&ensp;<code>ndarray(float)</code></dt>
<dd>pairs of angles in the range (-2pi, 2pi).</dd>
<dt><strong><code>reference_theta</code></strong> :&ensp;<code>ndarray(float)</code></dt>
<dd>angles in the range (-2pi, 2pi)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>theta_p</code></strong> :&ensp;<code>ndarray(float)</code></dt>
<dd>pairs of angles of the same shape as <code>thetas</code>, so that
<code>reference_theta</code> lies in the counterclockwise angle between
<code>theta_p[&hellip;, 0]</code> and <code>theta_p[&hellip;, 1]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arc_include(thetas, reference_theta):
    &#34;&#34;&#34;Reorder angles so that the counterclockwise arc between them always
    includes some reference point on the circle.

    Parameters
    ----------
    thetas : ndarray(float)
        pairs of angles in the range (-2pi, 2pi).
    reference_theta: ndarray(float)
         angles in the range (-2pi, 2pi)

    Returns
    -------
    theta_p : ndarray(float)
        pairs of angles of the same shape as `thetas`, so that
        `reference_theta` lies in the counterclockwise angle between
        `theta_p[..., 0]` and `theta_p[..., 1]`.

    &#34;&#34;&#34;

    s_thetas = np.copy(thetas)
    s_theta1 = thetas[..., 1] - thetas[..., 0]
    s_reference = np.expand_dims(reference_theta - thetas[..., 0],
                                 axis=-1)

    s_theta1[s_theta1 &lt; 0] += 2 * np.pi
    s_reference[s_reference &lt; 0] += 2 * np.pi

    to_swap = (s_theta1 &lt; s_reference[..., 0])

    s_thetas[to_swap] = np.flip(s_thetas[to_swap], axis=-1)
    return s_thetas</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.c_to_r"><code class="name flex">
<span>def <span class="ident">c_to_r</span></span>(<span>cx_array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def c_to_r(cx_array):
    return cx_array.astype(&#39;complex&#39;).view(&#39;(2,)float&#39;)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.circle_angles"><code class="name flex">
<span>def <span class="ident">circle_angles</span></span>(<span>center, coords)</span>
</code></dt>
<dd>
<div class="desc"><p>Return angles relative to the center of a circle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>numpy array with shape (&hellip;, 2) representing x,y coordinates
the centers of some circles.</dd>
<dt><strong><code>coords</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>numpy array with shape (&hellip;, 2) representing x,y coordinates
of some points.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>angles (relative to x-axis) of each of the pair of points
specified by coords.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_angles(center, coords):
    &#34;&#34;&#34;Return angles relative to the center of a circle.

    Parameters
    ----------
    center: ndarray
        numpy array with shape (..., 2) representing x,y coordinates
        the centers of some circles.
    coords: ndarray
        numpy array with shape (..., 2) representing x,y coordinates
        of some points.

    Returns
    -------
    ndarray
        angles (relative to x-axis) of each of the pair of points
        specified by coords.

    &#34;&#34;&#34;
    xs = (coords - np.expand_dims(center, axis=-2))[..., 0]
    ys = (coords - np.expand_dims(center, axis=-2))[..., 1]

    return np.arctan2(ys, xs)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.circle_through"><code class="name flex">
<span>def <span class="ident">circle_through</span></span>(<span>p1, p2, p3)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the unique circle passing through three points in the plane.</p>
<p>This does NOT check for colinearity and will just return nans in
that case.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p1</code></strong>, <strong><code>p2</code></strong>, <strong><code>p3</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(&hellip;, 2)``</dt>
<dd>Euclidean coordinates of three points in the plane (or three
arrays of points)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>tuple of the form <code>(center, radius)</code>, where <code>center</code> is an
ndarray containing Euclidean coordinates of the center of the
determined circle, and <code>radius</code> is either a float or an
ndarray containing the radius of the determined circle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle_through(p1, p2, p3):
    &#34;&#34;&#34;Get the unique circle passing through three points in the plane.

    This does NOT check for colinearity and will just return nans in
    that case.

    Parameters
    ----------
    p1, p2, p3 : ndarray of shape `(..., 2)`
        Euclidean coordinates of three points in the plane (or three
        arrays of points)

    Returns
    -------
    tuple
        tuple of the form `(center, radius)`, where `center` is an
        ndarray containing Euclidean coordinates of the center of the
        determined circle, and `radius` is either a float or an
        ndarray containing the radius of the determined circle.

    &#34;&#34;&#34;
    t_p1 = p1 - p3
    t_p2 = p2 - p3

    x1 = t_p1[..., 0]
    y1 = t_p1[..., 1]

    x2 = t_p2[..., 0]
    y2 = t_p2[..., 1]

    r_sq = np.stack([x1**2 + y1**2, x2**2 + y2**2], axis=-1)
    r_sq = np.expand_dims(r_sq, axis=-2)

    mats = np.stack([t_p1, t_p2], axis=-1)

    # we&#39;ll act on the right
    t_ctrs = np.squeeze(r_sq @ np.linalg.inv(mats), axis=-2)/2.

    radii = np.linalg.norm(t_ctrs, axis=-1)

    return (t_ctrs + p3, radii)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.diagonalize_form"><code class="name flex">
<span>def <span class="ident">diagonalize_form</span></span>(<span>bilinear_form, order_eigenvalues='signed', reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a matrix conjugating a symmetric real bilinear form to a
diagonal form.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bilinear_form</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>numpy array of shape (n, n) representing, a symmetric bilinear
form in standard coordinates</dd>
<dt><strong><code>order_eigenvalues</code></strong> :&ensp;<code>{'signed', 'minkowski'}</code></dt>
<dd>
<p>If "signed" (the default), conjugate to a diagonal bilinear
form on R^n, whose eigenvectors are ordered in order of
increasing eigenvalue.</p>
<p>If "minkowski", conjugate to a diagonal bilinear form whose
basis vectors are ordered so that lightlike basis vectors come
first, followed by spacelike basis vectors, followed by
timelike basis vectors. (lightlike vectors pair to a negative
value under the form, spacelike vectors pair to a positive
value, and timelike vectors pair to zero).</p>
</dd>
<dt><strong><code>reverse</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, reverse the order of the basis vectors for the
diagonal bilinear form (from the order specified by
<code>order_eigenvalues</code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>numpy array of shape (n, n), representing a coordinate change
taking the given bilinear form to a diagonal form. If <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is
the matrix given by bilinear_form, and <span><span class="MathJax_Preview">D</span><script type="math/tex">D</script></span> is a diagonal
matrix with the same signature as <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>, then this function
returns a matrix <span><span class="MathJax_Preview">M</span><script type="math/tex">M</script></span> such that <span><span class="MathJax_Preview">M^TDM = B</span><script type="math/tex">M^TDM = B</script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagonalize_form(bilinear_form, order_eigenvalues=&#34;signed&#34;, reverse=False):
    r&#34;&#34;&#34;Return a matrix conjugating a symmetric real bilinear form to a
    diagonal form.

    Parameters
    ----------
    bilinear_form: ndarray
        numpy array of shape (n, n) representing, a symmetric bilinear
        form in standard coordinates
    order_eigenvalues: {&#39;signed&#39;, &#39;minkowski&#39;}
        If &#34;signed&#34; (the default), conjugate to a diagonal bilinear
        form on R^n, whose eigenvectors are ordered in order of
        increasing eigenvalue.

        If &#34;minkowski&#34;, conjugate to a diagonal bilinear form whose
        basis vectors are ordered so that lightlike basis vectors come
        first, followed by spacelike basis vectors, followed by
        timelike basis vectors. (lightlike vectors pair to a negative
        value under the form, spacelike vectors pair to a positive
        value, and timelike vectors pair to zero).
    reverse : bool
        if True, reverse the order of the basis vectors for the
        diagonal bilinear form (from the order specified by
        `order_eigenvalues`).

    Returns
    -------
    ndarray
        numpy array of shape (n, n), representing a coordinate change
        taking the given bilinear form to a diagonal form. If \(B\) is
        the matrix given by bilinear_form, and \(D\) is a diagonal
        matrix with the same signature as \(B\), then this function
        returns a matrix \(M\) such that \(M^TDM = B\).

    &#34;&#34;&#34;
    n, _ = bilinear_form.shape

    eigs, U = np.linalg.eigh(bilinear_form)
    D = np.diag(1 / np.sqrt(np.abs(eigs)))


    perm = np.identity(n)

    if order_eigenvalues:
        if order_eigenvalues == &#34;signed&#34;:
            order = np.argsort(eigs)
        if order_eigenvalues == &#34;minkowski&#34;:
            negative = np.count_nonzero(eigs &lt; 0)
            positive = np.count_nonzero(eigs &gt; 0)

            if negative &lt;= positive:
                order = np.concatenate(
                    ((eigs &lt; 0).nonzero()[0],
                     (eigs &gt; 0).nonzero()[0],
                     (eigs == 0).nonzero()[0])
                )
            else:
                order = np.concatenate(
                    ((eigs &gt; 0).nonzero()[0],
                     (eigs &lt; 0).nonzero()[0],
                     (eigs == 0).nonzero()[0])
                )
        if reverse:
            order = np.flip(order)

        perm = permutation_matrix(order)

    W = U @ D @ np.linalg.inv(perm)

    return W</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.disk_containments"><code class="name flex">
<span>def <span class="ident">disk_containments</span></span>(<span>c1, r1, c2, r2, broadcast='elementwise')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disk_containments(c1, r1, c2, r2,
                      broadcast=&#34;elementwise&#34;):
    if broadcast == &#34;pairwise&#34;:
        pairwise_dists = np.linalg.norm(
            np.expand_dims(cout, 0) - np.expand_dims(cin, 1),
            axis=-1
        )
        radial_diff1 = np.expand_dims(rout, 0) - np.expand_dims(rin, 1)
        return (pairwise_dists &lt; radial_diffs,
                pairwise_dists &lt; -radial_diffs)

    dists = np.linalg.norm(cout - cin, axis=-1)
    return (dists &lt; (rout - rin),
            dists &lt; (rin - rout))</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.disk_interactions"><code class="name flex">
<span>def <span class="ident">disk_interactions</span></span>(<span>c1, r1, c2, r2, broadcast='elementwise')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disk_interactions(c1, r1, c2, r2,
                      broadcast=&#34;elementwise&#34;):
    # WARNING: this will only work for Nx2 arrays
    if broadcast == &#34;pairwise&#34;:
        pairwise_dists = np.linalg.norm(
            np.expand_dims(c1, 1) - np.expand_dims(c2, 0),
            axis=-1
        )
        radial_diff = np.expand_dims(r1, 1) - np.expand_dims(r2, 0)
        radial_sum = np.expand_dims(r1, 1) + np.expand_dims(r2, 0)
        return (pairwise_dists &lt; radial_diff,
                pairwise_dists &lt; -radial_diff,
                pairwise_dists &lt; radial_sum)

    dists = np.linalg.norm(c1 - c2, axis=-1)

    return (dists &lt; (r1 - r2),
            dists &lt; (r2 - r1),
            dists &lt; (r2 + r1))</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.expand_unit_axes"><code class="name flex">
<span>def <span class="ident">expand_unit_axes</span></span>(<span>array, unit_axes, new_axes)</span>
</code></dt>
<dd>
<div class="desc"><p>expand the last axes of an array to make it suitable for ndarray
pairwise multiplication.</p>
<p><code>array</code> is an ndarray, viewed as an array of arrays, each of which
has <code>unit_axes</code> axes. That is, its shape decomposes into a pair of
tuples <code>([axes 1], [axes 2])</code>, where <code>[axes 2]</code> is a tuple of
length <code>unit_axes</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>ndarray to expand</dd>
<dt><strong><code>unit_axes</code></strong> :&ensp;<code>int</code></dt>
<dd>number of axes of <code>array</code> to treat as a "unit"</dd>
<dt><strong><code>new_axes</code></strong> :&ensp;<code>int</code></dt>
<dd>number of axes to add to the array</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>ndarray of shape <code>([object axes], 1, &hellip;, 1, [unit axes])</code>,
where the number of 1's is either <code>new_axes - unit_axes</code>, or 0
if this is negative.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand_unit_axes(array, unit_axes, new_axes):
    &#34;&#34;&#34;expand the last axes of an array to make it suitable for ndarray
    pairwise multiplication.

    `array` is an ndarray, viewed as an array of arrays, each of which
    has `unit_axes` axes. That is, its shape decomposes into a pair of
    tuples `([axes 1], [axes 2])`, where `[axes 2]` is a tuple of
    length `unit_axes`.

    Parameters
    ----------
    array : ndarray
        ndarray to expand
    unit_axes : int
        number of axes of `array` to treat as a &#34;unit&#34;
    new_axes : int
        number of axes to add to the array

    Returns
    -------
    ndarray
        ndarray of shape `([object axes], 1, ..., 1, [unit axes])`,
        where the number of 1&#39;s is either `new_axes - unit_axes`, or 0
        if this is negative.

    &#34;&#34;&#34;
    if new_axes &lt;= unit_axes:
        return array

    return np.expand_dims(array.T, axis=tuple(range(unit_axes, new_axes))).T</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.find_definite_isometry"><code class="name flex">
<span>def <span class="ident">find_definite_isometry</span></span>(<span>partial_map, force_oriented=False)</span>
</code></dt>
<dd>
<div class="desc"><p>find an orthogonal matrix agreeing with a specified map on
the flag defined by the standard basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>partial_map</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(&hellip;, k, n)``</dt>
<dd>array representing the images of the first k standard basis
vectors (row vectors)</dd>
<dt><strong><code>force_oriented</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether we should apply a reflection to force the resulting
map to be orientation-preserving.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>
<p>array of shape <code>(&hellip;, n, n)</code> representing an array of matrices
with orthonormal rows and columns.</p>
<p>For all <code>j &lt;= k</code>, the subspace spanned by the first <code>j</code>
standard basis vectors is sent to the subspace spanned by the
first <code>j</code> rows of the result.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_definite_isometry(partial_map, force_oriented=False):
    &#34;&#34;&#34;find an orthogonal matrix agreeing with a specified map on
    the flag defined by the standard basis.

    Parameters
    ----------
    partial_map : ndarray of shape `(..., k, n)`
        array representing the images of the first k standard basis
        vectors (row vectors)

    force_oriented : boolean
        whether we should apply a reflection to force the resulting
        map to be orientation-preserving.

    Returns
    -------
    ndarray
        array of shape `(..., n, n)` representing an array of matrices
        with orthonormal rows and columns.

        For all `j &lt;= k`, the subspace spanned by the first `j`
        standard basis vectors is sent to the subspace spanned by the
        first `j` rows of the result.

    &#34;&#34;&#34;
    pmap = np.array(partial_map)
    if len(pmap.shape) &lt; 2:
        pmap = pmap.reshape((len(pmap), 1))
    h, w = pmap.shape[-2:]
    n = max(h, w)
    if w &gt; h:
        mat = np.concatenate([pmap.swapaxes(-1, -2),
                             np.identity(n)], axis=-1)
    else:
        mat = np.concatenate([pmap, np.identity(n)], axis=-1)

    q, r = np.linalg.qr(mat)

    iso = np.sign(r[..., 0,0]) * q

    if force_oriented:
        iso = make_orientation_preserving(iso)

    return iso</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.find_isometry"><code class="name flex">
<span>def <span class="ident">find_isometry</span></span>(<span>form, partial_map, force_oriented=False)</span>
</code></dt>
<dd>
<div class="desc"><p>find a form-preserving matrix agreeing with a specified map on
the flag defined by the standard basis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>form</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(n, n)``</dt>
<dd>the bilinear map to preserve</dd>
<dt><strong><code>partial_map</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(&hellip;, k, n)``</dt>
<dd>array representing the images of the first k standard basis
vectors (row vectors)</dd>
<dt><strong><code>force_oriented</code></strong> :&ensp;<code>boolean</code></dt>
<dd>whether we should apply a reflection to force the resulting
map to be orientation-preserving.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>
<p>array of shape <code>(&hellip;, n, n)</code> representing an array of matrices
whose rows and columns are "orthonormal" with respect to the
bilinear form (since the form may be indefinite, "normal"
vectors may have norm -1).</p>
<p>For all <code>j &lt;= k</code>, the subspace spanned by the first <code>j</code>
standard basis vectors is sent to the subspace spanned by the
first <code>j</code> rows of the result.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_isometry(form, partial_map, force_oriented=False):
    &#34;&#34;&#34;find a form-preserving matrix agreeing with a specified map on
    the flag defined by the standard basis.

    Parameters
    ----------
    form : ndarray of shape `(n, n)`
        the bilinear map to preserve

    partial_map : ndarray of shape `(..., k, n)`
        array representing the images of the first k standard basis
        vectors (row vectors)

    force_oriented : boolean
        whether we should apply a reflection to force the resulting
        map to be orientation-preserving.

    Returns
    -------
    ndarray
        array of shape `(..., n, n)` representing an array of matrices
        whose rows and columns are &#34;orthonormal&#34; with respect to the
        bilinear form (since the form may be indefinite, &#34;normal&#34;
        vectors may have norm -1).

        For all `j &lt;= k`, the subspace spanned by the first `j`
        standard basis vectors is sent to the subspace spanned by the
        first `j` rows of the result.

    &#34;&#34;&#34;

    orth_partial = indefinite_orthogonalize(form, partial_map)
    if len(orth_partial.shape) &lt; 2:
        orth_partial = np.expand_dims(orth_partial, axis=0)

    _, _, vh = np.linalg.svd(orth_partial @ form)

    kernel = vh[..., orth_partial.shape[-2]:, :]

    orth_kernel = indefinite_orthogonalize(form, kernel)
    iso = np.concatenate([orth_partial, orth_kernel], axis=-2)

    if force_oriented:
        iso = make_orientation_preserving(iso)

    return iso</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.find_positive_functional"><code class="name flex">
<span>def <span class="ident">find_positive_functional</span></span>(<span>positive_points)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a dual vector which evaluates to a positive real on a given
array of vectors, using scipy's linear programming routines.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>positive_points</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>
<p>array of vectors to find a dual vector for. If this is a
2-dimensional array, then find a single dual vector which is
positive when paired with every row of the array.</p>
<p>If the array has shape (&hellip;, k, n), then find an array of dual
vectors such that the vectors in the array pair positively
with the corresponding k vectors in positive_points.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>duals</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>array of dual vectors. If positive_points has shape (d1, &hellip;,
dj, k, n), then <code>duals</code> has shape (d1, &hellip;, dj, n).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_positive_functional(positive_points):
    &#34;&#34;&#34;Find a dual vector which evaluates to a positive real on a given
       array of vectors, using scipy&#39;s linear programming routines.

    Parameters
    ----------
    positive_points : ndarray
        array of vectors to find a dual vector for. If this is a
        2-dimensional array, then find a single dual vector which is
        positive when paired with every row of the array.

        If the array has shape (..., k, n), then find an array of dual
        vectors such that the vectors in the array pair positively
        with the corresponding k vectors in positive_points.

    Returns
    -------
    duals : ndarray
        array of dual vectors. If positive_points has shape (d1, ...,
        dj, k, n), then `duals` has shape (d1, ..., dj, n).

    &#34;&#34;&#34;
    dim = positive_points.shape[-1]
    codim = positive_points.shape[-2]

    functionals = np.zeros(positive_points.shape[:-2] +
                           (positive_points.shape[-1],))

    for ind in np.ndindex(positive_points.shape[:-2]):
        res = linprog(
            np.zeros(dim),
            -1 * positive_points[ind],
            -1 * np.ones(codim),
            bounds=(None, None))

        if not res.success:
            return None

        functionals[ind] = res.x

    return normalize(functionals)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.first_sign_switch"><code class="name flex">
<span>def <span class="ident">first_sign_switch</span></span>(<span>array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_sign_switch(array):
    signs = np.sign(array)
    row_i, col_i = np.nonzero(signs != np.expand_dims(signs[..., 0], axis=-1))
    _, init_inds = np.unique(row_i, return_index=True)
    return col_i[init_inds]</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.indefinite_orthogonalize"><code class="name flex">
<span>def <span class="ident">indefinite_orthogonalize</span></span>(<span>form, matrices)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the Gram-Schmidt algorithm, but for a possibly indefinite
bilinear form.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>form</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(n,n)``</dt>
<dd>bilinear form to orthogonalize with respect to</dd>
<dt><strong><code>matrices</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(&hellip;, k, n)``</dt>
<dd>array of k row vectors to orthogonalize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>
<p>array with the same shape as <code>matrices</code>. The last two
dimensions of this array give matrices with mutually
orthogonal rows, with respect to the given bilinear form.</p>
<p>For all <code>j &lt;= k</code>, the subspace spanned by the first <code>j</code> rows
of <code>result</code> is the same as the subspace spanned by the first
<code>j</code> rows of <code>matrices</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indefinite_orthogonalize(form, matrices):
    &#34;&#34;&#34;Apply the Gram-Schmidt algorithm, but for a possibly indefinite
    bilinear form.

    Parameters
    ----------
    form : ndarray of shape `(n,n)`
        bilinear form to orthogonalize with respect to

    matrices : ndarray of shape `(..., k, n)`
        array of k row vectors to orthogonalize.

    Returns
    -------
    result : ndarray
        array with the same shape as `matrices`. The last two
        dimensions of this array give matrices with mutually
        orthogonal rows, with respect to the given bilinear form.

        For all `j &lt;= k`, the subspace spanned by the first `j` rows
        of `result` is the same as the subspace spanned by the first
        `j` rows of `matrices`.

    &#34;&#34;&#34;
    if len(matrices.shape) &lt; 2:
        return normalize(matrices, form)

    n, m = matrices.shape[-2:]

    result = np.zeros_like(matrices)

    #we&#39;re using a python for loop, but only over dimension^2 which
    #is probably small

    for i in range(n):
        row = matrices[..., i, :]
        for j in range(i):
            row -= projection(row, result[..., j, :], form)
        result[..., i, :] = row

    return normalize(result, form)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.invert_gen"><code class="name flex">
<span>def <span class="ident">invert_gen</span></span>(<span>generator)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert_gen(generator):
    if generator.lower() == generator:
        return generator.upper()
    return generator.lower()</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.make_orientation_preserving"><code class="name flex">
<span>def <span class="ident">make_orientation_preserving</span></span>(<span>matrix)</span>
</code></dt>
<dd>
<div class="desc"><p>apply a reflection to the last row of matrix to make it orientation
preserving.</p>
<p>if matrix is already orientation preserving, do nothing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>ndarray</code> of <code>shape </code>(&hellip;, n, n)``</dt>
<dd>ndarray of linear maps</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>array with the same shape as <code>matrices</code>, representating an
ndarray of linear maps. If <code>A</code> is an orientation-reversing
matrix in <code>matrices</code>, then the corresponding matrix in
<code>result</code> has its last row negated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_orientation_preserving(matrix):
    &#34;&#34;&#34;apply a reflection to the last row of matrix to make it orientation
    preserving.

    if matrix is already orientation preserving, do nothing.

    Parameters
    ----------
    matrix : ndarray of shape `(..., n, n)`
        ndarray of linear maps

    Returns
    -------
    result : ndarray
        array with the same shape as `matrices`, representating an
        ndarray of linear maps. If `A` is an orientation-reversing
        matrix in `matrices`, then the corresponding matrix in
        `result` has its last row negated.
    &#34;&#34;&#34;
    preserved = matrix.copy()
    preserved[np.linalg.det(preserved) &lt; 0, -1, :] *= -1
    return preserved</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.matrix_product"><code class="name flex">
<span>def <span class="ident">matrix_product</span></span>(<span>array1, array2, unit_axis_1=2, unit_axis_2=2, broadcast='elementwise')</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply two ndarrays of ndarrays together.</p>
<p>Each array in the input is viewed as an ndarray of smaller
ndarrays with a specified number of axes. The shapes of these
smaller arrays must broadcast against each other (i.e. be
compatible with the numpy <code>@</code> operator).</p>
<p>For the dimensions of the outer ndarray, the behavior of this
function depends on the broadcast rule provided by the <code>broadcast</code>
keyword.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array1</code></strong>, <strong><code>array2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>ndarrays of ndarrays to multiply together</dd>
<dt><strong><code>unit_axis_1</code></strong>, <strong><code>unit_axis_2</code></strong> :&ensp;<code>int</code></dt>
<dd>Each of <code>array1</code> and <code>array2</code> is viewed as an array with
<code>unit_axis_1</code> and <code>unit_axis_2</code> ndims, respectively. By
default both are set to 2, meaning this function multiplies a
pair of ndarrays of matrices (2-dim arrays).</dd>
<dt><strong><code>broadcast</code></strong> :&ensp;<code>{'elementwise', 'pairwise', 'pairwise_reversed'}</code></dt>
<dd>
<p>broadcast rule to use when multiplying arrays.</p>
<p>If the broadcast rule is 'elementwise' (the default), assume that
the shape of one outer array broadcasts against the shape of
the other outer array, and multiply with the same rules as the
numpy <code>@</code> operator.</p>
<p>If 'pairwise', multiply every element in the first outer array
by every element in the second outer array, and return a new
array of arrays with expanded axes. If 'pairwise_reversed', do
the same thing, but use the axes of the second array first in
the result.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>
<p>result of matrix multiplication.</p>
<p>If <code>array1</code> and <code>array2</code> have shapes
<code>([outer ndims 1], [inner ndims 1])</code> and
<code>([outer ndims 2], [inner ndims 2])</code> (where
<code>[inner ndims]</code> are tuples with length <code>unit_axis_1</code> and
<code>unit_axis_2</code>, respectively) then:</p>
<ul>
<li>
<p>if <code>broadcast</code> is 'elementwise', <code>result</code> has shape
<code>([result ndims], [product ndims])</code>, where <code>[result ndims]</code>
is the result of broadcasting the outer ndims against each
other, and <code>[product ndims]</code> is the result of broadcasting
the inner ndims against each other.</p>
</li>
<li>
<p>if <code>broadcast</code> is 'pairwise', result has shape <code>([outer
ndims 1], [outer ndims 2], [product ndims])</code>.</p>
</li>
<li>
<p>if <code>broadcast</code> is 'pairwise_reversed', result has shape
<code>([outer ndims 2], [outer ndims 1], [product ndims])</code></p>
</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def matrix_product(array1, array2, unit_axis_1=2, unit_axis_2=2,
                   broadcast=&#34;elementwise&#34;):
    &#34;&#34;&#34;Multiply two ndarrays of ndarrays together.

    Each array in the input is viewed as an ndarray of smaller
    ndarrays with a specified number of axes. The shapes of these
    smaller arrays must broadcast against each other (i.e. be
    compatible with the numpy `@` operator).

    For the dimensions of the outer ndarray, the behavior of this
    function depends on the broadcast rule provided by the `broadcast`
    keyword.

    Parameters
    ----------
    array1, array2 : ndarray
        ndarrays of ndarrays to multiply together
    unit_axis_1, unit_axis_2 : int
        Each of `array1` and `array2` is viewed as an array with
        `unit_axis_1` and `unit_axis_2` ndims, respectively. By
        default both are set to 2, meaning this function multiplies a
        pair of ndarrays of matrices (2-dim arrays).
    broadcast : {&#39;elementwise&#39;, &#39;pairwise&#39;, &#39;pairwise_reversed&#39;}
        broadcast rule to use when multiplying arrays.

        If the broadcast rule is &#39;elementwise&#39; (the default), assume that
        the shape of one outer array broadcasts against the shape of
        the other outer array, and multiply with the same rules as the
        numpy `@` operator.

        If &#39;pairwise&#39;, multiply every element in the first outer array
        by every element in the second outer array, and return a new
        array of arrays with expanded axes. If &#39;pairwise_reversed&#39;, do
        the same thing, but use the axes of the second array first in
        the result.

    Returns
    -------
    result : ndarray

        result of matrix multiplication.

        If `array1` and `array2` have shapes
        `([outer ndims 1], [inner ndims 1])` and
        `([outer ndims 2], [inner ndims 2])` (where
        `[inner ndims]` are tuples with length `unit_axis_1` and
        `unit_axis_2`, respectively) then:

        - if `broadcast` is &#39;elementwise&#39;, `result` has shape
          `([result ndims], [product ndims])`, where `[result ndims]`
          is the result of broadcasting the outer ndims against each
          other, and `[product ndims]` is the result of broadcasting
          the inner ndims against each other.

        - if `broadcast` is &#39;pairwise&#39;, result has shape `([outer
          ndims 1], [outer ndims 2], [product ndims])`.

        - if `broadcast` is &#39;pairwise_reversed&#39;, result has shape
          `([outer ndims 2], [outer ndims 1], [product ndims])`

    &#34;&#34;&#34;

    reshape1 = expand_unit_axes(array1, unit_axis_1, unit_axis_2)
    reshape2 = expand_unit_axes(array2, unit_axis_2, unit_axis_1)

    if broadcast == &#34;pairwise&#34; or broadcast == &#34;pairwise_reversed&#34;:
        large_axes = max(unit_axis_1, unit_axis_2)

        excess1 = reshape1.ndim - large_axes
        excess2 = reshape2.ndim - large_axes

        if excess1 &gt; 0:
            if broadcast == &#34;pairwise_reversed&#34;:
                reshape1 = np.expand_dims(reshape1,
                                          axis=tuple(range(excess1, excess1 + excess2)))
            else:
                reshape1 = np.expand_dims(reshape1,
                                          axis=tuple(range(excess2)))

        if excess2 &gt; 0:
            if broadcast == &#34;pairwise_reversed&#34;:
                reshape2 = np.expand_dims(reshape2, axis=tuple(range(excess1)))
            else:
                reshape2 = np.expand_dims(reshape2,
                                          axis=tuple(range(excess2, excess1 + excess2)))

    product = reshape1 @ reshape2

    if unit_axis_1 &lt; unit_axis_2:
        product = squeeze_excess(product, unit_axis_1, unit_axis_2)

    return product</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>vectors, bilinear_form=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize an array of vectors, with respect to a bilinear form.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vectors</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>ndarray of shape (&hellip;, n)</dd>
<dt><strong><code>bilinear_form</code></strong> :&ensp;<code>ndarray</code> or <code>None</code></dt>
<dd>bilinear form to use to evaluate the norms in vectors. If
None, use the standard (Euclidean) bilinear form on R^n.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>ndarray with the same shape as vectors. Each vector in this
array has norm either +1 or -1, depending on whether the
original vector had positive or negative square-norm (with
respect to the given bilinear form).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(vectors, bilinear_form=None):
    &#34;&#34;&#34;Normalize an array of vectors, with respect to a bilinear form.

    Parameters
    ----------
    vectors: ndarray
        ndarray of shape (..., n)
    bilinear_form: ndarray or None
        bilinear form to use to evaluate the norms in vectors. If
        None, use the standard (Euclidean) bilinear form on R^n.

    Returns
    -------
    ndarray
        ndarray with the same shape as vectors. Each vector in this
        array has norm either +1 or -1, depending on whether the
        original vector had positive or negative square-norm (with
        respect to the given bilinear form).

    &#34;&#34;&#34;
    norms = normsq(vectors, bilinear_form)
    return vectors / np.sqrt(np.abs(np.expand_dims(norms, axis=-1)))</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.normsq"><code class="name flex">
<span>def <span class="ident">normsq</span></span>(<span>vectors, bilinear_form=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the norm squared of an array of vectors, with respect to a
bilinear form.</p>
<p>Equivalent to a call of apply_bilinear(vectors, vectors, bilinear_form).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normsq(vectors, bilinear_form=None):
    &#34;&#34;&#34;Evaluate the norm squared of an array of vectors, with respect to a
       bilinear form.

    Equivalent to a call of apply_bilinear(vectors, vectors, bilinear_form).

    &#34;&#34;&#34;
    return apply_bilinear(vectors, vectors, bilinear_form)</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.order_eigs"><code class="name flex">
<span>def <span class="ident">order_eigs</span></span>(<span>eigenvalues, eigenvectors)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort eigenvalue/eigenvector tuples by increasing modulus.</p>
<p>This function accepts the eigenvalue/eigenvector data returned by
the <code>np.linalg.eig</code> function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eigenvalues</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape (&hellip;, n) representing eigenvalues of some
matrices</dd>
<dt><strong><code>eigenvectors</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape (&hellip;, n, n) representing eigenvectors of some
matrices (as column vectors).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>Tuple of the form <code>(eigvals, eigvecs)</code>, where both eigvals and
eigvecs have the same data as the input arrays, but arranged
so that eigenvalues and eigenvectors are in increasing order
of modulus.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_eigs(eigenvalues, eigenvectors):
    &#34;&#34;&#34;Sort eigenvalue/eigenvector tuples by increasing modulus.

    This function accepts the eigenvalue/eigenvector data returned by
    the `np.linalg.eig` function.

    Parameters
    ----------
    eigenvalues : ndarray
        Array of shape (..., n) representing eigenvalues of some
        matrices
    eigenvectors : ndarray
        Array of shape (..., n, n) representing eigenvectors of some
        matrices (as column vectors).

    Returns
    -------
    tuple
        Tuple of the form `(eigvals, eigvecs)`, where both eigvals and
        eigvecs have the same data as the input arrays, but arranged
        so that eigenvalues and eigenvectors are in increasing order
        of modulus.

    &#34;&#34;&#34;
    eigorder = np.argsort(np.abs(eigenvalues), axis=-1)
    eigvecs = np.take_along_axis(eigenvectors, np.expand_dims(eigorder, axis=-2), axis=-1)
    eigvals = np.take_along_axis(eigenvalues, eigorder, axis=-1)

    return eigvals, eigvecs</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.permutation_matrix"><code class="name flex">
<span>def <span class="ident">permutation_matrix</span></span>(<span>permutation)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a permutation matrix representing the given permutation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>permutation</code></strong> :&ensp;<code>iterable</code></dt>
<dd>a sequence of n numbers (indices), specifying a permutation of
(1, &hellip; n).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>square 2-dimensional array, giving a permutation matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permutation_matrix(permutation):
    &#34;&#34;&#34;Return a permutation matrix representing the given permutation.

    Parameters
    ----------
    permutation: iterable
        a sequence of n numbers (indices), specifying a permutation of
        (1, ... n).

    Returns
    -------
    ndarray
        square 2-dimensional array, giving a permutation matrix.

    &#34;&#34;&#34;
    n = len(permutation)
    p_mat = np.zeros((n, n))
    for i,j in enumerate(permutation):
        p_mat[i,j] = 1.

    return p_mat</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.projection"><code class="name flex">
<span>def <span class="ident">projection</span></span>(<span>v1, v2, bilinear_form)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the projection of <code>v1</code> onto <code>v2</code> with respect to some
bilinear form.</p>
<p>The returned vector <code>w</code> is parallel to <code>v2</code>, and <code>v1 - w</code> is
orthogonal to <code>v2</code> with respect to the given bilinear form.
<code>w</code> is determined by the formula
<span><span class="MathJax_Preview">
v_2 \cdot \langle v_1, v_2 \rangle / \langle v_2, v_2 \rangle,
</span><script type="math/tex; mode=display">
v_2 \cdot \langle v_1, v_2 \rangle / \langle v_2, v_2 \rangle,
</script></span>
where <span><span class="MathJax_Preview">\langle \cdot, \cdot \rangle</span><script type="math/tex">\langle \cdot, \cdot \rangle</script></span> is the pairing determined by
<code>bilinear_form</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v1</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>vector in R^n to project</dd>
<dt><strong><code>v2</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>vector in R^n to project onto</dd>
<dt><strong><code>bilinear_form</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>array of shape <code>(n, n)</code> giving a bilinear form to use for the
projection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>vector in R^n giving the projection of <code>v1</code> onto <code>v2</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projection(v1, v2, bilinear_form):
    r&#34;&#34;&#34;Return the projection of `v1` onto `v2` with respect to some
    bilinear form.

    The returned vector `w` is parallel to `v2`, and `v1 - w` is
    orthogonal to `v2` with respect to the given bilinear form.
    `w` is determined by the formula
    \[
    v_2 \cdot \langle v_1, v_2 \rangle / \langle v_2, v_2 \rangle,
    \]
    where \(\langle \cdot, \cdot \rangle\) is the pairing determined by
    `bilinear_form`.

    Parameters
    ----------
    v1 : ndarray
        vector in R^n to project
    v2 : ndarray
        vector in R^n to project onto
    bilinear_form : ndarray
        array of shape `(n, n)` giving a bilinear form to use for the
        projection.

    Returns
    -------
    w : ndarray
        vector in R^n giving the projection of `v1` onto `v2`.

    &#34;&#34;&#34;

    return (v2.T *
            apply_bilinear(v1, v2, bilinear_form).T /
            normsq(v2, bilinear_form).T).T</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.r_to_c"><code class="name flex">
<span>def <span class="ident">r_to_c</span></span>(<span>real_coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def r_to_c(real_coords):
    return real_coords[..., 0] + real_coords[..., 1]*1.0j</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.right_to_left"><code class="name flex">
<span>def <span class="ident">right_to_left</span></span>(<span>thetas)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder angles so that the counterclockwise arc goes right to left.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thetas</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>numpy array of shape (&hellip;, 2), giving ordered pairs of angles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>numpy array with the same shape as <code>thetas</code>. The ordered pairs
in this array are arranged so that for each pair <code>(a, b)</code>, the
cosine of <code>b</code> is at most the cosine of <code>a</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def right_to_left(thetas):
    &#34;&#34;&#34;Reorder angles so that the counterclockwise arc goes right to left.

    Parameters
    ----------
    thetas: ndarray
        numpy array of shape (..., 2), giving ordered pairs of angles.

    Returns
    -------
    ndarray
        numpy array with the same shape as `thetas`. The ordered pairs
        in this array are arranged so that for each pair `(a, b)`, the
        cosine of `b` is at most the cosine of `a`.

    &#34;&#34;&#34;
    flipped_thetas = np.copy(thetas)

    to_flip = np.cos(thetas[..., 0]) &lt; np.cos(thetas[..., 1])
    flipped_thetas[to_flip] = np.flip(thetas[to_flip], axis=-1)

    return flipped_thetas</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.rotation_matrix"><code class="name flex">
<span>def <span class="ident">rotation_matrix</span></span>(<span>angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a 2x2 rotation matrix rotating counterclockwise by the
specified angle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>angle to rotate by</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>numpy array of shape (2,2) of the form
<span><span class="MathJax_Preview">\begin{pmatrix}\cos \theta &amp; -\sin \theta\\\sin\theta &amp; \cos \theta
\end{pmatrix}</span><script type="math/tex">\begin{pmatrix}\cos \theta & -\sin \theta\\\sin\theta & \cos \theta
\end{pmatrix}</script></span></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix(angle):
    r&#34;&#34;&#34;Get a 2x2 rotation matrix rotating counterclockwise by the
    specified angle.

    Parameters
    ----------
    angle : float
        angle to rotate by

    Returns
    -------
    ndarray
        numpy array of shape (2,2) of the form
        \(\begin{pmatrix}\cos \theta &amp; -\sin \theta\\\sin\theta &amp; \cos \theta
        \end{pmatrix}\)

    &#34;&#34;&#34;
    return np.array([[np.cos(angle), -1*np.sin(angle)],
                     [np.sin(angle), np.cos(angle)]])</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.short_arc"><code class="name flex">
<span>def <span class="ident">short_arc</span></span>(<span>thetas)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder angles so that the counterclockwise arc between them is
shorter than the clockwise angle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thetas</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>numpy array of shape (&hellip;, 2), giving ordered pairs of angles
in the range (-2pi, 2pi)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>numpy array with the same shape as thetas. The ordered pairs
in this array are arranged so that for each pair <code>(a, b)</code>, the
counterclockwise arc from <code>a</code> to <code>b</code> is shorter than the
counterclockwise arc from <code>b</code> to <code>a</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def short_arc(thetas):
    &#34;&#34;&#34;Reorder angles so that the counterclockwise arc between them is
    shorter than the clockwise angle.

    Parameters
    ----------
    thetas: ndarray
        numpy array of shape (..., 2), giving ordered pairs of angles
        in the range (-2pi, 2pi)

    Returns
    -------
    ndarray
        numpy array with the same shape as thetas. The ordered pairs
        in this array are arranged so that for each pair `(a, b)`, the
        counterclockwise arc from `a` to `b` is shorter than the
        counterclockwise arc from `b` to `a`.

    &#34;&#34;&#34;
    shifted_thetas = np.copy(thetas)

    shifted_thetas[shifted_thetas &lt; 0] += 2 * np.pi
    shifted_thetas.sort(axis=-1)

    to_flip = shifted_thetas[...,1] - shifted_thetas[...,0] &gt; np.pi
    shifted_thetas[to_flip] = np.flip(shifted_thetas[to_flip], axis=-1)

    return shifted_thetas</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.sphere_inversion"><code class="name flex">
<span>def <span class="ident">sphere_inversion</span></span>(<span>points)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply unit sphere inversion to points in R^n.</p>
<p>This realizes the map <span><span class="MathJax_Preview">v \mapsto v / ||v||^2</span><script type="math/tex">v \mapsto v / ||v||^2</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, n)</code> giving a set of points in R^n</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>The image of the <code>points</code> array under sphere inversion.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sphere_inversion(points):
    r&#34;&#34;&#34;Apply unit sphere inversion to points in R^n.

    This realizes the map \(v \mapsto v / ||v||^2\).

    Parameters
    ----------
    points : ndarray
        Array of shape `(..., n)` giving a set of points in R^n

    Returns
    -------
    ndarray
        The image of the `points` array under sphere inversion.

    &#34;&#34;&#34;
    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        return (points.T / (normsq(points)).T).T</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.squeeze_excess"><code class="name flex">
<span>def <span class="ident">squeeze_excess</span></span>(<span>array, unit_axes, other_unit_axes)</span>
</code></dt>
<dd>
<div class="desc"><p>Squeeze all excess axes from an ndarray of arrays with unit_axes axes.</p>
<p>This undoes expand_unit_axes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>ndarray of shape
<code>([object axes], [excess axes], [unit axes])</code>, where <code>[unit axes]</code>
is a tuple of length <code>unit_axes</code>, and <code>[excess axes]</code> is a
tuple of length <code>other_unit_axes - unit_axes</code>.</dd>
<dt><strong><code>unit_axes</code></strong> :&ensp;<code>int</code></dt>
<dd>number of axes to view as "units" in <code>array</code>. That is, <code>array</code>
is viewed as an ndarray of arrays each with <code>unit_axes</code> axes.</dd>
<dt><strong><code>other_unit_axes</code></strong> :&ensp;<code>int</code></dt>
<dd>axes to avoid squeezing when we reshape the array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Reshaped array with certain length-1 axes removed. If the
input array has shape
<code>([object axes], [excess axes], [unit axes])</code>,
squeeze out all the ones in <code>[excess axes]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def squeeze_excess(array, unit_axes, other_unit_axes):
    &#34;&#34;&#34;Squeeze all excess axes from an ndarray of arrays with unit_axes axes.

    This undoes expand_unit_axes.

    Parameters
    ----------
    array : ndarray
        ndarray of shape
        `([object axes], [excess axes], [unit axes])`, where `[unit axes]`
        is a tuple of length `unit_axes`, and `[excess axes]` is a
        tuple of length `other_unit_axes - unit_axes`.
    unit_axes : int
        number of axes to view as &#34;units&#34; in `array`. That is, `array`
        is viewed as an ndarray of arrays each with `unit_axes` axes.
    other_unit_axes : int
        axes to avoid squeezing when we reshape the array.

    Returns
    -------
    ndarray
        Reshaped array with certain length-1 axes removed. If the
        input array has shape
        `([object axes], [excess axes], [unit axes])`,
        squeeze out all the ones in `[excess axes]`.

    &#34;&#34;&#34;
    squeezable = np.array(array.T.shape[unit_axes:other_unit_axes])
    (to_squeeze,) = np.nonzero(squeezable == 1)
    to_squeeze += unit_axes

    return np.squeeze(array.T, axis=tuple(to_squeeze)).T</code></pre>
</details>
</dd>
<dt id="geometry_tools.utils.swap_matrix"><code class="name flex">
<span>def <span class="ident">swap_matrix</span></span>(<span>i, j, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a permutation matrix representing a single transposition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong>, <strong><code>j</code></strong> :&ensp;<code>int</code></dt>
<dd>Indices swapped by a transposition.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>dimension of the permutation matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Array of shape <code>(n, n)</code> giving a transposition matrix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_matrix(i, j, n):
    &#34;&#34;&#34;Return a permutation matrix representing a single transposition.

    Parameters
    ----------
    i, j : int
        Indices swapped by a transposition.
    n : int
        dimension of the permutation matrix.

    Returns
    -------
    ndarray
        Array of shape `(n, n)` giving a transposition matrix.

    &#34;&#34;&#34;
    permutation = list(range(n))
    permutation[i] = j
    permutation[j] = i
    return permutation_matrix(permutation)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geometry_tools" href="../index.html">geometry_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="geometry_tools.utils.cp1" href="cp1.html">geometry_tools.utils.cp1</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geometry_tools.utils.affine_disks_contain" href="#geometry_tools.utils.affine_disks_contain">affine_disks_contain</a></code></li>
<li><code><a title="geometry_tools.utils.apply_bilinear" href="#geometry_tools.utils.apply_bilinear">apply_bilinear</a></code></li>
<li><code><a title="geometry_tools.utils.arc_include" href="#geometry_tools.utils.arc_include">arc_include</a></code></li>
<li><code><a title="geometry_tools.utils.c_to_r" href="#geometry_tools.utils.c_to_r">c_to_r</a></code></li>
<li><code><a title="geometry_tools.utils.circle_angles" href="#geometry_tools.utils.circle_angles">circle_angles</a></code></li>
<li><code><a title="geometry_tools.utils.circle_through" href="#geometry_tools.utils.circle_through">circle_through</a></code></li>
<li><code><a title="geometry_tools.utils.diagonalize_form" href="#geometry_tools.utils.diagonalize_form">diagonalize_form</a></code></li>
<li><code><a title="geometry_tools.utils.disk_containments" href="#geometry_tools.utils.disk_containments">disk_containments</a></code></li>
<li><code><a title="geometry_tools.utils.disk_interactions" href="#geometry_tools.utils.disk_interactions">disk_interactions</a></code></li>
<li><code><a title="geometry_tools.utils.expand_unit_axes" href="#geometry_tools.utils.expand_unit_axes">expand_unit_axes</a></code></li>
<li><code><a title="geometry_tools.utils.find_definite_isometry" href="#geometry_tools.utils.find_definite_isometry">find_definite_isometry</a></code></li>
<li><code><a title="geometry_tools.utils.find_isometry" href="#geometry_tools.utils.find_isometry">find_isometry</a></code></li>
<li><code><a title="geometry_tools.utils.find_positive_functional" href="#geometry_tools.utils.find_positive_functional">find_positive_functional</a></code></li>
<li><code><a title="geometry_tools.utils.first_sign_switch" href="#geometry_tools.utils.first_sign_switch">first_sign_switch</a></code></li>
<li><code><a title="geometry_tools.utils.indefinite_orthogonalize" href="#geometry_tools.utils.indefinite_orthogonalize">indefinite_orthogonalize</a></code></li>
<li><code><a title="geometry_tools.utils.invert_gen" href="#geometry_tools.utils.invert_gen">invert_gen</a></code></li>
<li><code><a title="geometry_tools.utils.make_orientation_preserving" href="#geometry_tools.utils.make_orientation_preserving">make_orientation_preserving</a></code></li>
<li><code><a title="geometry_tools.utils.matrix_product" href="#geometry_tools.utils.matrix_product">matrix_product</a></code></li>
<li><code><a title="geometry_tools.utils.normalize" href="#geometry_tools.utils.normalize">normalize</a></code></li>
<li><code><a title="geometry_tools.utils.normsq" href="#geometry_tools.utils.normsq">normsq</a></code></li>
<li><code><a title="geometry_tools.utils.order_eigs" href="#geometry_tools.utils.order_eigs">order_eigs</a></code></li>
<li><code><a title="geometry_tools.utils.permutation_matrix" href="#geometry_tools.utils.permutation_matrix">permutation_matrix</a></code></li>
<li><code><a title="geometry_tools.utils.projection" href="#geometry_tools.utils.projection">projection</a></code></li>
<li><code><a title="geometry_tools.utils.r_to_c" href="#geometry_tools.utils.r_to_c">r_to_c</a></code></li>
<li><code><a title="geometry_tools.utils.right_to_left" href="#geometry_tools.utils.right_to_left">right_to_left</a></code></li>
<li><code><a title="geometry_tools.utils.rotation_matrix" href="#geometry_tools.utils.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="geometry_tools.utils.short_arc" href="#geometry_tools.utils.short_arc">short_arc</a></code></li>
<li><code><a title="geometry_tools.utils.sphere_inversion" href="#geometry_tools.utils.sphere_inversion">sphere_inversion</a></code></li>
<li><code><a title="geometry_tools.utils.squeeze_excess" href="#geometry_tools.utils.squeeze_excess">squeeze_excess</a></code></li>
<li><code><a title="geometry_tools.utils.swap_matrix" href="#geometry_tools.utils.swap_matrix">swap_matrix</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geometry_tools.coxeter API documentation</title>
<meta name="description" content="Work with Coxeter groups and their representations." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geometry_tools.coxeter</code></h1>
</header>
<section id="section-intro">
<p>Work with Coxeter groups and their representations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Work with Coxeter groups and their representations.
&#34;&#34;&#34;
import warnings
from collections import defaultdict

import numpy as np

from geometry_tools.representation import Representation
from geometry_tools.projective import GeometryError
from geometry_tools import hyperbolic
from geometry_tools import utils
from geometry_tools.automata import fsa, coxeter_automaton

GENERATOR_NAMES = &#34;abcdefghijklmnopqrstuvwxyz&#34;

class CoxeterGroup:
    def __init__(self, diagram=None, matrix=None):
        &#34;&#34;&#34;Construct a Coxeter group.

        The constructor accepts data determining a Coxeter group in
        the form of either a Coxeter diagram (specified as an iterable
        of tuples) or a Coxeter matrix (a symmetric array of
        integers).

        Parameters
        ----------
        diagram: iterable of tuples
            A Coxeter diagram, given as an iterable of triples of the
            form `(generator1, generator2, order)`. Each generator can
            be any hashable object (internally these will be mapped to
            characters a-z). `order` is an integer. If it is positive,
            then it represents the order of the product of generator1
            and generator2. If it is zero or negative, the order of
            this product is infinite.

        matrix: ndarray of ints
            The Coxeter matrix defining this Coxeter system. This must
            be a symmetric matrix of integers, with 1&#39;s on the
            diagonal.

    &#34;&#34;&#34;
        if diagram is None and matrix is None:
            raise ValueError(&#34;Must provide data to construct a Coxeter group&#34;)

        if diagram is not None and matrix is not None:
            warnings.warn(&#34;Redundant Coxeter data specified; ignoring Coxeter matrix and&#34;
                          &#34; constructing from diagram.&#34;)

        if diagram is not None:
            self.from_diagram(diagram)
        elif matrix is not None:
            self.from_coxeter_matrix(matrix)

        self._compute_bilinear_form()

    def _compute_bilinear_form(self):
        adjusted_cox_matrix = np.array(self.coxeter_matrix)
        adjusted_cox_matrix[adjusted_cox_matrix &lt;= 0] = 0.5

        self.bilinear_form = -1 * np.cos(np.pi / adjusted_cox_matrix)

    def from_diagram(self, diagram):
        self.generators = defaultdict(dict)

        for edge in diagram:
            g1, g2, order = edge
            self.generators[g1][g2] = order
            self.generators[g2][g1] = order

        self.generator_index = {g:i for i, g in enumerate(self.generators)}
        self.ordered_gens = [None] * len(self.generators)
        for g, i in self.generator_index.items():
            self.ordered_gens[i] = g
            self.generators[g][g] = 1

        self.coxeter_matrix = np.array([
            [self.generators[g1][g2] for g2 in self.ordered_gens]
            for g1 in self.ordered_gens
        ])

    def __str__(self):
        return &#34;{} with matrix: \n{}&#34;.format(
            self.__class__.__name__, self.coxeter_matrix
        )


    def from_coxeter_matrix(self, matrix):
        if (matrix.T - matrix != 0).any():
            raise GeometryError(&#34;Coxeter matrix must be symmetric&#34;)

        if (matrix.astype(int) != matrix).any():
            raise GeometryError(&#34;Coxeter matrix must have integer entries&#34;)

        if (np.diag(matrix) != 1).any():
            warnings.warn(&#34;Coxeter matrix should have 1&#39;s on the diagonal&#34;)

        self.coxeter_matrix = matrix
        self.generators = defaultdict(dict)

        n = len(matrix)
        self.generator_index = {
            GENERATOR_NAMES[i]:i for i in range(n)
        }
        self.ordered_gens = GENERATOR_NAMES[:n]

        for i, row in enumerate(matrix):
            for j, order in enumerate(row):
                self.generators[GENERATOR_NAMES[i]][GENERATOR_NAMES[j]] = order

    def canonical_representation(self):
        &#34;&#34;&#34;Get the canonical representation of the Coxeter group.

        Returns
        -------
        representation.Representation
            The canonical (Tits) representation for this Coxeter
            group. This representation always preserves the symmetric
            bilinear form determined by the cosine matrix (which is in
            turn determined by the Coxeter matrix).

            Generators are mapped to &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, etc.

        &#34;&#34;&#34;
        num_gens = len(self.generators)
        rep = Representation()

        for i, gen in enumerate(self.ordered_gens):
            basis_vec = np.zeros(num_gens)
            basis_vec[i] = 1.0
            diagonal = np.diag(basis_vec)
            rep[GENERATOR_NAMES[i]] = (
                np.identity(num_gens) - 2 * diagonal @ self.bilinear_form
            )

        return rep

    def tits_vinberg_rep(self, parameters):
        #TODO: actually compute a Tits-Vinberg representation based on
        #some parameters
        return self.canonical_representation()


    def diagonal_rep(self, order_eigenvalues=&#34;signed&#34;):
        &#34;&#34;&#34;Get a representation of the Coxeter group which preserves a
        diagonal symmetric bilinear form.

        This function finds a conjugate of the representation returned
        by canonical_representation so that in the standard basis on
        R^n, the representation preserves the bilinear form given by a
        diagonal matrix.

        Parameters
        ----------
        order_eigenvalues: {&#39;signed&#39;, &#39;minkowski&#39;}
            How to order the diagonal basis for the form. See the
            documentation for utils.diagonalize_form for details.

        Returns
        -------
        representation.Representation
            Diagonal representation for this Coxeter group. Generators
            are mapped to &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, etc.

        &#34;&#34;&#34;
        W = utils.diagonalize_form(self.bilinear_form,
                                   order_eigenvalues=order_eigenvalues)

        rep = self.canonical_representation()
        for g in self.generators:
            rep[g] = np.linalg.inv(W) @ rep[g] @ W

        return rep

    def hyperbolic_rep(self):
        &#34;&#34;&#34;Get a representation of this Coxeter group in PO(d, 1).

        This function assumes that the canonical representation of the
        Coxeter group preserves a bilinear form of signature (d, 1).

        Returns
        -------
        hyperbolic.HyperbolicRepresentation
            Representation of the Coxeter group by isometries in
            d-dimensional hyperbolic space, where d+1 is the number of
            generators of the group. Generators are mapped to &#39;a&#39;,
            &#39;b&#39;, &#39;c&#39;, etc.

        &#34;&#34;&#34;
        matrix_rep = self.diagonal_rep(order_eigenvalues=&#34;signed&#34;)
        return hyperbolic.HyperbolicRepresentation(matrix_rep)

    def automaton(self, shortlex=True):
        &#34;&#34;&#34;Get a finite-state automaton accepting geodesic words in the
        Coxeter group.

        Parameters
        ----------
        shortlex : bool
            If True (the default), return an automaton which only
            accepts shortlex geodesic representatives of elements in
            the group. If False, return an automaton which only
            accepts geodesic words, and accepts at least one geodesic
            word per element.

        Returns
        -------
        fsa.FSA
            finite-state automaton accepting geodesic words.

    &#34;&#34;&#34;
        aut = coxeter_automaton.generate_automaton_coxeter_matrix(
            self.coxeter_matrix,
            shortlex
        )
        aut.rename_generators(self.ordered_gens)
        return aut


class TriangleGroup(CoxeterGroup):
    &#34;&#34;&#34;Convenience class for building a triangle group.

    &#34;&#34;&#34;
    def __init__(self, vertex_params):
        v1, v2, v3 = vertex_params
        CoxeterGroup.__init__(
            self, [
                [&#39;a&#39;, &#39;b&#39;, v1],
                [&#39;b&#39;, &#39;c&#39;, v2],
                [&#39;c&#39;, &#39;a&#39;, v3]
            ]
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geometry_tools.coxeter.CoxeterGroup"><code class="flex name class">
<span>class <span class="ident">CoxeterGroup</span></span>
<span>(</span><span>diagram=None, matrix=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a Coxeter group.</p>
<p>The constructor accepts data determining a Coxeter group in
the form of either a Coxeter diagram (specified as an iterable
of tuples) or a Coxeter matrix (a symmetric array of
integers).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>diagram</code></strong> :&ensp;<code>iterable</code> of <code>tuples</code></dt>
<dd>A Coxeter diagram, given as an iterable of triples of the
form <code>(generator1, generator2, order)</code>. Each generator can
be any hashable object (internally these will be mapped to
characters a-z). <code>order</code> is an integer. If it is positive,
then it represents the order of the product of generator1
and generator2. If it is zero or negative, the order of
this product is infinite.</dd>
<dt><strong><code>matrix</code></strong> :&ensp;<code>ndarray</code> of <code>ints</code></dt>
<dd>The Coxeter matrix defining this Coxeter system. This must
be a symmetric matrix of integers, with 1's on the
diagonal.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoxeterGroup:
    def __init__(self, diagram=None, matrix=None):
        &#34;&#34;&#34;Construct a Coxeter group.

        The constructor accepts data determining a Coxeter group in
        the form of either a Coxeter diagram (specified as an iterable
        of tuples) or a Coxeter matrix (a symmetric array of
        integers).

        Parameters
        ----------
        diagram: iterable of tuples
            A Coxeter diagram, given as an iterable of triples of the
            form `(generator1, generator2, order)`. Each generator can
            be any hashable object (internally these will be mapped to
            characters a-z). `order` is an integer. If it is positive,
            then it represents the order of the product of generator1
            and generator2. If it is zero or negative, the order of
            this product is infinite.

        matrix: ndarray of ints
            The Coxeter matrix defining this Coxeter system. This must
            be a symmetric matrix of integers, with 1&#39;s on the
            diagonal.

    &#34;&#34;&#34;
        if diagram is None and matrix is None:
            raise ValueError(&#34;Must provide data to construct a Coxeter group&#34;)

        if diagram is not None and matrix is not None:
            warnings.warn(&#34;Redundant Coxeter data specified; ignoring Coxeter matrix and&#34;
                          &#34; constructing from diagram.&#34;)

        if diagram is not None:
            self.from_diagram(diagram)
        elif matrix is not None:
            self.from_coxeter_matrix(matrix)

        self._compute_bilinear_form()

    def _compute_bilinear_form(self):
        adjusted_cox_matrix = np.array(self.coxeter_matrix)
        adjusted_cox_matrix[adjusted_cox_matrix &lt;= 0] = 0.5

        self.bilinear_form = -1 * np.cos(np.pi / adjusted_cox_matrix)

    def from_diagram(self, diagram):
        self.generators = defaultdict(dict)

        for edge in diagram:
            g1, g2, order = edge
            self.generators[g1][g2] = order
            self.generators[g2][g1] = order

        self.generator_index = {g:i for i, g in enumerate(self.generators)}
        self.ordered_gens = [None] * len(self.generators)
        for g, i in self.generator_index.items():
            self.ordered_gens[i] = g
            self.generators[g][g] = 1

        self.coxeter_matrix = np.array([
            [self.generators[g1][g2] for g2 in self.ordered_gens]
            for g1 in self.ordered_gens
        ])

    def __str__(self):
        return &#34;{} with matrix: \n{}&#34;.format(
            self.__class__.__name__, self.coxeter_matrix
        )


    def from_coxeter_matrix(self, matrix):
        if (matrix.T - matrix != 0).any():
            raise GeometryError(&#34;Coxeter matrix must be symmetric&#34;)

        if (matrix.astype(int) != matrix).any():
            raise GeometryError(&#34;Coxeter matrix must have integer entries&#34;)

        if (np.diag(matrix) != 1).any():
            warnings.warn(&#34;Coxeter matrix should have 1&#39;s on the diagonal&#34;)

        self.coxeter_matrix = matrix
        self.generators = defaultdict(dict)

        n = len(matrix)
        self.generator_index = {
            GENERATOR_NAMES[i]:i for i in range(n)
        }
        self.ordered_gens = GENERATOR_NAMES[:n]

        for i, row in enumerate(matrix):
            for j, order in enumerate(row):
                self.generators[GENERATOR_NAMES[i]][GENERATOR_NAMES[j]] = order

    def canonical_representation(self):
        &#34;&#34;&#34;Get the canonical representation of the Coxeter group.

        Returns
        -------
        representation.Representation
            The canonical (Tits) representation for this Coxeter
            group. This representation always preserves the symmetric
            bilinear form determined by the cosine matrix (which is in
            turn determined by the Coxeter matrix).

            Generators are mapped to &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, etc.

        &#34;&#34;&#34;
        num_gens = len(self.generators)
        rep = Representation()

        for i, gen in enumerate(self.ordered_gens):
            basis_vec = np.zeros(num_gens)
            basis_vec[i] = 1.0
            diagonal = np.diag(basis_vec)
            rep[GENERATOR_NAMES[i]] = (
                np.identity(num_gens) - 2 * diagonal @ self.bilinear_form
            )

        return rep

    def tits_vinberg_rep(self, parameters):
        #TODO: actually compute a Tits-Vinberg representation based on
        #some parameters
        return self.canonical_representation()


    def diagonal_rep(self, order_eigenvalues=&#34;signed&#34;):
        &#34;&#34;&#34;Get a representation of the Coxeter group which preserves a
        diagonal symmetric bilinear form.

        This function finds a conjugate of the representation returned
        by canonical_representation so that in the standard basis on
        R^n, the representation preserves the bilinear form given by a
        diagonal matrix.

        Parameters
        ----------
        order_eigenvalues: {&#39;signed&#39;, &#39;minkowski&#39;}
            How to order the diagonal basis for the form. See the
            documentation for utils.diagonalize_form for details.

        Returns
        -------
        representation.Representation
            Diagonal representation for this Coxeter group. Generators
            are mapped to &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, etc.

        &#34;&#34;&#34;
        W = utils.diagonalize_form(self.bilinear_form,
                                   order_eigenvalues=order_eigenvalues)

        rep = self.canonical_representation()
        for g in self.generators:
            rep[g] = np.linalg.inv(W) @ rep[g] @ W

        return rep

    def hyperbolic_rep(self):
        &#34;&#34;&#34;Get a representation of this Coxeter group in PO(d, 1).

        This function assumes that the canonical representation of the
        Coxeter group preserves a bilinear form of signature (d, 1).

        Returns
        -------
        hyperbolic.HyperbolicRepresentation
            Representation of the Coxeter group by isometries in
            d-dimensional hyperbolic space, where d+1 is the number of
            generators of the group. Generators are mapped to &#39;a&#39;,
            &#39;b&#39;, &#39;c&#39;, etc.

        &#34;&#34;&#34;
        matrix_rep = self.diagonal_rep(order_eigenvalues=&#34;signed&#34;)
        return hyperbolic.HyperbolicRepresentation(matrix_rep)

    def automaton(self, shortlex=True):
        &#34;&#34;&#34;Get a finite-state automaton accepting geodesic words in the
        Coxeter group.

        Parameters
        ----------
        shortlex : bool
            If True (the default), return an automaton which only
            accepts shortlex geodesic representatives of elements in
            the group. If False, return an automaton which only
            accepts geodesic words, and accepts at least one geodesic
            word per element.

        Returns
        -------
        fsa.FSA
            finite-state automaton accepting geodesic words.

    &#34;&#34;&#34;
        aut = coxeter_automaton.generate_automaton_coxeter_matrix(
            self.coxeter_matrix,
            shortlex
        )
        aut.rename_generators(self.ordered_gens)
        return aut</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.coxeter.TriangleGroup" href="#geometry_tools.coxeter.TriangleGroup">TriangleGroup</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.coxeter.CoxeterGroup.automaton"><code class="name flex">
<span>def <span class="ident">automaton</span></span>(<span>self, shortlex=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a finite-state automaton accepting geodesic words in the
Coxeter group.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shortlex</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True (the default), return an automaton which only
accepts shortlex geodesic representatives of elements in
the group. If False, return an automaton which only
accepts geodesic words, and accepts at least one geodesic
word per element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>fsa.FSA</code></dt>
<dd>finite-state automaton accepting geodesic words.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def automaton(self, shortlex=True):
    &#34;&#34;&#34;Get a finite-state automaton accepting geodesic words in the
    Coxeter group.

    Parameters
    ----------
    shortlex : bool
        If True (the default), return an automaton which only
        accepts shortlex geodesic representatives of elements in
        the group. If False, return an automaton which only
        accepts geodesic words, and accepts at least one geodesic
        word per element.

    Returns
    -------
    fsa.FSA
        finite-state automaton accepting geodesic words.

&#34;&#34;&#34;
    aut = coxeter_automaton.generate_automaton_coxeter_matrix(
        self.coxeter_matrix,
        shortlex
    )
    aut.rename_generators(self.ordered_gens)
    return aut</code></pre>
</details>
</dd>
<dt id="geometry_tools.coxeter.CoxeterGroup.canonical_representation"><code class="name flex">
<span>def <span class="ident">canonical_representation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the canonical representation of the Coxeter group.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>representation.Representation</code></dt>
<dd>
<p>The canonical (Tits) representation for this Coxeter
group. This representation always preserves the symmetric
bilinear form determined by the cosine matrix (which is in
turn determined by the Coxeter matrix).</p>
<p>Generators are mapped to 'a', 'b', 'c', etc.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canonical_representation(self):
    &#34;&#34;&#34;Get the canonical representation of the Coxeter group.

    Returns
    -------
    representation.Representation
        The canonical (Tits) representation for this Coxeter
        group. This representation always preserves the symmetric
        bilinear form determined by the cosine matrix (which is in
        turn determined by the Coxeter matrix).

        Generators are mapped to &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, etc.

    &#34;&#34;&#34;
    num_gens = len(self.generators)
    rep = Representation()

    for i, gen in enumerate(self.ordered_gens):
        basis_vec = np.zeros(num_gens)
        basis_vec[i] = 1.0
        diagonal = np.diag(basis_vec)
        rep[GENERATOR_NAMES[i]] = (
            np.identity(num_gens) - 2 * diagonal @ self.bilinear_form
        )

    return rep</code></pre>
</details>
</dd>
<dt id="geometry_tools.coxeter.CoxeterGroup.diagonal_rep"><code class="name flex">
<span>def <span class="ident">diagonal_rep</span></span>(<span>self, order_eigenvalues='signed')</span>
</code></dt>
<dd>
<div class="desc"><p>Get a representation of the Coxeter group which preserves a
diagonal symmetric bilinear form.</p>
<p>This function finds a conjugate of the representation returned
by canonical_representation so that in the standard basis on
R^n, the representation preserves the bilinear form given by a
diagonal matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order_eigenvalues</code></strong> :&ensp;<code>{'signed', 'minkowski'}</code></dt>
<dd>How to order the diagonal basis for the form. See the
documentation for utils.diagonalize_form for details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>representation.Representation</code></dt>
<dd>Diagonal representation for this Coxeter group. Generators
are mapped to 'a', 'b', 'c', etc.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagonal_rep(self, order_eigenvalues=&#34;signed&#34;):
    &#34;&#34;&#34;Get a representation of the Coxeter group which preserves a
    diagonal symmetric bilinear form.

    This function finds a conjugate of the representation returned
    by canonical_representation so that in the standard basis on
    R^n, the representation preserves the bilinear form given by a
    diagonal matrix.

    Parameters
    ----------
    order_eigenvalues: {&#39;signed&#39;, &#39;minkowski&#39;}
        How to order the diagonal basis for the form. See the
        documentation for utils.diagonalize_form for details.

    Returns
    -------
    representation.Representation
        Diagonal representation for this Coxeter group. Generators
        are mapped to &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, etc.

    &#34;&#34;&#34;
    W = utils.diagonalize_form(self.bilinear_form,
                               order_eigenvalues=order_eigenvalues)

    rep = self.canonical_representation()
    for g in self.generators:
        rep[g] = np.linalg.inv(W) @ rep[g] @ W

    return rep</code></pre>
</details>
</dd>
<dt id="geometry_tools.coxeter.CoxeterGroup.from_coxeter_matrix"><code class="name flex">
<span>def <span class="ident">from_coxeter_matrix</span></span>(<span>self, matrix)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_coxeter_matrix(self, matrix):
    if (matrix.T - matrix != 0).any():
        raise GeometryError(&#34;Coxeter matrix must be symmetric&#34;)

    if (matrix.astype(int) != matrix).any():
        raise GeometryError(&#34;Coxeter matrix must have integer entries&#34;)

    if (np.diag(matrix) != 1).any():
        warnings.warn(&#34;Coxeter matrix should have 1&#39;s on the diagonal&#34;)

    self.coxeter_matrix = matrix
    self.generators = defaultdict(dict)

    n = len(matrix)
    self.generator_index = {
        GENERATOR_NAMES[i]:i for i in range(n)
    }
    self.ordered_gens = GENERATOR_NAMES[:n]

    for i, row in enumerate(matrix):
        for j, order in enumerate(row):
            self.generators[GENERATOR_NAMES[i]][GENERATOR_NAMES[j]] = order</code></pre>
</details>
</dd>
<dt id="geometry_tools.coxeter.CoxeterGroup.from_diagram"><code class="name flex">
<span>def <span class="ident">from_diagram</span></span>(<span>self, diagram)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_diagram(self, diagram):
    self.generators = defaultdict(dict)

    for edge in diagram:
        g1, g2, order = edge
        self.generators[g1][g2] = order
        self.generators[g2][g1] = order

    self.generator_index = {g:i for i, g in enumerate(self.generators)}
    self.ordered_gens = [None] * len(self.generators)
    for g, i in self.generator_index.items():
        self.ordered_gens[i] = g
        self.generators[g][g] = 1

    self.coxeter_matrix = np.array([
        [self.generators[g1][g2] for g2 in self.ordered_gens]
        for g1 in self.ordered_gens
    ])</code></pre>
</details>
</dd>
<dt id="geometry_tools.coxeter.CoxeterGroup.hyperbolic_rep"><code class="name flex">
<span>def <span class="ident">hyperbolic_rep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a representation of this Coxeter group in PO(d, 1).</p>
<p>This function assumes that the canonical representation of the
Coxeter group preserves a bilinear form of signature (d, 1).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>hyperbolic.HyperbolicRepresentation</code></dt>
<dd>Representation of the Coxeter group by isometries in
d-dimensional hyperbolic space, where d+1 is the number of
generators of the group. Generators are mapped to 'a',
'b', 'c', etc.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hyperbolic_rep(self):
    &#34;&#34;&#34;Get a representation of this Coxeter group in PO(d, 1).

    This function assumes that the canonical representation of the
    Coxeter group preserves a bilinear form of signature (d, 1).

    Returns
    -------
    hyperbolic.HyperbolicRepresentation
        Representation of the Coxeter group by isometries in
        d-dimensional hyperbolic space, where d+1 is the number of
        generators of the group. Generators are mapped to &#39;a&#39;,
        &#39;b&#39;, &#39;c&#39;, etc.

    &#34;&#34;&#34;
    matrix_rep = self.diagonal_rep(order_eigenvalues=&#34;signed&#34;)
    return hyperbolic.HyperbolicRepresentation(matrix_rep)</code></pre>
</details>
</dd>
<dt id="geometry_tools.coxeter.CoxeterGroup.tits_vinberg_rep"><code class="name flex">
<span>def <span class="ident">tits_vinberg_rep</span></span>(<span>self, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tits_vinberg_rep(self, parameters):
    #TODO: actually compute a Tits-Vinberg representation based on
    #some parameters
    return self.canonical_representation()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geometry_tools.coxeter.TriangleGroup"><code class="flex name class">
<span>class <span class="ident">TriangleGroup</span></span>
<span>(</span><span>vertex_params)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience class for building a triangle group.</p>
<p>Construct a Coxeter group.</p>
<p>The constructor accepts data determining a Coxeter group in
the form of either a Coxeter diagram (specified as an iterable
of tuples) or a Coxeter matrix (a symmetric array of
integers).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>diagram</code></strong> :&ensp;<code>iterable</code> of <code>tuples</code></dt>
<dd>A Coxeter diagram, given as an iterable of triples of the
form <code>(generator1, generator2, order)</code>. Each generator can
be any hashable object (internally these will be mapped to
characters a-z). <code>order</code> is an integer. If it is positive,
then it represents the order of the product of generator1
and generator2. If it is zero or negative, the order of
this product is infinite.</dd>
<dt><strong><code>matrix</code></strong> :&ensp;<code>ndarray</code> of <code>ints</code></dt>
<dd>The Coxeter matrix defining this Coxeter system. This must
be a symmetric matrix of integers, with 1's on the
diagonal.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriangleGroup(CoxeterGroup):
    &#34;&#34;&#34;Convenience class for building a triangle group.

    &#34;&#34;&#34;
    def __init__(self, vertex_params):
        v1, v2, v3 = vertex_params
        CoxeterGroup.__init__(
            self, [
                [&#39;a&#39;, &#39;b&#39;, v1],
                [&#39;b&#39;, &#39;c&#39;, v2],
                [&#39;c&#39;, &#39;a&#39;, v3]
            ]
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geometry_tools.coxeter.CoxeterGroup" href="#geometry_tools.coxeter.CoxeterGroup">CoxeterGroup</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geometry_tools.coxeter.CoxeterGroup" href="#geometry_tools.coxeter.CoxeterGroup">CoxeterGroup</a></b></code>:
<ul class="hlist">
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.automaton" href="#geometry_tools.coxeter.CoxeterGroup.automaton">automaton</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.canonical_representation" href="#geometry_tools.coxeter.CoxeterGroup.canonical_representation">canonical_representation</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.diagonal_rep" href="#geometry_tools.coxeter.CoxeterGroup.diagonal_rep">diagonal_rep</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.hyperbolic_rep" href="#geometry_tools.coxeter.CoxeterGroup.hyperbolic_rep">hyperbolic_rep</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geometry_tools" href="index.html">geometry_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geometry_tools.coxeter.CoxeterGroup" href="#geometry_tools.coxeter.CoxeterGroup">CoxeterGroup</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.automaton" href="#geometry_tools.coxeter.CoxeterGroup.automaton">automaton</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.canonical_representation" href="#geometry_tools.coxeter.CoxeterGroup.canonical_representation">canonical_representation</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.diagonal_rep" href="#geometry_tools.coxeter.CoxeterGroup.diagonal_rep">diagonal_rep</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.from_coxeter_matrix" href="#geometry_tools.coxeter.CoxeterGroup.from_coxeter_matrix">from_coxeter_matrix</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.from_diagram" href="#geometry_tools.coxeter.CoxeterGroup.from_diagram">from_diagram</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.hyperbolic_rep" href="#geometry_tools.coxeter.CoxeterGroup.hyperbolic_rep">hyperbolic_rep</a></code></li>
<li><code><a title="geometry_tools.coxeter.CoxeterGroup.tits_vinberg_rep" href="#geometry_tools.coxeter.CoxeterGroup.tits_vinberg_rep">tits_vinberg_rep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geometry_tools.coxeter.TriangleGroup" href="#geometry_tools.coxeter.TriangleGroup">TriangleGroup</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
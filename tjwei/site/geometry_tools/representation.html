<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geometry_tools.representation API documentation</title>
<meta name="description" content="Work with group representations into finite-dimensional vector
spaces, using numerical matrices â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geometry_tools.representation</code></h1>
</header>
<section id="section-intro">
<p>Work with group representations into finite-dimensional vector
spaces, using numerical matrices.</p>
<p>To make a representation, instantiate the <code><a title="geometry_tools.representation.Representation" href="#geometry_tools.representation.Representation">Representation</a></code> class, and
assign numpy arrays to group generators (which are lowercase letters
a-z). Use square brackets to access the image of a word in the
generators.</p>
<pre><code class="python">import numpy as np

from geometry_tools import representation
from geometry_tools.automata import fsa

rep = representation.Representation()
rep[&quot;a&quot;] = np.array([
    [3.0, 0.0],
    [0.0, 1/3.0]
])

rep[&quot;aaa&quot;]
</code></pre>
<pre><code>array([[27.        ,  0.        ],
       [ 0.        ,  0.03703704]])
</code></pre>
<p>Generator inverses are automatically assigned to capital letters:</p>
<pre><code class="python">rep = representation.Representation()
rep[&quot;a&quot;] = np.array([
    [3.0, 0.0],
    [0.0, 1/3.0]
])

rep[&quot;aA&quot;]
</code></pre>
<pre><code>array([[1., 0.],
       [0., 1.]])
</code></pre>
<p>A common use-case for this class is to get a list of matrices
representing all elements in the group, up to a bounded word
length. The fastest way to do this is to use the built-in
<code><a title="geometry_tools.representation.Representation.freely_reduced_elements" href="#geometry_tools.representation.Representation.freely_reduced_elements">Representation.freely_reduced_elements()</a></code> method, which returns a numpy
array containing one matrix for each freely reduced word in the group
(up to a specified word length).</p>
<p>The array of matrices is <em>not</em> typically ordered lexicographically. To
get a list of words corresponding to the matrices returned, pass the
<code>with_words</code> flag when calling
<code><a title="geometry_tools.representation.Representation.freely_reduced_elements" href="#geometry_tools.representation.Representation.freely_reduced_elements">Representation.freely_reduced_elements()</a></code> (see the documentation for
that function for details).</p>
<pre><code class="python">rep = representation.Representation()
rep[&quot;a&quot;] = np.array([
    [3.0, 0.0],
    [0.0, 1/3.0]
])
rep[&quot;b&quot;] = np.array([
    [1.0, -1.0],
    [1.0, 1.0]
]) / np.sqrt(2)


rep.freely_reduced_elements(6)
</code></pre>
<pre><code>array([[[ 1.00000000e+00,  0.00000000e+00],
        [ 0.00000000e+00,  1.00000000e+00]],

       [[ 7.07106781e-01,  7.07106781e-01],
        [-7.07106781e-01,  7.07106781e-01]],

       [[ 2.12132034e+00,  2.12132034e+00],
        [-2.35702260e-01,  2.35702260e-01]],

       ...,

       [[-2.12132034e+00, -2.12132034e+00],
        [ 2.35702260e-01, -2.35702260e-01]],

       [[-2.35702260e-01, -2.35702260e-01],
        [ 2.12132034e+00, -2.12132034e+00]],

       [[-1.07699575e-16, -1.00000000e+00],
        [ 1.00000000e+00,  7.51818954e-17]]])
</code></pre>
<p>You can speed up this process even more if you have access to a finite
state automaton which provides a unique word for each element in your
group.</p>
<p>For instance, to find the image of a Cayley ball of radius 10 under
the canonical representation of a (3,3,4) triangle group, you can use
the <code><a title="geometry_tools.representation.Representation.automaton_accepted" href="#geometry_tools.representation.Representation.automaton_accepted">Representation.automaton_accepted()</a></code> method as follows:</p>
<pre><code class="python">from geometry_tools import coxeter
from geometry_tools.automata import fsa

# create the representation and load the built-in automaton
rep = coxeter.TriangleGroup((3,3,4)).canonical_representation()
automaton = fsa.load_builtin('cox334.wa')

rep.automaton_accepted(automaton, 10)
</code></pre>
<pre><code>array([[[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],
        [ 0.00000000e+00,  1.00000000e+00,  0.00000000e+00],
        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],

       [[ 4.44089210e-16, -1.00000000e+00,  2.41421356e+00],
        [ 1.00000000e+00, -1.00000000e+00,  1.00000000e+00],
        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],

       [[-1.00000000e+00,  1.00000000e+00,  1.41421356e+00],
        [ 0.00000000e+00,  1.00000000e+00,  0.00000000e+00],
        [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],

       ...,

       [[-2.47279221e+01,  2.57279221e+01,  2.23137085e+01],
        [-2.91421356e+01,  2.91421356e+01,  2.71421356e+01],
        [-1.50710678e+01,  1.50710678e+01,  1.40710678e+01]],

       [[-7.24264069e+00,  7.24264069e+00,  6.82842712e+00],
        [-1.06568542e+01,  1.16568542e+01,  9.24264069e+00],
        [-5.82842712e+00,  6.82842712e+00,  4.82842712e+00]],

       [[-2.47279221e+01,  2.57279221e+01,  2.23137085e+01],
        [-1.06568542e+01,  1.16568542e+01,  9.24264069e+00],
        [-3.05563492e+01,  3.29705627e+01,  2.67279221e+01]]])
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Work with group representations into finite-dimensional vector
spaces, using numerical matrices.


To make a representation, instantiate the `Representation` class, and
assign numpy arrays to group generators (which are lowercase letters
a-z). Use square brackets to access the image of a word in the
generators.


```python
import numpy as np

from geometry_tools import representation
from geometry_tools.automata import fsa

rep = representation.Representation()
rep[&#34;a&#34;] = np.array([
    [3.0, 0.0],
    [0.0, 1/3.0]
])

rep[&#34;aaa&#34;]
```




    array([[27.        ,  0.        ],
           [ 0.        ,  0.03703704]])



Generator inverses are automatically assigned to capital letters:


```python
rep = representation.Representation()
rep[&#34;a&#34;] = np.array([
    [3.0, 0.0],
    [0.0, 1/3.0]
])

rep[&#34;aA&#34;]
```




    array([[1., 0.],
           [0., 1.]])



A common use-case for this class is to get a list of matrices
representing all elements in the group, up to a bounded word
length. The fastest way to do this is to use the built-in
`Representation.freely_reduced_elements` method, which returns a numpy
array containing one matrix for each freely reduced word in the group
(up to a specified word length).

The array of matrices is *not* typically ordered lexicographically. To
get a list of words corresponding to the matrices returned, pass the
`with_words` flag when calling
`Representation.freely_reduced_elements` (see the documentation for
that function for details).


```python
rep = representation.Representation()
rep[&#34;a&#34;] = np.array([
    [3.0, 0.0],
    [0.0, 1/3.0]
])
rep[&#34;b&#34;] = np.array([
    [1.0, -1.0],
    [1.0, 1.0]
]) / np.sqrt(2)


rep.freely_reduced_elements(6)
```




    array([[[ 1.00000000e+00,  0.00000000e+00],
            [ 0.00000000e+00,  1.00000000e+00]],

           [[ 7.07106781e-01,  7.07106781e-01],
            [-7.07106781e-01,  7.07106781e-01]],

           [[ 2.12132034e+00,  2.12132034e+00],
            [-2.35702260e-01,  2.35702260e-01]],

           ...,

           [[-2.12132034e+00, -2.12132034e+00],
            [ 2.35702260e-01, -2.35702260e-01]],

           [[-2.35702260e-01, -2.35702260e-01],
            [ 2.12132034e+00, -2.12132034e+00]],

           [[-1.07699575e-16, -1.00000000e+00],
            [ 1.00000000e+00,  7.51818954e-17]]])



You can speed up this process even more if you have access to a finite
state automaton which provides a unique word for each element in your
group.

For instance, to find the image of a Cayley ball of radius 10 under
the canonical representation of a (3,3,4) triangle group, you can use
the `Representation.automaton_accepted` method as follows:


```python
from geometry_tools import coxeter
from geometry_tools.automata import fsa

# create the representation and load the built-in automaton
rep = coxeter.TriangleGroup((3,3,4)).canonical_representation()
automaton = fsa.load_builtin(&#39;cox334.wa&#39;)

rep.automaton_accepted(automaton, 10)
```




    array([[[ 1.00000000e+00,  0.00000000e+00,  0.00000000e+00],
            [ 0.00000000e+00,  1.00000000e+00,  0.00000000e+00],
            [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],

           [[ 4.44089210e-16, -1.00000000e+00,  2.41421356e+00],
            [ 1.00000000e+00, -1.00000000e+00,  1.00000000e+00],
            [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],

           [[-1.00000000e+00,  1.00000000e+00,  1.41421356e+00],
            [ 0.00000000e+00,  1.00000000e+00,  0.00000000e+00],
            [ 0.00000000e+00,  0.00000000e+00,  1.00000000e+00]],

           ...,

           [[-2.47279221e+01,  2.57279221e+01,  2.23137085e+01],
            [-2.91421356e+01,  2.91421356e+01,  2.71421356e+01],
            [-1.50710678e+01,  1.50710678e+01,  1.40710678e+01]],

           [[-7.24264069e+00,  7.24264069e+00,  6.82842712e+00],
            [-1.06568542e+01,  1.16568542e+01,  9.24264069e+00],
            [-5.82842712e+00,  6.82842712e+00,  4.82842712e+00]],

           [[-2.47279221e+01,  2.57279221e+01,  2.23137085e+01],
            [-1.06568542e+01,  1.16568542e+01,  9.24264069e+00],
            [-3.05563492e+01,  3.29705627e+01,  2.67279221e+01]]])

    &#34;&#34;&#34;

import re
import itertools

import numpy as np
from scipy.special import binom

from . import utils
from .automata import fsa

def semi_gens(generators):
    &#34;&#34;&#34;Get an iterable of semigroup generators from an iterable of group generators.

    Given a sequence of lowercase/uppercase letters, return only the
    lowercase ones.

    Parameters
    ----------
    generators : iterable of strings
        Sequence of semigroup generators

    Yields
    ------
    gen : string
        the lowercase characters in `generators`

    &#34;&#34;&#34;
    for gen in generators:
        if re.match(&#34;[a-z]&#34;, gen):
            yield gen

class Representation:
    &#34;&#34;&#34;Model a representation for a finitely generated group
    representation into GL(n).
    &#34;&#34;&#34;

    @property
    def dim(self):
        return self._dim

    def freely_reduced_elements(self, length, maxlen=True,
                                with_words=False):
        &#34;&#34;&#34;Return group elements, one for each freely reduced word
           in the generators.

        Parameters
        ----------
        length : int
            maximum length of a word to find a representation of
        maxlen : bool
            If `True` (the default), the returned array has one
            element for each word up to length `length`
            (inclusive). If `False`, only compute the image of words
            of length exactly equal to `length`.
        with_words : bool
            If `True`, also return the list of words corresponding to
            the computed matrices.

        Returns
        -------
        result : ndarray or tuple
            If `with_words` is `True`, `result` is a tuple `(elements, words)`,
            where `elements` is an ndarray of shape `(k, n, n)`,
            containing one matrix for each of the `k` freely reduced
            words in the generators, and `words` is a python list of
            strings, containing those words. If `with_words` is
            `False`, just return `elements`.

        &#34;&#34;&#34;
        automaton = fsa.free_automaton(list(self.semi_gens()))
        return self.automaton_accepted(automaton, length,
                                       maxlen=maxlen,
                                       with_words=with_words)

    def free_words_of_length(self, length):
        &#34;&#34;&#34;Yield freely reduced words in the generators, of a specified length.

        Parameters
        ----------
        length : int
            the length of words to return

        Yields
        ------
        word : string
            All freely reduced words in the generators of length
            `length`.

        &#34;&#34;&#34;

        if length == 0:
            yield &#34;&#34;
        else:
            for word in self.free_words_of_length(length - 1):
                for generator in self.generators:
                    if len(word) == 0 or generator != utils.invert_gen(word[-1]):
                        yield word + generator

    def free_words_less_than(self, length):
        &#34;&#34;&#34;Yield freely reduced words in the generators, up to a specified
        length.

        Parameters
        ----------
        length : int
            the maximum length of words to return

        Yields
        ------
        word : string
            All freely reduced words in the generators, up to length
            `length` (inclusive)

        &#34;&#34;&#34;
        for i in range(length):
            for word in self.free_words_of_length(i):
                yield word

    def automaton_accepted(self, automaton, length,
                           maxlen=True, with_words=False,
                           start_state=None, end_state=None,
                           precomputed=None):
        &#34;&#34;&#34;Return group elements representing words accepted by a
           finite-state automaton.

        Parameters
        ----------
        automaton : automata.fsa.FSA
            Finite-state automaton which determines the accepted words
        length : int
            Maximum length of a word to compute
        maxlen : bool
            if `True` (the default), compute representations of all
            accepted words of length up to `length`. If `False`, only
            compute representations of words whose length is exactly
            `length`.
        with_words : bool
            Whether to return a list of accepted words along with the
            computed array of images.
        start_state: object
            vertex of the automaton to use as the starting state for
            all accepted words. If `None`, then the default start
            vertex of the automaton is used. *Note*: at most one of
            `start_state` and `end_state` can be specified.
        end_state: object
            vertex of the automaton where all accepted paths must
            end. If `None`, then any ending state is allowed. *Note*:
            at most one of `start_state` and `end_state` can be
            specified.
        precomputed: dict
            dictionary giving precomputed values of this
            function. Keys are tuples of then form `(length, state)`,
            where `length` is an integer and `state` is a vertex of
            the automaton. If `None`, use an empty dictionary. In
            either case, the dictionary will be populated when the
            function is called.

        Returns
        -------
        result : ndarray or tuple
            If `with_words` is `True`, `result` is a tuple `(elements, words)`,
            where `elements` is an ndarray containing one
            matrix for each accepted word, and `words` is a list of
            strings containing the corresponding words. If
            `with_words` is `False`, just return `elements`.

        &#34;&#34;&#34;

        if start_state is not None and end_state is not None:
            raise ValueError(&#34;At most one of start_state and end_state &#34;
                             &#34;can be specified&#34;)

        as_start = True
        state = None

        if start_state is not None:
            state = start_state
            as_start = True

        if end_state is not None:
            state = end_state
            as_start = False

        return self._automaton_accepted(automaton, length,
                                        maxlen=maxlen,
                                        with_words=with_words,
                                        state=state,
                                        as_start=as_start,
                                        precomputed=precomputed)


    def _automaton_accepted(self, automaton, length,
                           state=None, as_start=True, maxlen=True,
                           precomputed=None, with_words=False):

        if precomputed is None:
            precomputed = {}

        if (length, state) in precomputed:
            return precomputed[(length, state)]

        empty_arr = np.array([]).reshape((0, self.dim, self.dim))

        if length == 0:
            if state is None or as_start or state in automaton.start_vertices:
                id_array = np.array([np.identity(self.dim)])
                if with_words:
                    return (id_array, [&#34;&#34;])
                return id_array

            if with_words:
                return (empty_arr, [])
            return empty_arr

        if state is None:
            as_start = True
            state = automaton.start_vertices[0]

        if as_start:
            adj_states = automaton.out_dict[state]
        else:
            adj_states = automaton.in_dict[state]

        if len(adj_states) == 0 and not as_start:
            if with_words:
                return (empty_arr, [])
            return empty_arr


        matrix_list = []
        accepted_words = []
        for adj_state, labels in adj_states.items():
            for label in labels:
                result = self._automaton_accepted(
                    automaton, length - 1,
                    state=adj_state,
                    as_start=as_start,
                    maxlen=maxlen,
                    precomputed=precomputed,
                    with_words=with_words
                )
                if with_words:
                    matrices, words = result
                    if as_start:
                        words = [label + word for word in words]
                    else:
                        words = [word + label for word in words]
                    accepted_words += words
                else:
                    matrices = result

                if as_start:
                    matrices = self._word_value(label) @ matrices
                else:
                    matrices = matrices @ self._word_value(label)
                matrix_list.append(matrices)

        accepted_matrices = np.concatenate(matrix_list)
        if maxlen and length &gt; 1:
            additional_result = self._automaton_accepted(
                automaton, 1,
                state=state,
                as_start=as_start,
                maxlen=False,
                with_words=with_words,
                precomputed=precomputed
            )
            if with_words:
                additional_mats, additional_words = additional_result
                accepted_words = additional_words + accepted_words
            else:
                additional_mats = additional_result

            accepted_matrices = np.concatenate(
                [additional_mats, accepted_matrices]
            )

        if with_words:
            accepted = (accepted_matrices, accepted_words)
        else:
            accepted = accepted_matrices

        precomputed[(length, state)] = accepted
        return accepted

    def elements(self, words):
        &#34;&#34;&#34;Get images of an iterable of words.

        Parameters
        ----------
        words : iterable of strings
            words to find the image of under the representation

        Returns
        -------
        ndarray
            numpy array of shape `(l, n, n)`, where `l` is the length
            of `words` and `n` is the dimension of the representation.

        &#34;&#34;&#34;
        return np.array(
            [self._word_value(word) for word in words]
        )

    def semi_gens(self):
        &#34;&#34;&#34;Iterate over group generator names for this representation.

        Only iterate over group generators (lowercase letters), not
        semigroup generators (upper and lowercase letters).

        Yields
        ------
        gen : string
            group generator names

        &#34;&#34;&#34;
        return semi_gens(self.generators.keys())

    def __init__(self, representation=None,
                 generator_names=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        representation : Representation
            Representation to copy elements from
        generator_names : iterable of strings
            Names to use for the generators. These must be initialized
            as arrays later to use the representation properly.

        &#34;&#34;&#34;

        self._dim = None

        if representation is not None:
            if generator_names is None:
                generator_names = list(representation.generators)

            self.generators = {}
            for gen in semi_gens(generator_names):
                self[gen] = representation[gen]

            self._dim = representation._dim

        else:
            if generator_names is None:
                generator_names = []

            self.generators = {name[0].lower():None
                               for name in semi_gens(generator_names)}

            for gen in list(self.generators):
                self.generators[gen.upper()] = None

    def _word_value(self, word):
        matrix = np.identity(self._dim)
        for i, letter in enumerate(word):
            matrix = matrix @ self.generators[letter]
        return matrix

    def __getitem__(self, word):
        return self._word_value(word)

    def __setitem__(self, generator, matrix):
        shape = matrix.shape

        if self._dim is None:
            self._dim = shape[0]
        if shape[0] != shape[1]:
            raise ValueError(&#34;Matrices representing group elements must be square&#34;)
        if shape[0] != self._dim:
            raise ValueError(
                &#34;Every matrix in the representation must have the same shape&#34;
            )

        self.generators[generator] = matrix
        self.generators[utils.invert_gen(generator)] = np.linalg.inv(matrix)

    def tensor_product(self, rep):
        &#34;&#34;&#34;Return a tensor product of this representation with `rep`.

        Parameters
        ----------
        rep : Representation
            Representation to tensor with.

        Raises
        ------
        ValueError
            Raised if `self` and `rep` have differing generating sets.

        Returns
        -------
        tensor: Representation
            Representation giving the tensor product of self with `rep`.

        &#34;&#34;&#34;
        if set(rep.generators) != set(self.generators):
            raise ValueError(
                &#34;Cannot take a tensor product of a representation of groups with &#34;
                &#34;different presentations&#34;
            )
        else:
            product_rep = Representation()
            for gen in self.semi_gens():
                tens = np.tensordot(self[gen], rep[gen], axes=0)
                elt = np.concatenate(np.concatenate(tens, axis=1), axis=1)
                product_rep[gen] = np.matrix(elt)
            return product_rep

    def symmetric_square(self):
        &#34;&#34;&#34;Return the symmetric square of this representation.

        Returns
        -------
        square : Representation
            Symmetric square of `self`.

        &#34;&#34;&#34;

        tensor_rep = self.tensor_product(self)
        incl = symmetric_inclusion(self._dim)
        proj = symmetric_projection(self._dim)
        square_rep = Representation()
        for g in self.semi_gens():
            square_rep[g] = proj * tensor_rep[g] * incl

        return square_rep


def sym_index(i, j, n):
    r&#34;&#34;&#34;Return coordinate indices for an isomorphism
    \(\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^{\binom{n}{2} + n}\).

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for \(\mathbb{R}^n\),
    the isomorphism is realized by giving \(\mathrm{Sym}^2(\mathbb{R}^n)\)
    the ordered basis
    \[
        \{e_ne_n, e_{n-1}e_{n-1}, e_{n-1}e_n,
        e_{n-1}e_{n-1}, e_{n-1}e_{n-2}, e_{n-1}e_{n-3}, \ldots \}.
    \]
    Schematically this is given by the symmetric matrix

    \[\begin{pmatrix} \ddots \\
    &amp; 3 &amp; 4 &amp; 5 \\
    &amp; &amp; 1 &amp; 2 \\
    &amp; &amp; &amp; 0
    \end{pmatrix},
    \]
    where the (i,j) entry of the matrix gives the index of basis
    element \(e_ie_j\).

    Parameters
    ----------
    i : int
        index of one of the terms in the basis monomial \(e_ie_j\) for the
        symmetric square
    j : int
        index of the other term in the basis monomial \(e_ie_j\) for the
        symmetric square
    n : int
        dimension of the underlying vector space \(\mathbb{R}^n\).

    Returns
    -------
    int
        index of the corresponding basis vector in
        \(\mathbb{R}^{\binom{n}{2} + n}\).

    &#34;&#34;&#34;
    if i &gt; j:
        i, j = j, i
    return int((n - i) * (n - i  - 1) / 2 + (j - i))

def tensor_pos(i, n):
    r&#34;&#34;&#34;Return coordinate indices for an isomorphism
    \(\mathbb{R}^{n^2} \to \mathbb{R}^n \otimes \mathbb{R}^n\).

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for
    \(\mathbb{R}^n\), the isomorphism is realized by giving
    \(\mathbb{R}^n \otimes \mathbb{R}^n\) the ordered basis
    \[
    \{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
    \]
    represented schematically by the matrix
    \[
        \begin{pmatrix}
            0 &amp; 1 &amp; \ldots \\
            n &amp; n + 1 &amp; \ldots\\
            \vdots
        \end{pmatrix}.
    \]
    Here the (i, j) entry of the matrix gives the index of the basis
    element \(e_i \otimes e_j\).

    The inverse of this isomorphism is given by `tensor_index`.

    Parameters
    ----------
    i : int
        index of a basis vector in \(\mathbb{R}^{n^2}\)
    n : int
        dimension of the underlying vector space \(\mathbb{R}^n\)

    Returns
    -------
    tuple
        tuple `(j, k)` determining the monomial \(e_j \otimes e_k\)
        mapped to by given the basis vector in \(\mathbb{R}^{n^2}\).

    &#34;&#34;&#34;
    return int(i / n), i % n

def tensor_index(i,j,n):
    r&#34;&#34;&#34;Return coordinate indices for an isomorphism
    \(\mathbb{R}^n \otimes \mathbb{R}^n \to \mathbb{R}^{n^2}\).

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for
    \(\mathbb{R}^n\), the isomorphism is realized by giving
    \(\mathbb{R}^n \otimes \mathbb{R}^n\) the ordered basis
    \[
    \{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
    \]
    represented schematically by the matrix
    \[
        \begin{pmatrix}
            0 &amp; 1 &amp; \ldots \\
            n &amp; n + 1 &amp; \ldots\\
            \vdots
        \end{pmatrix}.
    \]
    Here the (i, j) entry of the matrix gives the index of the basis
    element \(e_i \otimes e_j\).

    The inverse of this isomorphism is given by `tensor_pos`.

    Parameters
    ----------
    i : int
        index of one of the terms in a basis vector \(e_i \otimes e_j\).
    j : int
        index of the other term in a basis vector \(e_i \times e_j\).
    n : int
        dimension of the underlying vector space \(\mathbb{R}^n\)

    Returns
    -------
    int
        index of a basis vector in \(\mathbb{R}^{n^2}\) mapped to by
        \(e_i \otimes e_j\).
    &#34;&#34;&#34;
    return i * n + j

def symmetric_inclusion(n):
    r&#34;&#34;&#34;Return a matrix representing the linear inclusion
    \(\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^n \otimes
    \mathbb{R}^n\).

    \(\mathrm{Sym}^2(\mathbb{R}^n)\) and
    \(\mathbb{R}^n \otimes \mathbb{R}^n\)
    are respectively identified with
    \(\mathbb{R}^{\binom{n}{2} + n}\) and \(\mathbb{R}^{n^2}\) via the
    isomorphisms described in `sym_index`, `tensor_index`, and
    `tensor_pos`.

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for
    \(\mathbb{R}^n\), the returned matrix gives the linear map taking
    \(e_ie_j\) to \(\frac{1}{2}(e_i \otimes e_j + e_j \otimes e_i)\),
    with respect to the bases specified above.

    Parameters
    ----------
    n : int
        Dimension of the underlying vector space \(\mathbb{R}^n\).

    Returns
    -------
    matrix : ndarray
        \(n^2 \times \binom{n}{2} + n\) array defining this linear map.

    &#34;&#34;&#34;
    incl_matrix = np.zeros((n * n, int(n * (n + 1) / 2)))
    for i in range(n):
        for j in range(n):
            si = sym_index(i, j, n)
            ti = tensor_index(i, j, n)
            incl_matrix[ti][si] = 1/2 + (i == j) * 1/2

    return np.matrix(incl_matrix)

def symmetric_projection(n):
    r&#34;&#34;&#34;Return a matrix representing the linear surjection
    \(\mathbb{R}^n \otimes \mathbb{R}^n \to \mathrm{Sym}^2(\mathbb{R}^n)\).

    If \(\mathbb{R}^n\) is given the standard basis \(\{e_1, \ldots,
    e_n\}\), then this matrix represents the linear map determined by
    \(e_i \otimes e_j \mapsto e_ie_j\). The spaces
    \(\mathbb{R}^n \otimes \mathbb{R}^n\) and \(\mathrm{Sym}^2(\mathbb{R}^n)\)
    are given the ordered bases determined by the functions
    `sym_index`, `tensor_index`, and `tensor_pos`.

    Parameters
    ----------
    n : int
        Dimension of the underlying vector space \(\mathbb{R}^n\)

    Returns
    -------
    ndarray
        \(\binom{n}{2} + n \times n\) matrix representing the linear map
        in the given bases.

    &#34;&#34;&#34;
    proj_matrix = np.zeros((int(n * (n + 1) / 2), n * n))
    for i in range(n * n):
        u, v = tensor_pos(i,n)
        proj_matrix[_sym_index(u, v, n)][i] = 1

    return np.matrix(proj_matrix)

def sl2_irrep(A, n):
    r&#34;&#34;&#34;The irreducible representation \(\mathrm{SL}(2) \to
    \mathrm{SL}(n)\), via the action on homogeneous polynomials.

    Given an element of \(\mathrm{SL}(2)\) as a 2x2 array, compute a
    matrix giving the action of this matrix on symmetric polynomials
    in elements of the standard basis \(\{e_1, e_2\}\). The (ordered)
    basis for the new matrix is given by the degree-(n-1) monomials
    \(\{e_1^{0} e_2^{n-1}, e_1^{1} e_2^{n-2}, \ldots, e_1^{n-1}e_2^{0}\}\).

    Parameters
    ----------
    A : ndarray
        Array of shape `(..., 2, 2)`, giving a matrix (or array of
        matrices) to represent.
    n : int
        Dimension of the irreducible representation.

    Returns
    -------
    result : ndarray
        Array of shape `(..., n, n)` giving the representation of
        `A` under the `dim`-dimensional irreducible representation of
        \(\mathrm{SL}(2)\).

    &#34;&#34;&#34;

    a = A[..., 0, 0]
    b = A[..., 0, 1]
    c = A[..., 1, 0]
    d = A[..., 1, 1]

    im = np.zeros(A.shape[:-2] +(n, n))
    r = n - 1
    for k in range(n):
        for j in range(n):
            for i in range(max(0, j - r + k), min(j+1, k+1)):
                im[..., j,k] += (binom(k,i) * binom(r - k, j - i)
                          * a**i * c**(k - i) * b**(j - i)
                          * d**(r - k - j + i))
    return im

def sl2_to_so21(A):
    r&#34;&#34;&#34;Return the image of an element of \(\mathrm{SL}(2, \mathbb{R})\)
    under the isomorphism \(\mathrm{SL}(2, \mathbb{R}) \to
    \mathrm{SO}(2,1)\).

    Here \(\mathrm{SO}(2,1)\) preserves the symmetric bilinear form
    determined by the matrix `diag(-1, 1, 1)` (in the standard basis on
    \(\mathbb{R}^3\)).

    An inverse for this representation is given by the function
    `o_to_pgl`.

    Parameters
    ----------
    A : ndarray
        Array of shape `(..., 2, 2)` giving a matrix (or array of
        matrices) in \(\mathrm{SL}(2, \mathbb{R})\).

    Returns
    -------
    result : ndarray
        Array of shape `(..., 3, 3)` giving the image of `A` under the
        representation.

    &#34;&#34;&#34;
    killing_conj = np.array([[-0., -1., -0.],
                             [-1., -0.,  1.],
                             [-1., -0., -1.]])
    permutation = utils.permutation_matrix((2,1,0))

    A_3 = sl2_irrep(A, 3)
    return (permutation @ killing_conj @ A_3 @
            np.linalg.inv(killing_conj) @ permutation)

def o_to_pgl(A, bilinear_form=np.diag((-1., 1., 1.))):
    r&#34;&#34;&#34;Return the image of an element of \(\mathrm{O}(2, 1)\) under the
    representation \(\mathrm{O}(2,1) \to \mathrm{GL}(2)\).

    On \(\mathrm{SO}(2, 1)\), this restricts to an inverse of the
    isomorphism \(\mathrm{SL}(2, \mathbb{R}) \to \mathrm{SO}(2, 1)\)
    given by the function `sl2_to_so21`.

    Parameters
    ----------
    A : ndarray
        Array of shape `(..., 3, 3)` giving a matrix (or array of
        matrices) preserving a bilinear form of signature (2, 1).
    bilinear_form : ndarray
        3x3 matrix giving the bilinear form preserved by `A`. By
        default, the diagonal form `diag(-1, 1, 1)`.

    Returns
    -------
    result : ndarray
        Array of shape `(..., 2, 2)` giving the image of `A` under
        this representation.

    &#34;&#34;&#34;
    conj = np.eye(3)
    conj_i = np.eye(3)

    if bilinear_form is not None:
        killing_conj = np.array([[ 0. , -0.5, -0.5],
                                 [-1. ,  0. ,  0. ],
                                 [ 0. ,  0.5, -0.5]])

        form_conj = utils.diagonalize_form(bilinear_form,
                                      order_eigenvalues=&#34;minkowski&#34;,
                                      reverse=True)

        conj = form_conj @ np.linalg.inv(killing_conj)
        conj_i = killing_conj @ np.linalg.inv(form_conj)

    A_d = conj_i @ A @ conj

    a = np.sqrt(np.abs(A_d[0][0]))
    b = np.sqrt(np.abs(A_d[2][0]))
    c = np.sqrt(np.abs(A_d[0][2]))
    d = np.sqrt(np.abs(A_d[2][2]))

    if A_d[0][1] &lt; 0:
        b = b * -1
    if A_d[1][0] &lt; 0:
        c = c * -1
    if A_d[1][2] * A_d[0][1] &lt; 0:
        d = d * -1

    return np.array([[a, b],
                     [c, d]])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geometry_tools.representation.o_to_pgl"><code class="name flex">
<span>def <span class="ident">o_to_pgl</span></span>(<span>A, bilinear_form=array([[-1.,
0.,
0.],
[ 0.,
1.,
0.],
[ 0.,
0.,
1.]]))</span>
</code></dt>
<dd>
<div class="desc"><p>Return the image of an element of <span><span class="MathJax_Preview">\mathrm{O}(2, 1)</span><script type="math/tex">\mathrm{O}(2, 1)</script></span> under the
representation <span><span class="MathJax_Preview">\mathrm{O}(2,1) \to \mathrm{GL}(2)</span><script type="math/tex">\mathrm{O}(2,1) \to \mathrm{GL}(2)</script></span>.</p>
<p>On <span><span class="MathJax_Preview">\mathrm{SO}(2, 1)</span><script type="math/tex">\mathrm{SO}(2, 1)</script></span>, this restricts to an inverse of the
isomorphism <span><span class="MathJax_Preview">\mathrm{SL}(2, \mathbb{R}) \to \mathrm{SO}(2, 1)</span><script type="math/tex">\mathrm{SL}(2, \mathbb{R}) \to \mathrm{SO}(2, 1)</script></span>
given by the function <code><a title="geometry_tools.representation.sl2_to_so21" href="#geometry_tools.representation.sl2_to_so21">sl2_to_so21()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, 3, 3)</code> giving a matrix (or array of
matrices) preserving a bilinear form of signature (2, 1).</dd>
<dt><strong><code>bilinear_form</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>3x3 matrix giving the bilinear form preserved by <code>A</code>. By
default, the diagonal form <code>diag(-1, 1, 1)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, 2, 2)</code> giving the image of <code>A</code> under
this representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def o_to_pgl(A, bilinear_form=np.diag((-1., 1., 1.))):
    r&#34;&#34;&#34;Return the image of an element of \(\mathrm{O}(2, 1)\) under the
    representation \(\mathrm{O}(2,1) \to \mathrm{GL}(2)\).

    On \(\mathrm{SO}(2, 1)\), this restricts to an inverse of the
    isomorphism \(\mathrm{SL}(2, \mathbb{R}) \to \mathrm{SO}(2, 1)\)
    given by the function `sl2_to_so21`.

    Parameters
    ----------
    A : ndarray
        Array of shape `(..., 3, 3)` giving a matrix (or array of
        matrices) preserving a bilinear form of signature (2, 1).
    bilinear_form : ndarray
        3x3 matrix giving the bilinear form preserved by `A`. By
        default, the diagonal form `diag(-1, 1, 1)`.

    Returns
    -------
    result : ndarray
        Array of shape `(..., 2, 2)` giving the image of `A` under
        this representation.

    &#34;&#34;&#34;
    conj = np.eye(3)
    conj_i = np.eye(3)

    if bilinear_form is not None:
        killing_conj = np.array([[ 0. , -0.5, -0.5],
                                 [-1. ,  0. ,  0. ],
                                 [ 0. ,  0.5, -0.5]])

        form_conj = utils.diagonalize_form(bilinear_form,
                                      order_eigenvalues=&#34;minkowski&#34;,
                                      reverse=True)

        conj = form_conj @ np.linalg.inv(killing_conj)
        conj_i = killing_conj @ np.linalg.inv(form_conj)

    A_d = conj_i @ A @ conj

    a = np.sqrt(np.abs(A_d[0][0]))
    b = np.sqrt(np.abs(A_d[2][0]))
    c = np.sqrt(np.abs(A_d[0][2]))
    d = np.sqrt(np.abs(A_d[2][2]))

    if A_d[0][1] &lt; 0:
        b = b * -1
    if A_d[1][0] &lt; 0:
        c = c * -1
    if A_d[1][2] * A_d[0][1] &lt; 0:
        d = d * -1

    return np.array([[a, b],
                     [c, d]])</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.semi_gens"><code class="name flex">
<span>def <span class="ident">semi_gens</span></span>(<span>generators)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an iterable of semigroup generators from an iterable of group generators.</p>
<p>Given a sequence of lowercase/uppercase letters, return only the
lowercase ones.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>generators</code></strong> :&ensp;<code>iterable</code> of <code>strings</code></dt>
<dd>Sequence of semigroup generators</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>gen</code></strong> :&ensp;<code>string</code></dt>
<dd>the lowercase characters in <code>generators</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semi_gens(generators):
    &#34;&#34;&#34;Get an iterable of semigroup generators from an iterable of group generators.

    Given a sequence of lowercase/uppercase letters, return only the
    lowercase ones.

    Parameters
    ----------
    generators : iterable of strings
        Sequence of semigroup generators

    Yields
    ------
    gen : string
        the lowercase characters in `generators`

    &#34;&#34;&#34;
    for gen in generators:
        if re.match(&#34;[a-z]&#34;, gen):
            yield gen</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.sl2_irrep"><code class="name flex">
<span>def <span class="ident">sl2_irrep</span></span>(<span>A, n)</span>
</code></dt>
<dd>
<div class="desc"><p>The irreducible representation <span><span class="MathJax_Preview">\mathrm{SL}(2) \to
\mathrm{SL}(n)</span><script type="math/tex">\mathrm{SL}(2) \to
\mathrm{SL}(n)</script></span>, via the action on homogeneous polynomials.</p>
<p>Given an element of <span><span class="MathJax_Preview">\mathrm{SL}(2)</span><script type="math/tex">\mathrm{SL}(2)</script></span> as a 2x2 array, compute a
matrix giving the action of this matrix on symmetric polynomials
in elements of the standard basis <span><span class="MathJax_Preview">\{e_1, e_2\}</span><script type="math/tex">\{e_1, e_2\}</script></span>. The (ordered)
basis for the new matrix is given by the degree-(n-1) monomials
<span><span class="MathJax_Preview">\{e_1^{0} e_2^{n-1}, e_1^{1} e_2^{n-2}, \ldots, e_1^{n-1}e_2^{0}\}</span><script type="math/tex">\{e_1^{0} e_2^{n-1}, e_1^{1} e_2^{n-2}, \ldots, e_1^{n-1}e_2^{0}\}</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, 2, 2)</code>, giving a matrix (or array of
matrices) to represent.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of the irreducible representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, n, n)</code> giving the representation of
<code>A</code> under the <code>dim</code>-dimensional irreducible representation of
<span><span class="MathJax_Preview">\mathrm{SL}(2)</span><script type="math/tex">\mathrm{SL}(2)</script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sl2_irrep(A, n):
    r&#34;&#34;&#34;The irreducible representation \(\mathrm{SL}(2) \to
    \mathrm{SL}(n)\), via the action on homogeneous polynomials.

    Given an element of \(\mathrm{SL}(2)\) as a 2x2 array, compute a
    matrix giving the action of this matrix on symmetric polynomials
    in elements of the standard basis \(\{e_1, e_2\}\). The (ordered)
    basis for the new matrix is given by the degree-(n-1) monomials
    \(\{e_1^{0} e_2^{n-1}, e_1^{1} e_2^{n-2}, \ldots, e_1^{n-1}e_2^{0}\}\).

    Parameters
    ----------
    A : ndarray
        Array of shape `(..., 2, 2)`, giving a matrix (or array of
        matrices) to represent.
    n : int
        Dimension of the irreducible representation.

    Returns
    -------
    result : ndarray
        Array of shape `(..., n, n)` giving the representation of
        `A` under the `dim`-dimensional irreducible representation of
        \(\mathrm{SL}(2)\).

    &#34;&#34;&#34;

    a = A[..., 0, 0]
    b = A[..., 0, 1]
    c = A[..., 1, 0]
    d = A[..., 1, 1]

    im = np.zeros(A.shape[:-2] +(n, n))
    r = n - 1
    for k in range(n):
        for j in range(n):
            for i in range(max(0, j - r + k), min(j+1, k+1)):
                im[..., j,k] += (binom(k,i) * binom(r - k, j - i)
                          * a**i * c**(k - i) * b**(j - i)
                          * d**(r - k - j + i))
    return im</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.sl2_to_so21"><code class="name flex">
<span>def <span class="ident">sl2_to_so21</span></span>(<span>A)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the image of an element of <span><span class="MathJax_Preview">\mathrm{SL}(2, \mathbb{R})</span><script type="math/tex">\mathrm{SL}(2, \mathbb{R})</script></span>
under the isomorphism <span><span class="MathJax_Preview">\mathrm{SL}(2, \mathbb{R}) \to
\mathrm{SO}(2,1)</span><script type="math/tex">\mathrm{SL}(2, \mathbb{R}) \to
\mathrm{SO}(2,1)</script></span>.</p>
<p>Here <span><span class="MathJax_Preview">\mathrm{SO}(2,1)</span><script type="math/tex">\mathrm{SO}(2,1)</script></span> preserves the symmetric bilinear form
determined by the matrix <code>diag(-1, 1, 1)</code> (in the standard basis on
<span><span class="MathJax_Preview">\mathbb{R}^3</span><script type="math/tex">\mathbb{R}^3</script></span>).</p>
<p>An inverse for this representation is given by the function
<code><a title="geometry_tools.representation.o_to_pgl" href="#geometry_tools.representation.o_to_pgl">o_to_pgl()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>A</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, 2, 2)</code> giving a matrix (or array of
matrices) in <span><span class="MathJax_Preview">\mathrm{SL}(2, \mathbb{R})</span><script type="math/tex">\mathrm{SL}(2, \mathbb{R})</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of shape <code>(&hellip;, 3, 3)</code> giving the image of <code>A</code> under the
representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sl2_to_so21(A):
    r&#34;&#34;&#34;Return the image of an element of \(\mathrm{SL}(2, \mathbb{R})\)
    under the isomorphism \(\mathrm{SL}(2, \mathbb{R}) \to
    \mathrm{SO}(2,1)\).

    Here \(\mathrm{SO}(2,1)\) preserves the symmetric bilinear form
    determined by the matrix `diag(-1, 1, 1)` (in the standard basis on
    \(\mathbb{R}^3\)).

    An inverse for this representation is given by the function
    `o_to_pgl`.

    Parameters
    ----------
    A : ndarray
        Array of shape `(..., 2, 2)` giving a matrix (or array of
        matrices) in \(\mathrm{SL}(2, \mathbb{R})\).

    Returns
    -------
    result : ndarray
        Array of shape `(..., 3, 3)` giving the image of `A` under the
        representation.

    &#34;&#34;&#34;
    killing_conj = np.array([[-0., -1., -0.],
                             [-1., -0.,  1.],
                             [-1., -0., -1.]])
    permutation = utils.permutation_matrix((2,1,0))

    A_3 = sl2_irrep(A, 3)
    return (permutation @ killing_conj @ A_3 @
            np.linalg.inv(killing_conj) @ permutation)</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.sym_index"><code class="name flex">
<span>def <span class="ident">sym_index</span></span>(<span>i, j, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return coordinate indices for an isomorphism
<span><span class="MathJax_Preview">\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^{\binom{n}{2} + n}</span><script type="math/tex">\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^{\binom{n}{2} + n}</script></span>.</p>
<p>If <span><span class="MathJax_Preview">\{e_1, \ldots, e_n\}</span><script type="math/tex">\{e_1, \ldots, e_n\}</script></span> is the standard basis for <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>,
the isomorphism is realized by giving <span><span class="MathJax_Preview">\mathrm{Sym}^2(\mathbb{R}^n)</span><script type="math/tex">\mathrm{Sym}^2(\mathbb{R}^n)</script></span>
the ordered basis
<span><span class="MathJax_Preview">
\{e_ne_n, e_{n-1}e_{n-1}, e_{n-1}e_n,
e_{n-1}e_{n-1}, e_{n-1}e_{n-2}, e_{n-1}e_{n-3}, \ldots \}.
</span><script type="math/tex; mode=display">
\{e_ne_n, e_{n-1}e_{n-1}, e_{n-1}e_n,
e_{n-1}e_{n-1}, e_{n-1}e_{n-2}, e_{n-1}e_{n-3}, \ldots \}.
</script></span>
Schematically this is given by the symmetric matrix</p>
<p><span><span class="MathJax_Preview">\begin{pmatrix} \ddots \\
&amp; 3 &amp; 4 &amp; 5 \\
&amp; &amp; 1 &amp; 2 \\
&amp; &amp; &amp; 0
\end{pmatrix},
</span><script type="math/tex; mode=display">\begin{pmatrix} \ddots \\
& 3 & 4 & 5 \\
& & 1 & 2 \\
& & & 0
\end{pmatrix},
</script></span>
where the (i,j) entry of the matrix gives the index of basis
element <span><span class="MathJax_Preview">e_ie_j</span><script type="math/tex">e_ie_j</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>index of one of the terms in the basis monomial <span><span class="MathJax_Preview">e_ie_j</span><script type="math/tex">e_ie_j</script></span> for the
symmetric square</dd>
<dt><strong><code>j</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the other term in the basis monomial <span><span class="MathJax_Preview">e_ie_j</span><script type="math/tex">e_ie_j</script></span> for the
symmetric square</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>dimension of the underlying vector space <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>index of the corresponding basis vector in
<span><span class="MathJax_Preview">\mathbb{R}^{\binom{n}{2} + n}</span><script type="math/tex">\mathbb{R}^{\binom{n}{2} + n}</script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sym_index(i, j, n):
    r&#34;&#34;&#34;Return coordinate indices for an isomorphism
    \(\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^{\binom{n}{2} + n}\).

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for \(\mathbb{R}^n\),
    the isomorphism is realized by giving \(\mathrm{Sym}^2(\mathbb{R}^n)\)
    the ordered basis
    \[
        \{e_ne_n, e_{n-1}e_{n-1}, e_{n-1}e_n,
        e_{n-1}e_{n-1}, e_{n-1}e_{n-2}, e_{n-1}e_{n-3}, \ldots \}.
    \]
    Schematically this is given by the symmetric matrix

    \[\begin{pmatrix} \ddots \\
    &amp; 3 &amp; 4 &amp; 5 \\
    &amp; &amp; 1 &amp; 2 \\
    &amp; &amp; &amp; 0
    \end{pmatrix},
    \]
    where the (i,j) entry of the matrix gives the index of basis
    element \(e_ie_j\).

    Parameters
    ----------
    i : int
        index of one of the terms in the basis monomial \(e_ie_j\) for the
        symmetric square
    j : int
        index of the other term in the basis monomial \(e_ie_j\) for the
        symmetric square
    n : int
        dimension of the underlying vector space \(\mathbb{R}^n\).

    Returns
    -------
    int
        index of the corresponding basis vector in
        \(\mathbb{R}^{\binom{n}{2} + n}\).

    &#34;&#34;&#34;
    if i &gt; j:
        i, j = j, i
    return int((n - i) * (n - i  - 1) / 2 + (j - i))</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.symmetric_inclusion"><code class="name flex">
<span>def <span class="ident">symmetric_inclusion</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a matrix representing the linear inclusion
<span><span class="MathJax_Preview">\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^n \otimes
\mathbb{R}^n</span><script type="math/tex">\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^n \otimes
\mathbb{R}^n</script></span>.</p>
<p><span><span class="MathJax_Preview">\mathrm{Sym}^2(\mathbb{R}^n)</span><script type="math/tex">\mathrm{Sym}^2(\mathbb{R}^n)</script></span> and
<span><span class="MathJax_Preview">\mathbb{R}^n \otimes \mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n \otimes \mathbb{R}^n</script></span>
are respectively identified with
<span><span class="MathJax_Preview">\mathbb{R}^{\binom{n}{2} + n}</span><script type="math/tex">\mathbb{R}^{\binom{n}{2} + n}</script></span> and <span><span class="MathJax_Preview">\mathbb{R}^{n^2}</span><script type="math/tex">\mathbb{R}^{n^2}</script></span> via the
isomorphisms described in <code><a title="geometry_tools.representation.sym_index" href="#geometry_tools.representation.sym_index">sym_index()</a></code>, <code><a title="geometry_tools.representation.tensor_index" href="#geometry_tools.representation.tensor_index">tensor_index()</a></code>, and
<code><a title="geometry_tools.representation.tensor_pos" href="#geometry_tools.representation.tensor_pos">tensor_pos()</a></code>.</p>
<p>If <span><span class="MathJax_Preview">\{e_1, \ldots, e_n\}</span><script type="math/tex">\{e_1, \ldots, e_n\}</script></span> is the standard basis for
<span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>, the returned matrix gives the linear map taking
<span><span class="MathJax_Preview">e_ie_j</span><script type="math/tex">e_ie_j</script></span> to <span><span class="MathJax_Preview">\frac{1}{2}(e_i \otimes e_j + e_j \otimes e_i)</span><script type="math/tex">\frac{1}{2}(e_i \otimes e_j + e_j \otimes e_i)</script></span>,
with respect to the bases specified above.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of the underlying vector space <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>ndarray</code></dt>
<dd><span><span class="MathJax_Preview">n^2 \times \binom{n}{2} + n</span><script type="math/tex">n^2 \times \binom{n}{2} + n</script></span> array defining this linear map.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symmetric_inclusion(n):
    r&#34;&#34;&#34;Return a matrix representing the linear inclusion
    \(\mathrm{Sym}^2(\mathbb{R}^n) \to \mathbb{R}^n \otimes
    \mathbb{R}^n\).

    \(\mathrm{Sym}^2(\mathbb{R}^n)\) and
    \(\mathbb{R}^n \otimes \mathbb{R}^n\)
    are respectively identified with
    \(\mathbb{R}^{\binom{n}{2} + n}\) and \(\mathbb{R}^{n^2}\) via the
    isomorphisms described in `sym_index`, `tensor_index`, and
    `tensor_pos`.

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for
    \(\mathbb{R}^n\), the returned matrix gives the linear map taking
    \(e_ie_j\) to \(\frac{1}{2}(e_i \otimes e_j + e_j \otimes e_i)\),
    with respect to the bases specified above.

    Parameters
    ----------
    n : int
        Dimension of the underlying vector space \(\mathbb{R}^n\).

    Returns
    -------
    matrix : ndarray
        \(n^2 \times \binom{n}{2} + n\) array defining this linear map.

    &#34;&#34;&#34;
    incl_matrix = np.zeros((n * n, int(n * (n + 1) / 2)))
    for i in range(n):
        for j in range(n):
            si = sym_index(i, j, n)
            ti = tensor_index(i, j, n)
            incl_matrix[ti][si] = 1/2 + (i == j) * 1/2

    return np.matrix(incl_matrix)</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.symmetric_projection"><code class="name flex">
<span>def <span class="ident">symmetric_projection</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a matrix representing the linear surjection
<span><span class="MathJax_Preview">\mathbb{R}^n \otimes \mathbb{R}^n \to \mathrm{Sym}^2(\mathbb{R}^n)</span><script type="math/tex">\mathbb{R}^n \otimes \mathbb{R}^n \to \mathrm{Sym}^2(\mathbb{R}^n)</script></span>.</p>
<p>If <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span> is given the standard basis <span><span class="MathJax_Preview">\{e_1, \ldots,
e_n\}</span><script type="math/tex">\{e_1, \ldots,
e_n\}</script></span>, then this matrix represents the linear map determined by
<span><span class="MathJax_Preview">e_i \otimes e_j \mapsto e_ie_j</span><script type="math/tex">e_i \otimes e_j \mapsto e_ie_j</script></span>. The spaces
<span><span class="MathJax_Preview">\mathbb{R}^n \otimes \mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n \otimes \mathbb{R}^n</script></span> and <span><span class="MathJax_Preview">\mathrm{Sym}^2(\mathbb{R}^n)</span><script type="math/tex">\mathrm{Sym}^2(\mathbb{R}^n)</script></span>
are given the ordered bases determined by the functions
<code><a title="geometry_tools.representation.sym_index" href="#geometry_tools.representation.sym_index">sym_index()</a></code>, <code><a title="geometry_tools.representation.tensor_index" href="#geometry_tools.representation.tensor_index">tensor_index()</a></code>, and <code><a title="geometry_tools.representation.tensor_pos" href="#geometry_tools.representation.tensor_pos">tensor_pos()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Dimension of the underlying vector space <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd><span><span class="MathJax_Preview">\binom{n}{2} + n \times n</span><script type="math/tex">\binom{n}{2} + n \times n</script></span> matrix representing the linear map
in the given bases.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symmetric_projection(n):
    r&#34;&#34;&#34;Return a matrix representing the linear surjection
    \(\mathbb{R}^n \otimes \mathbb{R}^n \to \mathrm{Sym}^2(\mathbb{R}^n)\).

    If \(\mathbb{R}^n\) is given the standard basis \(\{e_1, \ldots,
    e_n\}\), then this matrix represents the linear map determined by
    \(e_i \otimes e_j \mapsto e_ie_j\). The spaces
    \(\mathbb{R}^n \otimes \mathbb{R}^n\) and \(\mathrm{Sym}^2(\mathbb{R}^n)\)
    are given the ordered bases determined by the functions
    `sym_index`, `tensor_index`, and `tensor_pos`.

    Parameters
    ----------
    n : int
        Dimension of the underlying vector space \(\mathbb{R}^n\)

    Returns
    -------
    ndarray
        \(\binom{n}{2} + n \times n\) matrix representing the linear map
        in the given bases.

    &#34;&#34;&#34;
    proj_matrix = np.zeros((int(n * (n + 1) / 2), n * n))
    for i in range(n * n):
        u, v = tensor_pos(i,n)
        proj_matrix[_sym_index(u, v, n)][i] = 1

    return np.matrix(proj_matrix)</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.tensor_index"><code class="name flex">
<span>def <span class="ident">tensor_index</span></span>(<span>i, j, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return coordinate indices for an isomorphism
<span><span class="MathJax_Preview">\mathbb{R}^n \otimes \mathbb{R}^n \to \mathbb{R}^{n^2}</span><script type="math/tex">\mathbb{R}^n \otimes \mathbb{R}^n \to \mathbb{R}^{n^2}</script></span>.</p>
<p>If <span><span class="MathJax_Preview">\{e_1, \ldots, e_n\}</span><script type="math/tex">\{e_1, \ldots, e_n\}</script></span> is the standard basis for
<span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>, the isomorphism is realized by giving
<span><span class="MathJax_Preview">\mathbb{R}^n \otimes \mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n \otimes \mathbb{R}^n</script></span> the ordered basis
<span><span class="MathJax_Preview">
\{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
</span><script type="math/tex; mode=display">
\{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
</script></span>
represented schematically by the matrix
<span><span class="MathJax_Preview">
\begin{pmatrix}
0 &amp; 1 &amp; \ldots \\
n &amp; n + 1 &amp; \ldots\\
\vdots
\end{pmatrix}.
</span><script type="math/tex; mode=display">
\begin{pmatrix}
0 & 1 & \ldots \\
n & n + 1 & \ldots\\
\vdots
\end{pmatrix}.
</script></span>
Here the (i, j) entry of the matrix gives the index of the basis
element <span><span class="MathJax_Preview">e_i \otimes e_j</span><script type="math/tex">e_i \otimes e_j</script></span>.</p>
<p>The inverse of this isomorphism is given by <code><a title="geometry_tools.representation.tensor_pos" href="#geometry_tools.representation.tensor_pos">tensor_pos()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>index of one of the terms in a basis vector <span><span class="MathJax_Preview">e_i \otimes e_j</span><script type="math/tex">e_i \otimes e_j</script></span>.</dd>
<dt><strong><code>j</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the other term in a basis vector <span><span class="MathJax_Preview">e_i \times e_j</span><script type="math/tex">e_i \times e_j</script></span>.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>dimension of the underlying vector space <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>index of a basis vector in <span><span class="MathJax_Preview">\mathbb{R}^{n^2}</span><script type="math/tex">\mathbb{R}^{n^2}</script></span> mapped to by
<span><span class="MathJax_Preview">e_i \otimes e_j</span><script type="math/tex">e_i \otimes e_j</script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_index(i,j,n):
    r&#34;&#34;&#34;Return coordinate indices for an isomorphism
    \(\mathbb{R}^n \otimes \mathbb{R}^n \to \mathbb{R}^{n^2}\).

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for
    \(\mathbb{R}^n\), the isomorphism is realized by giving
    \(\mathbb{R}^n \otimes \mathbb{R}^n\) the ordered basis
    \[
    \{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
    \]
    represented schematically by the matrix
    \[
        \begin{pmatrix}
            0 &amp; 1 &amp; \ldots \\
            n &amp; n + 1 &amp; \ldots\\
            \vdots
        \end{pmatrix}.
    \]
    Here the (i, j) entry of the matrix gives the index of the basis
    element \(e_i \otimes e_j\).

    The inverse of this isomorphism is given by `tensor_pos`.

    Parameters
    ----------
    i : int
        index of one of the terms in a basis vector \(e_i \otimes e_j\).
    j : int
        index of the other term in a basis vector \(e_i \times e_j\).
    n : int
        dimension of the underlying vector space \(\mathbb{R}^n\)

    Returns
    -------
    int
        index of a basis vector in \(\mathbb{R}^{n^2}\) mapped to by
        \(e_i \otimes e_j\).
    &#34;&#34;&#34;
    return i * n + j</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.tensor_pos"><code class="name flex">
<span>def <span class="ident">tensor_pos</span></span>(<span>i, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Return coordinate indices for an isomorphism
<span><span class="MathJax_Preview">\mathbb{R}^{n^2} \to \mathbb{R}^n \otimes \mathbb{R}^n</span><script type="math/tex">\mathbb{R}^{n^2} \to \mathbb{R}^n \otimes \mathbb{R}^n</script></span>.</p>
<p>If <span><span class="MathJax_Preview">\{e_1, \ldots, e_n\}</span><script type="math/tex">\{e_1, \ldots, e_n\}</script></span> is the standard basis for
<span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span>, the isomorphism is realized by giving
<span><span class="MathJax_Preview">\mathbb{R}^n \otimes \mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n \otimes \mathbb{R}^n</script></span> the ordered basis
<span><span class="MathJax_Preview">
\{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
</span><script type="math/tex; mode=display">
\{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
</script></span>
represented schematically by the matrix
<span><span class="MathJax_Preview">
\begin{pmatrix}
0 &amp; 1 &amp; \ldots \\
n &amp; n + 1 &amp; \ldots\\
\vdots
\end{pmatrix}.
</span><script type="math/tex; mode=display">
\begin{pmatrix}
0 & 1 & \ldots \\
n & n + 1 & \ldots\\
\vdots
\end{pmatrix}.
</script></span>
Here the (i, j) entry of the matrix gives the index of the basis
element <span><span class="MathJax_Preview">e_i \otimes e_j</span><script type="math/tex">e_i \otimes e_j</script></span>.</p>
<p>The inverse of this isomorphism is given by <code><a title="geometry_tools.representation.tensor_index" href="#geometry_tools.representation.tensor_index">tensor_index()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>i</code></strong> :&ensp;<code>int</code></dt>
<dd>index of a basis vector in <span><span class="MathJax_Preview">\mathbb{R}^{n^2}</span><script type="math/tex">\mathbb{R}^{n^2}</script></span></dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>dimension of the underlying vector space <span><span class="MathJax_Preview">\mathbb{R}^n</span><script type="math/tex">\mathbb{R}^n</script></span></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>tuple <code>(j, k)</code> determining the monomial <span><span class="MathJax_Preview">e_j \otimes e_k</span><script type="math/tex">e_j \otimes e_k</script></span>
mapped to by given the basis vector in <span><span class="MathJax_Preview">\mathbb{R}^{n^2}</span><script type="math/tex">\mathbb{R}^{n^2}</script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_pos(i, n):
    r&#34;&#34;&#34;Return coordinate indices for an isomorphism
    \(\mathbb{R}^{n^2} \to \mathbb{R}^n \otimes \mathbb{R}^n\).

    If \(\{e_1, \ldots, e_n\}\) is the standard basis for
    \(\mathbb{R}^n\), the isomorphism is realized by giving
    \(\mathbb{R}^n \otimes \mathbb{R}^n\) the ordered basis
    \[
    \{e_1 \otimes e_1, e_1 \otimes e_2, \ldots, e_1 \otimes e_n, e_2 \otimes e_1, \ldots, \}
    \]
    represented schematically by the matrix
    \[
        \begin{pmatrix}
            0 &amp; 1 &amp; \ldots \\
            n &amp; n + 1 &amp; \ldots\\
            \vdots
        \end{pmatrix}.
    \]
    Here the (i, j) entry of the matrix gives the index of the basis
    element \(e_i \otimes e_j\).

    The inverse of this isomorphism is given by `tensor_index`.

    Parameters
    ----------
    i : int
        index of a basis vector in \(\mathbb{R}^{n^2}\)
    n : int
        dimension of the underlying vector space \(\mathbb{R}^n\)

    Returns
    -------
    tuple
        tuple `(j, k)` determining the monomial \(e_j \otimes e_k\)
        mapped to by given the basis vector in \(\mathbb{R}^{n^2}\).

    &#34;&#34;&#34;
    return int(i / n), i % n</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geometry_tools.representation.Representation"><code class="flex name class">
<span>class <span class="ident">Representation</span></span>
<span>(</span><span>representation=None, generator_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Model a representation for a finitely generated group
representation into GL(n).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>representation</code></strong> :&ensp;<code><a title="geometry_tools.representation.Representation" href="#geometry_tools.representation.Representation">Representation</a></code></dt>
<dd>Representation to copy elements from</dd>
<dt><strong><code>generator_names</code></strong> :&ensp;<code>iterable</code> of <code>strings</code></dt>
<dd>Names to use for the generators. These must be initialized
as arrays later to use the representation properly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Representation:
    &#34;&#34;&#34;Model a representation for a finitely generated group
    representation into GL(n).
    &#34;&#34;&#34;

    @property
    def dim(self):
        return self._dim

    def freely_reduced_elements(self, length, maxlen=True,
                                with_words=False):
        &#34;&#34;&#34;Return group elements, one for each freely reduced word
           in the generators.

        Parameters
        ----------
        length : int
            maximum length of a word to find a representation of
        maxlen : bool
            If `True` (the default), the returned array has one
            element for each word up to length `length`
            (inclusive). If `False`, only compute the image of words
            of length exactly equal to `length`.
        with_words : bool
            If `True`, also return the list of words corresponding to
            the computed matrices.

        Returns
        -------
        result : ndarray or tuple
            If `with_words` is `True`, `result` is a tuple `(elements, words)`,
            where `elements` is an ndarray of shape `(k, n, n)`,
            containing one matrix for each of the `k` freely reduced
            words in the generators, and `words` is a python list of
            strings, containing those words. If `with_words` is
            `False`, just return `elements`.

        &#34;&#34;&#34;
        automaton = fsa.free_automaton(list(self.semi_gens()))
        return self.automaton_accepted(automaton, length,
                                       maxlen=maxlen,
                                       with_words=with_words)

    def free_words_of_length(self, length):
        &#34;&#34;&#34;Yield freely reduced words in the generators, of a specified length.

        Parameters
        ----------
        length : int
            the length of words to return

        Yields
        ------
        word : string
            All freely reduced words in the generators of length
            `length`.

        &#34;&#34;&#34;

        if length == 0:
            yield &#34;&#34;
        else:
            for word in self.free_words_of_length(length - 1):
                for generator in self.generators:
                    if len(word) == 0 or generator != utils.invert_gen(word[-1]):
                        yield word + generator

    def free_words_less_than(self, length):
        &#34;&#34;&#34;Yield freely reduced words in the generators, up to a specified
        length.

        Parameters
        ----------
        length : int
            the maximum length of words to return

        Yields
        ------
        word : string
            All freely reduced words in the generators, up to length
            `length` (inclusive)

        &#34;&#34;&#34;
        for i in range(length):
            for word in self.free_words_of_length(i):
                yield word

    def automaton_accepted(self, automaton, length,
                           maxlen=True, with_words=False,
                           start_state=None, end_state=None,
                           precomputed=None):
        &#34;&#34;&#34;Return group elements representing words accepted by a
           finite-state automaton.

        Parameters
        ----------
        automaton : automata.fsa.FSA
            Finite-state automaton which determines the accepted words
        length : int
            Maximum length of a word to compute
        maxlen : bool
            if `True` (the default), compute representations of all
            accepted words of length up to `length`. If `False`, only
            compute representations of words whose length is exactly
            `length`.
        with_words : bool
            Whether to return a list of accepted words along with the
            computed array of images.
        start_state: object
            vertex of the automaton to use as the starting state for
            all accepted words. If `None`, then the default start
            vertex of the automaton is used. *Note*: at most one of
            `start_state` and `end_state` can be specified.
        end_state: object
            vertex of the automaton where all accepted paths must
            end. If `None`, then any ending state is allowed. *Note*:
            at most one of `start_state` and `end_state` can be
            specified.
        precomputed: dict
            dictionary giving precomputed values of this
            function. Keys are tuples of then form `(length, state)`,
            where `length` is an integer and `state` is a vertex of
            the automaton. If `None`, use an empty dictionary. In
            either case, the dictionary will be populated when the
            function is called.

        Returns
        -------
        result : ndarray or tuple
            If `with_words` is `True`, `result` is a tuple `(elements, words)`,
            where `elements` is an ndarray containing one
            matrix for each accepted word, and `words` is a list of
            strings containing the corresponding words. If
            `with_words` is `False`, just return `elements`.

        &#34;&#34;&#34;

        if start_state is not None and end_state is not None:
            raise ValueError(&#34;At most one of start_state and end_state &#34;
                             &#34;can be specified&#34;)

        as_start = True
        state = None

        if start_state is not None:
            state = start_state
            as_start = True

        if end_state is not None:
            state = end_state
            as_start = False

        return self._automaton_accepted(automaton, length,
                                        maxlen=maxlen,
                                        with_words=with_words,
                                        state=state,
                                        as_start=as_start,
                                        precomputed=precomputed)


    def _automaton_accepted(self, automaton, length,
                           state=None, as_start=True, maxlen=True,
                           precomputed=None, with_words=False):

        if precomputed is None:
            precomputed = {}

        if (length, state) in precomputed:
            return precomputed[(length, state)]

        empty_arr = np.array([]).reshape((0, self.dim, self.dim))

        if length == 0:
            if state is None or as_start or state in automaton.start_vertices:
                id_array = np.array([np.identity(self.dim)])
                if with_words:
                    return (id_array, [&#34;&#34;])
                return id_array

            if with_words:
                return (empty_arr, [])
            return empty_arr

        if state is None:
            as_start = True
            state = automaton.start_vertices[0]

        if as_start:
            adj_states = automaton.out_dict[state]
        else:
            adj_states = automaton.in_dict[state]

        if len(adj_states) == 0 and not as_start:
            if with_words:
                return (empty_arr, [])
            return empty_arr


        matrix_list = []
        accepted_words = []
        for adj_state, labels in adj_states.items():
            for label in labels:
                result = self._automaton_accepted(
                    automaton, length - 1,
                    state=adj_state,
                    as_start=as_start,
                    maxlen=maxlen,
                    precomputed=precomputed,
                    with_words=with_words
                )
                if with_words:
                    matrices, words = result
                    if as_start:
                        words = [label + word for word in words]
                    else:
                        words = [word + label for word in words]
                    accepted_words += words
                else:
                    matrices = result

                if as_start:
                    matrices = self._word_value(label) @ matrices
                else:
                    matrices = matrices @ self._word_value(label)
                matrix_list.append(matrices)

        accepted_matrices = np.concatenate(matrix_list)
        if maxlen and length &gt; 1:
            additional_result = self._automaton_accepted(
                automaton, 1,
                state=state,
                as_start=as_start,
                maxlen=False,
                with_words=with_words,
                precomputed=precomputed
            )
            if with_words:
                additional_mats, additional_words = additional_result
                accepted_words = additional_words + accepted_words
            else:
                additional_mats = additional_result

            accepted_matrices = np.concatenate(
                [additional_mats, accepted_matrices]
            )

        if with_words:
            accepted = (accepted_matrices, accepted_words)
        else:
            accepted = accepted_matrices

        precomputed[(length, state)] = accepted
        return accepted

    def elements(self, words):
        &#34;&#34;&#34;Get images of an iterable of words.

        Parameters
        ----------
        words : iterable of strings
            words to find the image of under the representation

        Returns
        -------
        ndarray
            numpy array of shape `(l, n, n)`, where `l` is the length
            of `words` and `n` is the dimension of the representation.

        &#34;&#34;&#34;
        return np.array(
            [self._word_value(word) for word in words]
        )

    def semi_gens(self):
        &#34;&#34;&#34;Iterate over group generator names for this representation.

        Only iterate over group generators (lowercase letters), not
        semigroup generators (upper and lowercase letters).

        Yields
        ------
        gen : string
            group generator names

        &#34;&#34;&#34;
        return semi_gens(self.generators.keys())

    def __init__(self, representation=None,
                 generator_names=None):
        &#34;&#34;&#34;
        Parameters
        ----------
        representation : Representation
            Representation to copy elements from
        generator_names : iterable of strings
            Names to use for the generators. These must be initialized
            as arrays later to use the representation properly.

        &#34;&#34;&#34;

        self._dim = None

        if representation is not None:
            if generator_names is None:
                generator_names = list(representation.generators)

            self.generators = {}
            for gen in semi_gens(generator_names):
                self[gen] = representation[gen]

            self._dim = representation._dim

        else:
            if generator_names is None:
                generator_names = []

            self.generators = {name[0].lower():None
                               for name in semi_gens(generator_names)}

            for gen in list(self.generators):
                self.generators[gen.upper()] = None

    def _word_value(self, word):
        matrix = np.identity(self._dim)
        for i, letter in enumerate(word):
            matrix = matrix @ self.generators[letter]
        return matrix

    def __getitem__(self, word):
        return self._word_value(word)

    def __setitem__(self, generator, matrix):
        shape = matrix.shape

        if self._dim is None:
            self._dim = shape[0]
        if shape[0] != shape[1]:
            raise ValueError(&#34;Matrices representing group elements must be square&#34;)
        if shape[0] != self._dim:
            raise ValueError(
                &#34;Every matrix in the representation must have the same shape&#34;
            )

        self.generators[generator] = matrix
        self.generators[utils.invert_gen(generator)] = np.linalg.inv(matrix)

    def tensor_product(self, rep):
        &#34;&#34;&#34;Return a tensor product of this representation with `rep`.

        Parameters
        ----------
        rep : Representation
            Representation to tensor with.

        Raises
        ------
        ValueError
            Raised if `self` and `rep` have differing generating sets.

        Returns
        -------
        tensor: Representation
            Representation giving the tensor product of self with `rep`.

        &#34;&#34;&#34;
        if set(rep.generators) != set(self.generators):
            raise ValueError(
                &#34;Cannot take a tensor product of a representation of groups with &#34;
                &#34;different presentations&#34;
            )
        else:
            product_rep = Representation()
            for gen in self.semi_gens():
                tens = np.tensordot(self[gen], rep[gen], axes=0)
                elt = np.concatenate(np.concatenate(tens, axis=1), axis=1)
                product_rep[gen] = np.matrix(elt)
            return product_rep

    def symmetric_square(self):
        &#34;&#34;&#34;Return the symmetric square of this representation.

        Returns
        -------
        square : Representation
            Symmetric square of `self`.

        &#34;&#34;&#34;

        tensor_rep = self.tensor_product(self)
        incl = symmetric_inclusion(self._dim)
        proj = symmetric_projection(self._dim)
        square_rep = Representation()
        for g in self.semi_gens():
            square_rep[g] = proj * tensor_rep[g] * incl

        return square_rep</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geometry_tools.projective.ProjectiveRepresentation" href="projective.html#geometry_tools.projective.ProjectiveRepresentation">ProjectiveRepresentation</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="geometry_tools.representation.Representation.dim"><code class="name">var <span class="ident">dim</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dim(self):
    return self._dim</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geometry_tools.representation.Representation.automaton_accepted"><code class="name flex">
<span>def <span class="ident">automaton_accepted</span></span>(<span>self, automaton, length, maxlen=True, with_words=False, start_state=None, end_state=None, precomputed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return group elements representing words accepted by a
finite-state automaton.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>automaton</code></strong> :&ensp;<code>automata.fsa.FSA</code></dt>
<dd>Finite-state automaton which determines the accepted words</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum length of a word to compute</dd>
<dt><strong><code>maxlen</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code> (the default), compute representations of all
accepted words of length up to <code>length</code>. If <code>False</code>, only
compute representations of words whose length is exactly
<code>length</code>.</dd>
<dt><strong><code>with_words</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return a list of accepted words along with the
computed array of images.</dd>
<dt><strong><code>start_state</code></strong> :&ensp;<code>object</code></dt>
<dd>vertex of the automaton to use as the starting state for
all accepted words. If <code>None</code>, then the default start
vertex of the automaton is used. <em>Note</em>: at most one of
<code>start_state</code> and <code>end_state</code> can be specified.</dd>
<dt><strong><code>end_state</code></strong> :&ensp;<code>object</code></dt>
<dd>vertex of the automaton where all accepted paths must
end. If <code>None</code>, then any ending state is allowed. <em>Note</em>:
at most one of <code>start_state</code> and <code>end_state</code> can be
specified.</dd>
<dt><strong><code>precomputed</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary giving precomputed values of this
function. Keys are tuples of then form <code>(length, state)</code>,
where <code>length</code> is an integer and <code>state</code> is a vertex of
the automaton. If <code>None</code>, use an empty dictionary. In
either case, the dictionary will be populated when the
function is called.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code> or <code>tuple</code></dt>
<dd>If <code>with_words</code> is <code>True</code>, <code>result</code> is a tuple <code>(elements, words)</code>,
where <code>elements</code> is an ndarray containing one
matrix for each accepted word, and <code>words</code> is a list of
strings containing the corresponding words. If
<code>with_words</code> is <code>False</code>, just return <code>elements</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def automaton_accepted(self, automaton, length,
                       maxlen=True, with_words=False,
                       start_state=None, end_state=None,
                       precomputed=None):
    &#34;&#34;&#34;Return group elements representing words accepted by a
       finite-state automaton.

    Parameters
    ----------
    automaton : automata.fsa.FSA
        Finite-state automaton which determines the accepted words
    length : int
        Maximum length of a word to compute
    maxlen : bool
        if `True` (the default), compute representations of all
        accepted words of length up to `length`. If `False`, only
        compute representations of words whose length is exactly
        `length`.
    with_words : bool
        Whether to return a list of accepted words along with the
        computed array of images.
    start_state: object
        vertex of the automaton to use as the starting state for
        all accepted words. If `None`, then the default start
        vertex of the automaton is used. *Note*: at most one of
        `start_state` and `end_state` can be specified.
    end_state: object
        vertex of the automaton where all accepted paths must
        end. If `None`, then any ending state is allowed. *Note*:
        at most one of `start_state` and `end_state` can be
        specified.
    precomputed: dict
        dictionary giving precomputed values of this
        function. Keys are tuples of then form `(length, state)`,
        where `length` is an integer and `state` is a vertex of
        the automaton. If `None`, use an empty dictionary. In
        either case, the dictionary will be populated when the
        function is called.

    Returns
    -------
    result : ndarray or tuple
        If `with_words` is `True`, `result` is a tuple `(elements, words)`,
        where `elements` is an ndarray containing one
        matrix for each accepted word, and `words` is a list of
        strings containing the corresponding words. If
        `with_words` is `False`, just return `elements`.

    &#34;&#34;&#34;

    if start_state is not None and end_state is not None:
        raise ValueError(&#34;At most one of start_state and end_state &#34;
                         &#34;can be specified&#34;)

    as_start = True
    state = None

    if start_state is not None:
        state = start_state
        as_start = True

    if end_state is not None:
        state = end_state
        as_start = False

    return self._automaton_accepted(automaton, length,
                                    maxlen=maxlen,
                                    with_words=with_words,
                                    state=state,
                                    as_start=as_start,
                                    precomputed=precomputed)</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.elements"><code class="name flex">
<span>def <span class="ident">elements</span></span>(<span>self, words)</span>
</code></dt>
<dd>
<div class="desc"><p>Get images of an iterable of words.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>words</code></strong> :&ensp;<code>iterable</code> of <code>strings</code></dt>
<dd>words to find the image of under the representation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>numpy array of shape <code>(l, n, n)</code>, where <code>l</code> is the length
of <code>words</code> and <code>n</code> is the dimension of the representation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def elements(self, words):
    &#34;&#34;&#34;Get images of an iterable of words.

    Parameters
    ----------
    words : iterable of strings
        words to find the image of under the representation

    Returns
    -------
    ndarray
        numpy array of shape `(l, n, n)`, where `l` is the length
        of `words` and `n` is the dimension of the representation.

    &#34;&#34;&#34;
    return np.array(
        [self._word_value(word) for word in words]
    )</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.free_words_less_than"><code class="name flex">
<span>def <span class="ident">free_words_less_than</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield freely reduced words in the generators, up to a specified
length.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the maximum length of words to return</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>word</code></strong> :&ensp;<code>string</code></dt>
<dd>All freely reduced words in the generators, up to length
<code>length</code> (inclusive)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def free_words_less_than(self, length):
    &#34;&#34;&#34;Yield freely reduced words in the generators, up to a specified
    length.

    Parameters
    ----------
    length : int
        the maximum length of words to return

    Yields
    ------
    word : string
        All freely reduced words in the generators, up to length
        `length` (inclusive)

    &#34;&#34;&#34;
    for i in range(length):
        for word in self.free_words_of_length(i):
            yield word</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.free_words_of_length"><code class="name flex">
<span>def <span class="ident">free_words_of_length</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield freely reduced words in the generators, of a specified length.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>the length of words to return</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>word</code></strong> :&ensp;<code>string</code></dt>
<dd>All freely reduced words in the generators of length
<code>length</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def free_words_of_length(self, length):
    &#34;&#34;&#34;Yield freely reduced words in the generators, of a specified length.

    Parameters
    ----------
    length : int
        the length of words to return

    Yields
    ------
    word : string
        All freely reduced words in the generators of length
        `length`.

    &#34;&#34;&#34;

    if length == 0:
        yield &#34;&#34;
    else:
        for word in self.free_words_of_length(length - 1):
            for generator in self.generators:
                if len(word) == 0 or generator != utils.invert_gen(word[-1]):
                    yield word + generator</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.freely_reduced_elements"><code class="name flex">
<span>def <span class="ident">freely_reduced_elements</span></span>(<span>self, length, maxlen=True, with_words=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return group elements, one for each freely reduced word
in the generators.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>maximum length of a word to find a representation of</dd>
<dt><strong><code>maxlen</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code> (the default), the returned array has one
element for each word up to length <code>length</code>
(inclusive). If <code>False</code>, only compute the image of words
of length exactly equal to <code>length</code>.</dd>
<dt><strong><code>with_words</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, also return the list of words corresponding to
the computed matrices.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>ndarray</code> or <code>tuple</code></dt>
<dd>If <code>with_words</code> is <code>True</code>, <code>result</code> is a tuple <code>(elements, words)</code>,
where <code>elements</code> is an ndarray of shape <code>(k, n, n)</code>,
containing one matrix for each of the <code>k</code> freely reduced
words in the generators, and <code>words</code> is a python list of
strings, containing those words. If <code>with_words</code> is
<code>False</code>, just return <code>elements</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freely_reduced_elements(self, length, maxlen=True,
                            with_words=False):
    &#34;&#34;&#34;Return group elements, one for each freely reduced word
       in the generators.

    Parameters
    ----------
    length : int
        maximum length of a word to find a representation of
    maxlen : bool
        If `True` (the default), the returned array has one
        element for each word up to length `length`
        (inclusive). If `False`, only compute the image of words
        of length exactly equal to `length`.
    with_words : bool
        If `True`, also return the list of words corresponding to
        the computed matrices.

    Returns
    -------
    result : ndarray or tuple
        If `with_words` is `True`, `result` is a tuple `(elements, words)`,
        where `elements` is an ndarray of shape `(k, n, n)`,
        containing one matrix for each of the `k` freely reduced
        words in the generators, and `words` is a python list of
        strings, containing those words. If `with_words` is
        `False`, just return `elements`.

    &#34;&#34;&#34;
    automaton = fsa.free_automaton(list(self.semi_gens()))
    return self.automaton_accepted(automaton, length,
                                   maxlen=maxlen,
                                   with_words=with_words)</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.semi_gens"><code class="name flex">
<span>def <span class="ident">semi_gens</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate over group generator names for this representation.</p>
<p>Only iterate over group generators (lowercase letters), not
semigroup generators (upper and lowercase letters).</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>gen</code></strong> :&ensp;<code>string</code></dt>
<dd>group generator names</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def semi_gens(self):
    &#34;&#34;&#34;Iterate over group generator names for this representation.

    Only iterate over group generators (lowercase letters), not
    semigroup generators (upper and lowercase letters).

    Yields
    ------
    gen : string
        group generator names

    &#34;&#34;&#34;
    return semi_gens(self.generators.keys())</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.symmetric_square"><code class="name flex">
<span>def <span class="ident">symmetric_square</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the symmetric square of this representation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>square</code></strong> :&ensp;<code><a title="geometry_tools.representation.Representation" href="#geometry_tools.representation.Representation">Representation</a></code></dt>
<dd>Symmetric square of <code>self</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symmetric_square(self):
    &#34;&#34;&#34;Return the symmetric square of this representation.

    Returns
    -------
    square : Representation
        Symmetric square of `self`.

    &#34;&#34;&#34;

    tensor_rep = self.tensor_product(self)
    incl = symmetric_inclusion(self._dim)
    proj = symmetric_projection(self._dim)
    square_rep = Representation()
    for g in self.semi_gens():
        square_rep[g] = proj * tensor_rep[g] * incl

    return square_rep</code></pre>
</details>
</dd>
<dt id="geometry_tools.representation.Representation.tensor_product"><code class="name flex">
<span>def <span class="ident">tensor_product</span></span>(<span>self, rep)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a tensor product of this representation with <code>rep</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rep</code></strong> :&ensp;<code><a title="geometry_tools.representation.Representation" href="#geometry_tools.representation.Representation">Representation</a></code></dt>
<dd>Representation to tensor with.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if <code>self</code> and <code>rep</code> have differing generating sets.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tensor</code></strong> :&ensp;<code><a title="geometry_tools.representation.Representation" href="#geometry_tools.representation.Representation">Representation</a></code></dt>
<dd>Representation giving the tensor product of self with <code>rep</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tensor_product(self, rep):
    &#34;&#34;&#34;Return a tensor product of this representation with `rep`.

    Parameters
    ----------
    rep : Representation
        Representation to tensor with.

    Raises
    ------
    ValueError
        Raised if `self` and `rep` have differing generating sets.

    Returns
    -------
    tensor: Representation
        Representation giving the tensor product of self with `rep`.

    &#34;&#34;&#34;
    if set(rep.generators) != set(self.generators):
        raise ValueError(
            &#34;Cannot take a tensor product of a representation of groups with &#34;
            &#34;different presentations&#34;
        )
    else:
        product_rep = Representation()
        for gen in self.semi_gens():
            tens = np.tensordot(self[gen], rep[gen], axes=0)
            elt = np.concatenate(np.concatenate(tens, axis=1), axis=1)
            product_rep[gen] = np.matrix(elt)
        return product_rep</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geometry_tools" href="index.html">geometry_tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geometry_tools.representation.o_to_pgl" href="#geometry_tools.representation.o_to_pgl">o_to_pgl</a></code></li>
<li><code><a title="geometry_tools.representation.semi_gens" href="#geometry_tools.representation.semi_gens">semi_gens</a></code></li>
<li><code><a title="geometry_tools.representation.sl2_irrep" href="#geometry_tools.representation.sl2_irrep">sl2_irrep</a></code></li>
<li><code><a title="geometry_tools.representation.sl2_to_so21" href="#geometry_tools.representation.sl2_to_so21">sl2_to_so21</a></code></li>
<li><code><a title="geometry_tools.representation.sym_index" href="#geometry_tools.representation.sym_index">sym_index</a></code></li>
<li><code><a title="geometry_tools.representation.symmetric_inclusion" href="#geometry_tools.representation.symmetric_inclusion">symmetric_inclusion</a></code></li>
<li><code><a title="geometry_tools.representation.symmetric_projection" href="#geometry_tools.representation.symmetric_projection">symmetric_projection</a></code></li>
<li><code><a title="geometry_tools.representation.tensor_index" href="#geometry_tools.representation.tensor_index">tensor_index</a></code></li>
<li><code><a title="geometry_tools.representation.tensor_pos" href="#geometry_tools.representation.tensor_pos">tensor_pos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geometry_tools.representation.Representation" href="#geometry_tools.representation.Representation">Representation</a></code></h4>
<ul class="">
<li><code><a title="geometry_tools.representation.Representation.automaton_accepted" href="#geometry_tools.representation.Representation.automaton_accepted">automaton_accepted</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.dim" href="#geometry_tools.representation.Representation.dim">dim</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.elements" href="#geometry_tools.representation.Representation.elements">elements</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.free_words_less_than" href="#geometry_tools.representation.Representation.free_words_less_than">free_words_less_than</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.free_words_of_length" href="#geometry_tools.representation.Representation.free_words_of_length">free_words_of_length</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.freely_reduced_elements" href="#geometry_tools.representation.Representation.freely_reduced_elements">freely_reduced_elements</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.semi_gens" href="#geometry_tools.representation.Representation.semi_gens">semi_gens</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.symmetric_square" href="#geometry_tools.representation.Representation.symmetric_square">symmetric_square</a></code></li>
<li><code><a title="geometry_tools.representation.Representation.tensor_product" href="#geometry_tools.representation.Representation.tensor_product">tensor_product</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>